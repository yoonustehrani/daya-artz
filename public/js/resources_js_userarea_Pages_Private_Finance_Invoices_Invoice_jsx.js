/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([["resources_js_userarea_Pages_Private_Finance_Invoices_Invoice_jsx"],{

/***/ "./resources/js/components/copy.js":
/*!*****************************************!*\
  !*** ./resources/js/components/copy.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ copyToClipboard)\n/* harmony export */ });\n/* harmony import */ var _services_AlertService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../services/AlertService */ \"./resources/js/services/AlertService.js\");\n\nfunction copyToClipboard(code) {\n  var title = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"متن مورد نظر\";\n  navigator.permissions.query({\n    name: \"clipboard-write\"\n  }).then(function (result) {\n    if (result.state == \"granted\" || result.state == \"prompt\") {\n      navigator.clipboard.writeText(code).then(function () {\n        new _services_AlertService__WEBPACK_IMPORTED_MODULE_0__[\"default\"]().success({\n          timer: 2000,\n          title: \"\".concat(title, \" \\u062F\\u0631 \\u062D\\u0627\\u0641\\u0638\\u0647 \\u0645\\u0648\\u0642\\u062A \\u06A9\\u067E\\u06CC \\u0634\\u062F\")\n        });\n      }, function () {\n        new _services_AlertService__WEBPACK_IMPORTED_MODULE_0__[\"default\"]().error({\n          timer: 2000,\n          title: 'متاسفانه در هنگام کپی مشکلی پیش آمد'\n        });\n      });\n    }\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9jb3B5LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFFZSxTQUFTQyxlQUFULENBQXlCQyxJQUF6QixFQUFxRDtFQUFBLElBQXRCQyxLQUFzQix1RUFBaEIsY0FBZ0I7RUFDaEVDLFNBQVMsQ0FBQ0MsV0FBVixDQUFzQkMsS0FBdEIsQ0FBNEI7SUFBQ0MsSUFBSSxFQUFFO0VBQVAsQ0FBNUIsRUFBdURDLElBQXZELENBQTRELFVBQUFDLE1BQU0sRUFBSTtJQUNsRSxJQUFJQSxNQUFNLENBQUNDLEtBQVAsSUFBZ0IsU0FBaEIsSUFBNkJELE1BQU0sQ0FBQ0MsS0FBUCxJQUFnQixRQUFqRCxFQUEyRDtNQUN2RE4sU0FBUyxDQUFDTyxTQUFWLENBQW9CQyxTQUFwQixDQUE4QlYsSUFBOUIsRUFBb0NNLElBQXBDLENBQXlDLFlBQVc7UUFDL0MsSUFBSVIsOERBQUosRUFBRCxDQUFtQmEsT0FBbkIsQ0FBMkI7VUFBQ0MsS0FBSyxFQUFFLElBQVI7VUFBY1gsS0FBSyxZQUFLQSxLQUFMO1FBQW5CLENBQTNCO01BQ0gsQ0FGRCxFQUVHLFlBQU07UUFDSixJQUFJSCw4REFBSixFQUFELENBQW1CZSxLQUFuQixDQUF5QjtVQUFDRCxLQUFLLEVBQUUsSUFBUjtVQUFjWCxLQUFLLEVBQUU7UUFBckIsQ0FBekI7TUFDSCxDQUpEO0lBS0g7RUFDSixDQVJEO0FBU0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9jb3B5LmpzPzQwMWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEFsZXJ0U2VydmljZSBmcm9tIFwiLi4vc2VydmljZXMvQWxlcnRTZXJ2aWNlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvcHlUb0NsaXBib2FyZChjb2RlLCB0aXRsZT1cItmF2KrZhiDZhdmI2LHYryDZhti42LFcIikge1xuICAgIG5hdmlnYXRvci5wZXJtaXNzaW9ucy5xdWVyeSh7bmFtZTogXCJjbGlwYm9hcmQtd3JpdGVcIn0pLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgaWYgKHJlc3VsdC5zdGF0ZSA9PSBcImdyYW50ZWRcIiB8fCByZXN1bHQuc3RhdGUgPT0gXCJwcm9tcHRcIikge1xuICAgICAgICAgICAgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQoY29kZSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAobmV3IEFsZXJ0U2VydmljZSkuc3VjY2Vzcyh7dGltZXI6IDIwMDAsIHRpdGxlOiBgJHt0aXRsZX0g2K/YsSDYrdin2YHYuNmHINmF2YjZgtiqINqp2b7bjCDYtNivYH0pXG4gICAgICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgKG5ldyBBbGVydFNlcnZpY2UpLmVycm9yKHt0aW1lcjogMjAwMCwgdGl0bGU6ICfZhdiq2KfYs9mB2KfZhtmHINiv2LEg2YfZhtqv2KfZhSDaqdm+24wg2YXYtNqp2YTbjCDZvtuM2LQg2KLZhdivJ30pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufSJdLCJuYW1lcyI6WyJBbGVydFNlcnZpY2UiLCJjb3B5VG9DbGlwYm9hcmQiLCJjb2RlIiwidGl0bGUiLCJuYXZpZ2F0b3IiLCJwZXJtaXNzaW9ucyIsInF1ZXJ5IiwibmFtZSIsInRoZW4iLCJyZXN1bHQiLCJzdGF0ZSIsImNsaXBib2FyZCIsIndyaXRlVGV4dCIsInN1Y2Nlc3MiLCJ0aW1lciIsImVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/components/copy.js\n");

/***/ }),

/***/ "./resources/js/components/datepicker.js":
/*!***********************************************!*\
  !*** ./resources/js/components/datepicker.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("window.persianDatepicker = __webpack_require__(/*! persian-datepicker/dist/js/persian-datepicker */ \"./node_modules/persian-datepicker/dist/js/persian-datepicker.js\");\nwindow.persianDate = __webpack_require__(/*! persian-date */ \"./node_modules/persian-date/dist/persian-date.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9kYXRlcGlja2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBQSxNQUFNLENBQUNDLGlCQUFQLEdBQTJCQyxtQkFBTyxDQUFDLHNIQUFELENBQWxDO0FBQ0FGLE1BQU0sQ0FBQ0csV0FBUCxHQUFxQkQsbUJBQU8sQ0FBQyxzRUFBRCxDQUE1QiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL2RhdGVwaWNrZXIuanM/ZTM2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJ3aW5kb3cucGVyc2lhbkRhdGVwaWNrZXIgPSByZXF1aXJlKCdwZXJzaWFuLWRhdGVwaWNrZXIvZGlzdC9qcy9wZXJzaWFuLWRhdGVwaWNrZXInKVxud2luZG93LnBlcnNpYW5EYXRlID0gcmVxdWlyZShcInBlcnNpYW4tZGF0ZVwiKSJdLCJuYW1lcyI6WyJ3aW5kb3ciLCJwZXJzaWFuRGF0ZXBpY2tlciIsInJlcXVpcmUiLCJwZXJzaWFuRGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/components/datepicker.js\n");

/***/ }),

/***/ "./resources/js/helpers/index.js":
/*!***************************************!*\
  !*** ./resources/js/helpers/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NestedObj: () => (/* binding */ NestedObj),\n/* harmony export */   isObjEmpty: () => (/* binding */ isObjEmpty),\n/* harmony export */   number_format: () => (/* binding */ number_format),\n/* harmony export */   translate: () => (/* binding */ translate)\n/* harmony export */ });\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nvar NestedObj = /*#__PURE__*/function () {\n  function NestedObj(targetObj, path) {\n    var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    _classCallCheck(this, NestedObj);\n\n    this.targetObj = JSON.parse(JSON.stringify(targetObj));\n    this.value = value;\n    var keys = path.split(\".\");\n\n    if (keys.length > 1) {\n      this.lastKey = keys.pop();\n      this.lastObj = keys.reduce(function (targetObj, key) {\n        return targetObj[key] = targetObj[key] && !Array.isArray(targetObj[key]) ? targetObj[key] : {};\n      }, this.targetObj);\n    } else {\n      this.lastObj = this.targetObj;\n      this.lastKey = path;\n    }\n  }\n\n  _createClass(NestedObj, [{\n    key: \"make\",\n    value: function make() {\n      this.lastObj[this.lastKey] = this.value;\n      return this.targetObj;\n    }\n  }, {\n    key: \"get\",\n    value: function get() {\n      var _this$lastObj$this$la;\n\n      return (_this$lastObj$this$la = this.lastObj[this.lastKey]) !== null && _this$lastObj$this$la !== void 0 ? _this$lastObj$this$la : \"\";\n    }\n  }]);\n\n  return NestedObj;\n}();\nfunction isObjEmpty(obj) {\n  return !Object.keys(obj).length;\n}\nvar translate = function translate(key) {\n  var _dic;\n\n  var dic = (_dic = {\n    // order methods\n    \"automate\": \"اتومات\",\n    \"manual\": \"دستی\",\n    \"just-recieved\": \"دریافت شده\",\n    \"in-progress\": \"در حال انجام\",\n    \"finished\": \"تمام شده\",\n    // statuses\n    \"submitted\": \"دریافت سفارش\",\n    \"reviewed\": \"بررسی جزئیات\",\n    \"designing\": \"در دست طراحی\",\n    \"ready\": \"آماده تحویل\",\n    \"editing\": \"در حال ویرایش\",\n    \"canceled\": \"لغو شده\",\n    \"suspended\": \"تعلیق شده\"\n  }, _defineProperty(_dic, \"finished\", \"اتمام سفارش\"), _defineProperty(_dic, \"checked-out\", \"تسویه و تحویل\"), _dic);\n  return dic[key];\n};\nvar number_format = function number_format(number) {\n  var appendix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return \"\".concat(Number(number).toLocaleString('en-US')).concat(appendix ? ' تومان' : '');\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvaGVscGVycy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBTyxJQUFNQSxTQUFiO0VBQ0ksbUJBQVlDLFNBQVosRUFBdUJDLElBQXZCLEVBQXlDO0lBQUEsSUFBWkMsS0FBWSx1RUFBTixJQUFNOztJQUFBOztJQUNyQyxLQUFLRixTQUFMLEdBQWlCRyxJQUFJLENBQUNDLEtBQUwsQ0FBV0QsSUFBSSxDQUFDRSxTQUFMLENBQWVMLFNBQWYsQ0FBWCxDQUFqQjtJQUNBLEtBQUtFLEtBQUwsR0FBYUEsS0FBYjtJQUNBLElBQUlJLElBQUksR0FBR0wsSUFBSSxDQUFDTSxLQUFMLENBQVcsR0FBWCxDQUFYOztJQUNBLElBQUlELElBQUksQ0FBQ0UsTUFBTCxHQUFjLENBQWxCLEVBQXFCO01BQ2pCLEtBQUtDLE9BQUwsR0FBZUgsSUFBSSxDQUFDSSxHQUFMLEVBQWY7TUFDQSxLQUFLQyxPQUFMLEdBQWVMLElBQUksQ0FBQ00sTUFBTCxDQUFZLFVBQUNaLFNBQUQsRUFBWWEsR0FBWjtRQUFBLE9BQ3ZCYixTQUFTLENBQUNhLEdBQUQsQ0FBVCxHQUFpQmIsU0FBUyxDQUFDYSxHQUFELENBQVQsSUFBa0IsQ0FBQ0MsS0FBSyxDQUFDQyxPQUFOLENBQWNmLFNBQVMsQ0FBQ2EsR0FBRCxDQUF2QixDQUFuQixHQUFtRGIsU0FBUyxDQUFDYSxHQUFELENBQTVELEdBQW9FLEVBRDlEO01BQUEsQ0FBWixFQUViLEtBQUtiLFNBRlEsQ0FBZjtJQUdILENBTEQsTUFLTztNQUNILEtBQUtXLE9BQUwsR0FBZSxLQUFLWCxTQUFwQjtNQUNBLEtBQUtTLE9BQUwsR0FBZVIsSUFBZjtJQUNIO0VBQ0o7O0VBZEw7SUFBQTtJQUFBLE9BZ0JJLGdCQUFPO01BQ0gsS0FBS1UsT0FBTCxDQUFhLEtBQUtGLE9BQWxCLElBQTZCLEtBQUtQLEtBQWxDO01BQ0EsT0FBTyxLQUFLRixTQUFaO0lBQ0g7RUFuQkw7SUFBQTtJQUFBLE9BcUJJLGVBQU07TUFBQTs7TUFDRixnQ0FBTyxLQUFLVyxPQUFMLENBQWEsS0FBS0YsT0FBbEIsQ0FBUCx5RUFBbUMsRUFBbkM7SUFDSDtFQXZCTDs7RUFBQTtBQUFBO0FBMEJPLFNBQVNPLFVBQVQsQ0FBb0JDLEdBQXBCLEVBQXlCO0VBQzVCLE9BQU8sQ0FBQ0MsTUFBTSxDQUFDWixJQUFQLENBQVlXLEdBQVosRUFBaUJULE1BQXpCO0FBQ0g7QUFFTSxJQUFNVyxTQUFTLEdBQUcsU0FBWkEsU0FBWSxDQUFDTixHQUFELEVBQVM7RUFBQTs7RUFDOUIsSUFBTU8sR0FBRztJQUNMO0lBQ0EsWUFBWSxRQUZQO0lBR0wsVUFBVSxNQUhMO0lBSUwsaUJBQWlCLFlBSlo7SUFLTCxlQUFlLGNBTFY7SUFNTCxZQUFZLFVBTlA7SUFPTDtJQUNBLGFBQWEsY0FSUjtJQVNMLFlBQVksY0FUUDtJQVVMLGFBQWEsY0FWUjtJQVdMLFNBQVMsYUFYSjtJQVlMLFdBQVcsZUFaTjtJQWFMLFlBQVksU0FiUDtJQWNMLGFBQWE7RUFkUixxQ0FlTyxhQWZQLHlCQWdCTCxhQWhCSyxFQWdCVSxlQWhCVixRQUFUO0VBa0JBLE9BQU9BLEdBQUcsQ0FBQ1AsR0FBRCxDQUFWO0FBQ0gsQ0FwQk07QUFzQkEsSUFBTVEsYUFBYSxHQUFHLFNBQWhCQSxhQUFnQixDQUFDQyxNQUFEO0VBQUEsSUFBU0MsUUFBVCx1RUFBb0IsS0FBcEI7RUFBQSxpQkFBaUNDLE1BQU0sQ0FBQ0YsTUFBRCxDQUFOLENBQWVHLGNBQWYsQ0FBOEIsT0FBOUIsQ0FBakMsU0FBMEVGLFFBQVEsR0FBRyxRQUFILEdBQWMsRUFBaEc7QUFBQSxDQUF0QiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9oZWxwZXJzL2luZGV4LmpzPzlkNjYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIE5lc3RlZE9iaiB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0T2JqLCBwYXRoLCB2YWx1ZT1udWxsKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0T2JqID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0YXJnZXRPYmopKVxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgICAgICAgbGV0IGtleXMgPSBwYXRoLnNwbGl0KFwiLlwiKVxuICAgICAgICBpZiAoa2V5cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RLZXkgPSBrZXlzLnBvcCgpXG4gICAgICAgICAgICB0aGlzLmxhc3RPYmogPSBrZXlzLnJlZHVjZSgodGFyZ2V0T2JqLCBrZXkpID0+IFxuICAgICAgICAgICAgICAgIHRhcmdldE9ialtrZXldID0gdGFyZ2V0T2JqW2tleV0gJiYgIUFycmF5LmlzQXJyYXkodGFyZ2V0T2JqW2tleV0pID8gdGFyZ2V0T2JqW2tleV0gOiB7fVxuICAgICAgICAgICAgLCB0aGlzLnRhcmdldE9iailcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGFzdE9iaiA9IHRoaXMudGFyZ2V0T2JqXG4gICAgICAgICAgICB0aGlzLmxhc3RLZXkgPSBwYXRoXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtYWtlKCkge1xuICAgICAgICB0aGlzLmxhc3RPYmpbdGhpcy5sYXN0S2V5XSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzLnRhcmdldE9ialxuICAgIH1cblxuICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdE9ialt0aGlzLmxhc3RLZXldPz9cIlwiXG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNPYmpFbXB0eShvYmopIHtcbiAgICByZXR1cm4gIU9iamVjdC5rZXlzKG9iaikubGVuZ3RoXG59XG5cbmV4cG9ydCBjb25zdCB0cmFuc2xhdGUgPSAoa2V5KSA9PiB7XG4gICAgY29uc3QgZGljID0ge1xuICAgICAgICAvLyBvcmRlciBtZXRob2RzXG4gICAgICAgIFwiYXV0b21hdGVcIjogXCLYp9iq2YjZhdin2KpcIixcbiAgICAgICAgXCJtYW51YWxcIjogXCLYr9iz2KrbjFwiLFxuICAgICAgICBcImp1c3QtcmVjaWV2ZWRcIjogXCLYr9ix24zYp9mB2Kog2LTYr9mHXCIsXG4gICAgICAgIFwiaW4tcHJvZ3Jlc3NcIjogXCLYr9ixINit2KfZhCDYp9mG2KzYp9mFXCIsXG4gICAgICAgIFwiZmluaXNoZWRcIjogXCLYqtmF2KfZhSDYtNiv2YdcIixcbiAgICAgICAgLy8gc3RhdHVzZXNcbiAgICAgICAgXCJzdWJtaXR0ZWRcIjogXCLYr9ix24zYp9mB2Kog2LPZgdin2LHYtFwiLFxuICAgICAgICBcInJldmlld2VkXCI6IFwi2KjYsdix2LPbjCDYrNiy2KbbjNin2KpcIixcbiAgICAgICAgXCJkZXNpZ25pbmdcIjogXCLYr9ixINiv2LPYqiDYt9ix2KfYrduMXCIsXG4gICAgICAgIFwicmVhZHlcIjogXCLYotmF2KfYr9mHINiq2K3ZiNuM2YRcIixcbiAgICAgICAgXCJlZGl0aW5nXCI6IFwi2K/YsSDYrdin2YQg2YjbjNix2KfbjNi0XCIsXG4gICAgICAgIFwiY2FuY2VsZWRcIjogXCLZhNi62Ygg2LTYr9mHXCIsXG4gICAgICAgIFwic3VzcGVuZGVkXCI6IFwi2KrYudmE24zZgiDYtNiv2YdcIixcbiAgICAgICAgXCJmaW5pc2hlZFwiOiBcItin2KrZhdin2YUg2LPZgdin2LHYtFwiLFxuICAgICAgICBcImNoZWNrZWQtb3V0XCI6IFwi2KrYs9mI24zZhyDZiCDYqtit2YjbjNmEXCJcbiAgICB9XG4gICAgcmV0dXJuIGRpY1trZXldXG59XG5cbmV4cG9ydCBjb25zdCBudW1iZXJfZm9ybWF0ID0gKG51bWJlciwgYXBwZW5kaXggPSBmYWxzZSkgPT4gYCR7TnVtYmVyKG51bWJlcikudG9Mb2NhbGVTdHJpbmcoJ2VuLVVTJyl9JHthcHBlbmRpeCA/ICcg2KrZiNmF2KfZhicgOiAnJ31gIl0sIm5hbWVzIjpbIk5lc3RlZE9iaiIsInRhcmdldE9iaiIsInBhdGgiLCJ2YWx1ZSIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsImtleXMiLCJzcGxpdCIsImxlbmd0aCIsImxhc3RLZXkiLCJwb3AiLCJsYXN0T2JqIiwicmVkdWNlIiwia2V5IiwiQXJyYXkiLCJpc0FycmF5IiwiaXNPYmpFbXB0eSIsIm9iaiIsIk9iamVjdCIsInRyYW5zbGF0ZSIsImRpYyIsIm51bWJlcl9mb3JtYXQiLCJudW1iZXIiLCJhcHBlbmRpeCIsIk51bWJlciIsInRvTG9jYWxlU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/helpers/index.js\n");

/***/ }),

/***/ "./resources/js/userarea/Pages/Private/Finance/Invoices/Invoice.jsx":
/*!**************************************************************************!*\
  !*** ./resources/js/userarea/Pages/Private/Finance/Invoices/Invoice.jsx ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-redux */ \"./node_modules/react-redux/es/index.js\");\n/* harmony import */ var _components_LoaderComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../components/LoaderComponent */ \"./resources/js/userarea/components/LoaderComponent.jsx\");\n/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../hooks */ \"./resources/js/userarea/hooks.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../../helpers */ \"./resources/js/helpers/index.js\");\n/* harmony import */ var _components_Bills__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/Bills */ \"./resources/js/userarea/Pages/Private/Finance/Invoices/components/Bills.jsx\");\n/* harmony import */ var _components_PaymentMethod__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/PaymentMethod */ \"./resources/js/userarea/Pages/Private/Finance/Invoices/components/PaymentMethod.jsx\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n // custom components\n\n\n\n\n\n\n\nvar Invoice = /*#__PURE__*/function (_Component) {\n  _inherits(Invoice, _Component);\n\n  var _super = _createSuper(Invoice);\n\n  function Invoice(props) {\n    var _this;\n\n    _classCallCheck(this, Invoice);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"loadInvoice\", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var invoiceId, response, order, invoice, total, total_off, _final;\n\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              invoiceId = _this.props.params.invoiceId;\n              _context.next = 3;\n              return _this.http.get(\"invoices/\".concat(invoiceId));\n\n            case 3:\n              response = _context.sent;\n\n              if (response.okay) {\n                order = response.order, invoice = response.invoice;\n                document.title = \"\".concat(invoice.active ? ' ' : 'پیش ', \"\\u0641\\u0627\\u06A9\\u062A\\u0648\\u0631 \\u0634\\u0645\\u0627\\u0631\\u0647 \").concat(invoice.id);\n\n                invoice.calculate_off = function (total) {\n                  var offer = invoice.offer;\n\n                  if (offer) {\n                    if (offer.value_type === 'percentage') {\n                      return total / 100 * offer.value;\n                    }\n\n                    return offer.value;\n                  }\n\n                  return 0;\n                };\n\n                total = 0;\n                order.items.forEach(function (item) {\n                  item.amount = item.total - item.off;\n                  total += item.amount;\n                  return item;\n                });\n                total_off = invoice.multipay ? 0 : invoice.calculate_off(total), _final = total - total_off;\n\n                _this.setState({\n                  invoice: _objectSpread(_objectSpread({}, invoice), {}, {\n                    calc: {\n                      total: total,\n                      total_off: total_off,\n                      \"final\": _final,\n                      total_tax: _final / 100 * 9\n                    }\n                  }),\n                  order: order,\n                  loading: false\n                });\n              }\n\n            case 5:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    })));\n\n    _defineProperty(_assertThisInitialized(_this), \"activateInvoice\", function (newInvoice) {\n      _this.setState(function (prev) {\n        return {\n          invoice: _objectSpread(_objectSpread({}, prev.invoice), newInvoice),\n          loading: false\n        };\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"setMultiPay\", function (_boolean) {\n      _this.setState(function (prev) {\n        return {\n          invoice: _objectSpread(_objectSpread({}, prev.invoice), {}, {\n            multipay: _boolean\n          })\n        };\n      });\n    });\n\n    _this.state = {\n      invoice: null,\n      order: null,\n      loading: true\n    };\n    _this.http = (0,_hooks__WEBPACK_IMPORTED_MODULE_3__.useHttpService)('/userarea/');\n    return _this;\n  }\n\n  _createClass(Invoice, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.loadInvoice();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          user = _this$props.user,\n          company = _this$props.company;\n      var _this$state = this.state,\n          invoice = _this$state.invoice,\n          order = _this$state.order,\n          loading = _this$state.loading;\n      return loading ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_components_LoaderComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {}) : /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(\"div\", {\n        className: \"factor-container p-3 p-md-4 \",\n        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"div\", {\n          className: \"factor-first-section\",\n          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(\"div\", {\n            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(\"ul\", {\n              children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(\"li\", {\n                children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(\"span\", {\n                  children: [invoice.active ? ' ' : 'پیش ', \" \\u0641\\u0627\\u06A9\\u062A\\u0648\\u0631 \\u0628\\u0631\\u0627\\u06CC :\"]\n                }), \" \\u0622\\u0642\\u0627 / \\u062E\\u0627\\u0646\\u0645 \", user.lastname]\n              }), company && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.Fragment, {\n                children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(\"li\", {\n                  children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"span\", {\n                    children: \"\\u0646\\u0627\\u0645 \\u0634\\u0631\\u06A9\\u062A:\"\n                  }), \" \", [company.title, company.title_en].join(' - ')]\n                }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(\"li\", {\n                  children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"span\", {\n                    children: \"\\u0622\\u062F\\u0631\\u0633 \\u0634\\u0631\\u06A9\\u062A:\"\n                  }), \" \\u062E\\u06CC\\u0627\\u0628\\u0627\\u0646 \\u0633\\u062C\\u0627\\u062F - \\u0633\\u062C\\u0627\\u062F 21 - \\u067E\\u0644\\u0627\\u06A9 124\"]\n                })]\n              }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"li\", {\n                className: \"contact-info\",\n                children: user.email\n              }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"li\", {\n                className: \"contact-info\",\n                children: user.phone_number\n              })]\n            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(\"ul\", {\n              children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(\"li\", {\n                children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"span\", {\n                  children: \"\\u0634\\u0645\\u0627\\u0631\\u0647 \\u0641\\u0627\\u06A9\\u062A\\u0648\\u0631:\"\n                }), invoice.id]\n              }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(\"li\", {\n                children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"span\", {\n                  children: \"\\u0634\\u0645\\u0627\\u0631\\u0647 \\u0633\\u0641\\u0627\\u0631\\u0634:\"\n                }), order.code]\n              }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(\"li\", {\n                children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"span\", {\n                  children: \"\\u062A\\u0627\\u0631\\u06CC\\u062E \\u0641\\u0627\\u06A9\\u062A\\u0648\\u0631:\"\n                }), (0,_hooks__WEBPACK_IMPORTED_MODULE_3__.useJalaliDate)(invoice.created_at).format('jYYYY/jMM/jDD')]\n              })]\n            })]\n          })\n        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(\"div\", {\n          className: \"float-left w-100 table-responsive mt-4\",\n          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"h3\", {\n            className: \"factor-section-title\",\n            children: \"\\u0622\\u06CC\\u062A\\u0645 \\u0647\\u0627\\u06CC \\u0633\\u0641\\u0627\\u0631\\u0634\"\n          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(\"table\", {\n            className: \"table text-center\",\n            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"thead\", {\n              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(\"tr\", {\n                children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"th\", {\n                  children: \"#\"\n                }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"th\", {\n                  children: \"\\u0639\\u0646\\u0648\\u0627\\u0646 \\u0633\\u0641\\u0627\\u0631\\u0634\"\n                }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"th\", {\n                  children: \"\\u0642\\u06CC\\u0645\\u062A\"\n                }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"th\", {\n                  children: \"\\u062A\\u062E\\u0641\\u06CC\\u0641\"\n                }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"th\", {\n                  children: \"\\u0645\\u062C\\u0645\\u0648\\u0639 \\u0646\\u0647\\u0627\\u06CC\\u06CC\"\n                })]\n              })\n            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"tbody\", {\n              children: order && order.items.map(function (item, i) {\n                return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(\"tr\", {\n                  children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"th\", {\n                    children: i + 1\n                  }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"th\", {\n                    scope: \"row\",\n                    children: item.title\n                  }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"td\", {\n                    children: (0,_helpers__WEBPACK_IMPORTED_MODULE_4__.number_format)(item.total, true)\n                  }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"td\", {\n                    children: (0,_helpers__WEBPACK_IMPORTED_MODULE_4__.number_format)(item.off, true)\n                  }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"td\", {\n                    children: (0,_helpers__WEBPACK_IMPORTED_MODULE_4__.number_format)(item.amount, true)\n                  })]\n                }, item.id);\n              })\n            })]\n          })]\n        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(\"div\", {\n          className: \"float-left w-100 table-responsive factor-info mt-4\",\n          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"h3\", {\n            className: \"factor-section-title\",\n            children: \"\\u0647\\u0632\\u06CC\\u0646\\u0647 \\u06A9\\u0644\\u06CC\"\n          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"table\", {\n            className: \"table\",\n            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(\"tbody\", {\n              children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(\"tr\", {\n                children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"th\", {\n                  scope: \"row\",\n                  children: \"\\u062C\\u0645\\u0639 \\u06A9\\u0644\"\n                }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"td\", {\n                  children: (0,_helpers__WEBPACK_IMPORTED_MODULE_4__.number_format)(invoice.calc.total, true)\n                })]\n              }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(\"tr\", {\n                children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"th\", {\n                  scope: \"row\",\n                  children: \"\\u062A\\u062E\\u0641\\u06CC\\u0641 \\u0641\\u0627\\u06A9\\u062A\\u0648\\u0631\"\n                }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"td\", {\n                  children: invoice.multipay ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"span\", {\n                    className: \"text-danger\",\n                    children: \"\\u062F\\u0631 \\u0631\\u0648\\u0634 \\u067E\\u0631\\u062F\\u0627\\u062E\\u062A \\u062C\\u0632\\u0626\\u06CC \\u062A\\u062E\\u0641\\u06CC\\u0641 \\u06A9\\u0644\\u06CC \\u0627\\u0639\\u0645\\u0627\\u0644 \\u0646\\u0645\\u06CC \\u0634\\u0648\\u062F.\"\n                  }) : (0,_helpers__WEBPACK_IMPORTED_MODULE_4__.number_format)(invoice.calc.total_off, true)\n                })]\n              }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(\"tr\", {\n                children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"th\", {\n                  scope: \"row\",\n                  children: \"\\u062C\\u0645\\u0639 \\u06A9\\u0644 \\u067E\\u0633 \\u0627\\u0632 \\u06A9\\u0633\\u0631 \\u062A\\u062E\\u0641\\u06CC\\u0641\"\n                }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"td\", {\n                  children: (0,_helpers__WEBPACK_IMPORTED_MODULE_4__.number_format)(invoice.calc[\"final\"], true)\n                })]\n              }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(\"tr\", {\n                children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"th\", {\n                  scope: \"row\",\n                  children: \"9% \\u0645\\u0627\\u0644\\u06CC\\u0627\\u062A \\u0627\\u0631\\u0632\\u0634 \\u0627\\u0641\\u0632\\u0648\\u062F\\u0647\"\n                }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"td\", {\n                  children: (0,_helpers__WEBPACK_IMPORTED_MODULE_4__.number_format)(invoice.calc.total_tax, true)\n                })]\n              }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(\"tr\", {\n                children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"th\", {\n                  scope: \"row\",\n                  children: \"\\u0642\\u0627\\u0628\\u0644 \\u067E\\u0631\\u062F\\u0627\\u062E\\u062A\"\n                }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"td\", {\n                  children: (0,_helpers__WEBPACK_IMPORTED_MODULE_4__.number_format)(invoice.calc[\"final\"] + invoice.calc.total_tax, true)\n                })]\n              }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(\"tr\", {\n                children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"th\", {\n                  scope: \"row\",\n                  children: \"\\u0631\\u0648\\u0634 \\u067E\\u0631\\u062F\\u0627\\u062E\\u062A\\u06CC\"\n                }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(\"td\", {\n                  children: invoice.multipay ? 'جزئی' : 'کلی'\n                })]\n              })]\n            })\n          })]\n        }), invoice.active && invoice.bills ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_components_Bills__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n          bills: invoice.bills\n        }) : /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_components_PaymentMethod__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n          invoice: invoice,\n          setMultiPay: this.setMultiPay,\n          onActive: this.activateInvoice\n        })]\n      });\n    }\n  }]);\n\n  return Invoice;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\n\nvar mapStateToProps = function mapStateToProps(state) {\n  return {\n    user: state.auth.user,\n    company: state.user.company\n  };\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,react_redux__WEBPACK_IMPORTED_MODULE_1__.connect)(mapStateToProps)(Invoice));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvdXNlcmFyZWEvUGFnZXMvUHJpdmF0ZS9GaW5hbmNlL0ludm9pY2VzL0ludm9pY2UuanN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OytDQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQURBO0FBQ0E7QUFDQTtBQUNBO0NBRUE7O0FBQ0E7QUFDQTs7Ozs7SUFFTVM7Ozs7O0VBQ0YsaUJBQVlDLEtBQVosRUFBbUI7SUFBQTs7SUFBQTs7SUFDZiwwQkFBTUEsS0FBTjs7SUFEZSxzSUFTTDtNQUFBOztNQUFBO1FBQUE7VUFBQTtZQUFBO2NBQ0xDLFNBREssR0FDUSxNQUFLRCxLQUFMLENBQVdFLE1BRG5CLENBQ0xELFNBREs7Y0FBQTtjQUFBLE9BRWEsTUFBS0UsSUFBTCxDQUFVQyxHQUFWLG9CQUEwQkgsU0FBMUIsRUFGYjs7WUFBQTtjQUVKSSxRQUZJOztjQUdWLElBQUlBLFFBQVEsQ0FBQ0MsSUFBYixFQUFtQjtnQkFDVEMsS0FEUyxHQUNVRixRQURWLENBQ1RFLEtBRFMsRUFDRkMsT0FERSxHQUNVSCxRQURWLENBQ0ZHLE9BREU7Z0JBRWZDLFFBQVEsQ0FBQ0MsS0FBVCxhQUFvQkYsT0FBTyxDQUFDRyxNQUFSLEdBQWlCLEdBQWpCLEdBQXVCLE1BQTNDLGlGQUFpRUgsT0FBTyxDQUFDSSxFQUF6RTs7Z0JBQ0FKLE9BQU8sQ0FBQ0ssYUFBUixHQUF3QixVQUFBQyxLQUFLLEVBQUk7a0JBQzdCLElBQUtDLEtBQUwsR0FBY1AsT0FBZCxDQUFLTyxLQUFMOztrQkFDQSxJQUFJQSxLQUFKLEVBQVc7b0JBQ1AsSUFBSUEsS0FBSyxDQUFDQyxVQUFOLEtBQXFCLFlBQXpCLEVBQXVDO3NCQUNuQyxPQUFRRixLQUFLLEdBQUcsR0FBVCxHQUFnQkMsS0FBSyxDQUFDRSxLQUE3QjtvQkFDSDs7b0JBQ0QsT0FBT0YsS0FBSyxDQUFDRSxLQUFiO2tCQUNIOztrQkFDRCxPQUFPLENBQVA7Z0JBQ0gsQ0FURDs7Z0JBVUlILEtBYlcs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ZUFBRCxDQUFQLENBQXlCbkQsT0FBekIsQ0FBZiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy91c2VyYXJlYS9QYWdlcy9Qcml2YXRlL0ZpbmFuY2UvSW52b2ljZXMvSW52b2ljZS5qc3g/MjJiMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCBMb2FkZXJDb21wb25lbnQgZnJvbSAnLi4vLi4vLi4vLi4vY29tcG9uZW50cy9Mb2FkZXJDb21wb25lbnQnO1xuaW1wb3J0IHsgdXNlSHR0cFNlcnZpY2UsIHVzZUphbGFsaURhdGUgfSBmcm9tICcuLi8uLi8uLi8uLi9ob29rcyc7XG5pbXBvcnQgeyBudW1iZXJfZm9ybWF0IH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vaGVscGVycyc7XG4vLyBjdXN0b20gY29tcG9uZW50c1xuaW1wb3J0IEJpbGxzIGZyb20nLi9jb21wb25lbnRzL0JpbGxzJztcbmltcG9ydCBQYXltZW50TWV0aG9kIGZyb20gJy4vY29tcG9uZW50cy9QYXltZW50TWV0aG9kJztcblxuY2xhc3MgSW52b2ljZSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBpbnZvaWNlOiBudWxsLFxuICAgICAgICAgICAgb3JkZXI6IG51bGwsXG4gICAgICAgICAgICBsb2FkaW5nOiB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5odHRwID0gdXNlSHR0cFNlcnZpY2UoJy91c2VyYXJlYS8nKVxuICAgIH1cbiAgICBsb2FkSW52b2ljZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgbGV0IHtpbnZvaWNlSWR9ID0gdGhpcy5wcm9wcy5wYXJhbXNcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHAuZ2V0KGBpbnZvaWNlcy8ke2ludm9pY2VJZH1gKVxuICAgICAgICBpZiAocmVzcG9uc2Uub2theSkge1xuICAgICAgICAgICAgbGV0IHsgb3JkZXIsIGludm9pY2UgfSA9IHJlc3BvbnNlXG4gICAgICAgICAgICBkb2N1bWVudC50aXRsZSA9IGAke2ludm9pY2UuYWN0aXZlID8gJyAnIDogJ9m+24zYtCAnfdmB2Kfaqdiq2YjYsSDYtNmF2KfYsdmHICR7aW52b2ljZS5pZH1gXG4gICAgICAgICAgICBpbnZvaWNlLmNhbGN1bGF0ZV9vZmYgPSB0b3RhbCA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHtvZmZlcn0gPSBpbnZvaWNlXG4gICAgICAgICAgICAgICAgaWYgKG9mZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvZmZlci52YWx1ZV90eXBlID09PSAncGVyY2VudGFnZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAodG90YWwgLyAxMDApICogb2ZmZXIudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2ZmZXIudmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0b3RhbCA9IDBcbiAgICAgICAgICAgIG9yZGVyLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbS5hbW91bnQgPSBpdGVtLnRvdGFsIC0gaXRlbS5vZmZcbiAgICAgICAgICAgICAgICB0b3RhbCArPSBpdGVtLmFtb3VudFxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgbGV0IHRvdGFsX29mZiA9IGludm9pY2UubXVsdGlwYXkgPyAwIDogaW52b2ljZS5jYWxjdWxhdGVfb2ZmKHRvdGFsKSxcbiAgICAgICAgICAgICAgICBmaW5hbCA9IHRvdGFsIC0gdG90YWxfb2ZmXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBpbnZvaWNlIDoge1xuICAgICAgICAgICAgICAgICAgICAuLi5pbnZvaWNlLFxuICAgICAgICAgICAgICAgICAgICBjYWxjOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsX29mZixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxfdGF4OiAoZmluYWwgLyAxMDApICogOSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3JkZXI6IG9yZGVyLFxuICAgICAgICAgICAgICAgIGxvYWRpbmc6IGZhbHNlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuICAgIGFjdGl2YXRlSW52b2ljZSA9IG5ld0ludm9pY2UgPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHByZXYgPT4gKHtcbiAgICAgICAgICAgIGludm9pY2U6IHtcbiAgICAgICAgICAgICAgICAuLi5wcmV2Lmludm9pY2UsXG4gICAgICAgICAgICAgICAgLi4ubmV3SW52b2ljZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxvYWRpbmc6IGZhbHNlXG4gICAgICAgIH0pKVxuICAgIH1cbiAgICBzZXRNdWx0aVBheSA9IGJvb2xlYW4gPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHByZXYgPT4gKHtcbiAgICAgICAgICAgIGludm9pY2U6IHtcbiAgICAgICAgICAgICAgICAuLi5wcmV2Lmludm9pY2UsXG4gICAgICAgICAgICAgICAgbXVsdGlwYXk6IGJvb2xlYW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpXG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLmxvYWRJbnZvaWNlKClcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyB1c2VyLCBjb21wYW55IH0gPSB0aGlzLnByb3BzXG4gICAgICAgIGxldCB7IGludm9pY2UsIG9yZGVyLCBsb2FkaW5nIH0gPSB0aGlzLnN0YXRlXG4gICAgICAgIHJldHVybiBsb2FkaW5nID8gPExvYWRlckNvbXBvbmVudCAvPiA6IChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdmYWN0b3ItY29udGFpbmVyIHAtMyBwLW1kLTQgJz5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZhY3Rvci1maXJzdC1zZWN0aW9uXCI+XG4gICAgICAgICAgICAgICAgICAgIHsvKiA8c3BhbiBjbGFzc05hbWU9XCJmYWN0b3ItZGF0ZSBtYi0zXCI+OSDYotiw2LEgMTQwMDwvc3Bhbj4gKi99XG4gICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtpbnZvaWNlLmFjdGl2ZSA/ICcgJyA6J9m+24zYtCAnfSDZgdin2qnYqtmI2LEg2KjYsdin24wgOjwvc3Bhbj4g2KLZgtinIC8g2K7Yp9mG2YUge3VzZXIubGFzdG5hbWV9PC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y29tcGFueSAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+PHNwYW4+2YbYp9mFINi02LHaqdiqOjwvc3Bhbj4ge1tjb21wYW55LnRpdGxlLCBjb21wYW55LnRpdGxlX2VuXS5qb2luKCcgLSAnKX08L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPjxzcGFuPtii2K/YsdizINi02LHaqdiqOjwvc3Bhbj4g2K7bjNin2KjYp9mGINiz2KzYp9ivIC0g2LPYrNin2K8gMjEgLSDZvtmE2KfaqSAxMjQ8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9J2NvbnRhY3QtaW5mbyc+e3VzZXIuZW1haWx9PC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPSdjb250YWN0LWluZm8nPnt1c2VyLnBob25lX251bWJlcn08L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+PHNwYW4+2LTZhdin2LHZhyDZgdin2qnYqtmI2LE6PC9zcGFuPntpbnZvaWNlLmlkfTwvbGk+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPjxzcGFuPti02YXYp9ix2Ycg2LPZgdin2LHYtDo8L3NwYW4+e29yZGVyLmNvZGV9PC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+PHNwYW4+2KrYp9ix24zYriDZgdin2qnYqtmI2LE6PC9zcGFuPnt1c2VKYWxhbGlEYXRlKGludm9pY2UuY3JlYXRlZF9hdCkuZm9ybWF0KCdqWVlZWS9qTU0vakREJyl9PC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7LyogPGxpIGNsYXNzTmFtZT0nYWxlcnQgYWxlcnQtZGFuZ2VyJz7Zhdio2YTYuiDYs9ixINix2LPbjNivOiB7aW52b2ljZX0g2KrZiNmF2KfZhjwvbGk+ICovfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbG9hdC1sZWZ0IHctMTAwIHRhYmxlLXJlc3BvbnNpdmUgbXQtNFwiPlxuICAgICAgICAgICAgICAgICAgICA8aDMgY2xhc3NOYW1lPSdmYWN0b3Itc2VjdGlvbi10aXRsZSc+2KLbjNiq2YUg2YfYp9uMINiz2YHYp9ix2LQ8L2gzPlxuICAgICAgICAgICAgICAgICAgICA8dGFibGUgY2xhc3NOYW1lPVwidGFibGUgdGV4dC1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aGVhZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aD4jPC90aD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoPti52YbZiNin2YYg2LPZgdin2LHYtDwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aD7ZgtuM2YXYqjwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aD7Yqtiu2YHbjNmBPC90aD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoPtmF2KzZhdmI2Lkg2YbZh9in24zbjDwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge29yZGVyICYmIG9yZGVyLml0ZW1zLm1hcCgoaXRlbSwgaSkgPT4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHIga2V5PXtpdGVtLmlkfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aD57aSArIDF9PC90aD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aCBzY29wZT0ncm93Jz57aXRlbS50aXRsZX08L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPntudW1iZXJfZm9ybWF0KGl0ZW0udG90YWwsIHRydWUpfTwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+e251bWJlcl9mb3JtYXQoaXRlbS5vZmYsIHRydWUpfTwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+e251bWJlcl9mb3JtYXQoaXRlbS5hbW91bnQsIHRydWUpfTwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxuICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxvYXQtbGVmdCB3LTEwMCB0YWJsZS1yZXNwb25zaXZlIGZhY3Rvci1pbmZvIG10LTRcIj5cbiAgICAgICAgICAgICAgICAgICAgPGgzIGNsYXNzTmFtZT0nZmFjdG9yLXNlY3Rpb24tdGl0bGUnPtmH2LLbjNmG2Ycg2qnZhNuMPC9oMz5cbiAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzTmFtZT1cInRhYmxlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGggc2NvcGU9J3Jvdyc+2KzZhdi5INqp2YQ8L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+e251bWJlcl9mb3JtYXQoaW52b2ljZS5jYWxjLnRvdGFsLCB0cnVlKX08L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGggc2NvcGU9J3Jvdyc+2KrYrtmB24zZgSDZgdin2qnYqtmI2LE8L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aW52b2ljZS5tdWx0aXBheSA/IDxzcGFuIGNsYXNzTmFtZT0ndGV4dC1kYW5nZXInPtiv2LEg2LHZiNi0INm+2LHYr9in2K7YqiDYrNiy2KbbjCDYqtiu2YHbjNmBINqp2YTbjCDYp9i52YXYp9mEINmG2YXbjCDYtNmI2K8uPC9zcGFuPiA6IG51bWJlcl9mb3JtYXQoaW52b2ljZS5jYWxjLnRvdGFsX29mZiwgdHJ1ZSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aCBzY29wZT0ncm93Jz7YrNmF2Lkg2qnZhCDZvtizINin2LIg2qnYs9ixINiq2K7ZgduM2YE8L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+e251bWJlcl9mb3JtYXQoaW52b2ljZS5jYWxjLmZpbmFsLCB0cnVlKX08L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGggc2NvcGU9J3Jvdyc+OSUg2YXYp9mE24zYp9iqINin2LHYsti0INin2YHYstmI2K/ZhzwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD57bnVtYmVyX2Zvcm1hdChpbnZvaWNlLmNhbGMudG90YWxfdGF4LCB0cnVlKX08L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGggc2NvcGU9J3Jvdyc+2YLYp9io2YQg2b7Ysdiv2KfYrtiqPC90aD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPntudW1iZXJfZm9ybWF0KGludm9pY2UuY2FsYy5maW5hbCArIGludm9pY2UuY2FsYy50b3RhbF90YXgsIHRydWUpfTwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aCBzY29wZT0ncm93Jz7YsdmI2LQg2b7Ysdiv2KfYrtiq24w8L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+e2ludm9pY2UubXVsdGlwYXkgPyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ9is2LLYptuMJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICfaqdmE24wnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH08L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxuICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIHtpbnZvaWNlLmFjdGl2ZSAmJiBpbnZvaWNlLmJpbGxzIFxuICAgICAgICAgICAgICAgICAgICA/IDxCaWxscyBiaWxscz17aW52b2ljZS5iaWxsc30vPlxuICAgICAgICAgICAgICAgICAgICA6IDxQYXltZW50TWV0aG9kIGludm9pY2U9e2ludm9pY2V9IHNldE11bHRpUGF5PXt0aGlzLnNldE11bHRpUGF5fSBvbkFjdGl2ZT17dGhpcy5hY3RpdmF0ZUludm9pY2V9Lz5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgey8qIDxkaXYgY2xhc3NOYW1lPSdmbG9hdC1sZWZ0IGFsZXJ0IGFsZXJ0LWxpZ2h0IHRleHQtY2VudGVyIG10LTUgaG9yaXpvbnRhbC1jZW50ZXItbGVmdCc+2YXZh9mE2Kog2b7Ysdiv2KfYrtiqINiq2LPZiNuM2Ycg2YHYp9qp2KrZiNixINi02YXYpyDYqNmHINi02YXYp9ix2Ycge2ludm9pY2UuaWR92Iwg2KrYpyDYqtin2LHbjNiuIDE0MDAvMTIvMzQg2YXbjNio2KfYtNivLjwvZGl2PiAqL31cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cbn1cblxuY29uc3QgbWFwU3RhdGVUb1Byb3BzID0gc3RhdGUgPT4gKHtcbiAgICB1c2VyOiBzdGF0ZS5hdXRoLnVzZXIsXG4gICAgY29tcGFueTogc3RhdGUudXNlci5jb21wYW55XG59KVxuXG5leHBvcnQgZGVmYXVsdCBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcykoSW52b2ljZSk7Il0sIm5hbWVzIjpbIlJlYWN0IiwiQ29tcG9uZW50IiwiY29ubmVjdCIsIkxvYWRlckNvbXBvbmVudCIsInVzZUh0dHBTZXJ2aWNlIiwidXNlSmFsYWxpRGF0ZSIsIm51bWJlcl9mb3JtYXQiLCJCaWxscyIsIlBheW1lbnRNZXRob2QiLCJJbnZvaWNlIiwicHJvcHMiLCJpbnZvaWNlSWQiLCJwYXJhbXMiLCJodHRwIiwiZ2V0IiwicmVzcG9uc2UiLCJva2F5Iiwib3JkZXIiLCJpbnZvaWNlIiwiZG9jdW1lbnQiLCJ0aXRsZSIsImFjdGl2ZSIsImlkIiwiY2FsY3VsYXRlX29mZiIsInRvdGFsIiwib2ZmZXIiLCJ2YWx1ZV90eXBlIiwidmFsdWUiLCJpdGVtcyIsImZvckVhY2giLCJpdGVtIiwiYW1vdW50Iiwib2ZmIiwidG90YWxfb2ZmIiwibXVsdGlwYXkiLCJmaW5hbCIsInNldFN0YXRlIiwiY2FsYyIsInRvdGFsX3RheCIsImxvYWRpbmciLCJuZXdJbnZvaWNlIiwicHJldiIsImJvb2xlYW4iLCJzdGF0ZSIsImxvYWRJbnZvaWNlIiwidXNlciIsImNvbXBhbnkiLCJsYXN0bmFtZSIsInRpdGxlX2VuIiwiam9pbiIsImVtYWlsIiwicGhvbmVfbnVtYmVyIiwiY29kZSIsImNyZWF0ZWRfYXQiLCJmb3JtYXQiLCJtYXAiLCJpIiwiYmlsbHMiLCJzZXRNdWx0aVBheSIsImFjdGl2YXRlSW52b2ljZSIsIm1hcFN0YXRlVG9Qcm9wcyIsImF1dGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/userarea/Pages/Private/Finance/Invoices/Invoice.jsx\n");

/***/ }),

/***/ "./resources/js/userarea/Pages/Private/Finance/Invoices/components/Bills.jsx":
/*!***********************************************************************************!*\
  !*** ./resources/js/userarea/Pages/Private/Finance/Invoices/components/Bills.jsx ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Bills)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var _PaymentPopup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PaymentPopup */ \"./resources/js/userarea/Pages/Private/Finance/Invoices/components/PaymentPopup.jsx\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../../../helpers */ \"./resources/js/helpers/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\nfunction Bills(_ref) {\n  var bills = _ref.bills;\n\n  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      showPopup = _useState2[0],\n      setShowPopup = _useState2[1];\n\n  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null),\n      _useState4 = _slicedToArray(_useState3, 2),\n      payable = _useState4[0],\n      setPayable = _useState4[1];\n\n  function select(bill) {\n    setPayable(bill);\n    setShowPopup(true);\n  }\n\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(\"div\", {\n    className: \"float-left w-100 table-responsive mt-5\",\n    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"h3\", {\n      className: \"factor-section-title\",\n      children: \"\\u0648\\u0636\\u0639\\u06CC\\u062A \\u067E\\u0631\\u062F\\u0627\\u062E\\u062A\\u06CC\"\n    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(\"table\", {\n      className: \"table table-hover\",\n      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"thead\", {\n        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(\"tr\", {\n          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"th\", {\n            children: \"#\"\n          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"th\", {\n            children: \"\\u0634\\u0645\\u0627\\u0631\\u0647 \\u0642\\u0628\\u0636\"\n          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"th\", {\n            children: \"\\u0639\\u0646\\u0648\\u0627\\u0646\"\n          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"th\", {\n            children: \"\\u0645\\u0642\\u062F\\u0627\\u0631\"\n          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"th\", {\n            children: \"\\u0648\\u0636\\u0639\\u06CC\\u062A \\u067E\\u0631\\u062F\\u0627\\u062E\\u062A\"\n          })]\n        })\n      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"tbody\", {\n        children: bills.length > 0 && bills.filter(function (x) {\n          return x.active;\n        }).map(function (bill, i) {\n          var id = bill.id,\n              code = bill.code,\n              title = bill.title,\n              amount = bill.amount,\n              paid_at = bill.paid_at;\n          return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(\"tr\", {\n            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"th\", {\n              children: i + 1\n            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"td\", {\n              children: code\n            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"td\", {\n              children: title\n            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"td\", {\n              children: (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.number_format)(amount, true)\n            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"td\", {\n              children: paid_at === null ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"button\", {\n                className: \"btn btn-sm btn-primary\",\n                onClick: function onClick() {\n                  return select(bill);\n                },\n                children: \"\\u067E\\u0631\\u062F\\u0627\\u062E\\u062A\"\n              }) : /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(\"span\", {\n                children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"i\", {\n                  className: \"far fa-check text-success\"\n                }), \" \\u067E\\u0631\\u062F\\u0627\\u062E\\u062A \\u0634\\u062F\\u0647\"]\n              })\n            })]\n          }, id);\n        })\n      })]\n    }), showPopup && payable && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_PaymentPopup__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n      id: payable.id,\n      amount: payable.amount,\n      close: function close() {\n        return setShowPopup(false);\n      }\n    })]\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvdXNlcmFyZWEvUGFnZXMvUHJpdmF0ZS9GaW5hbmNlL0ludm9pY2VzL2NvbXBvbmVudHMvQmlsbHMuanN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOzs7QUFFZSxTQUFTSyxLQUFULE9BQXdCO0VBQUEsSUFBUkMsS0FBUSxRQUFSQSxLQUFROztFQUNuQyxnQkFBa0NMLCtDQUFRLENBQUMsS0FBRCxDQUExQztFQUFBO0VBQUEsSUFBT00sU0FBUDtFQUFBLElBQWtCQyxZQUFsQjs7RUFDQSxpQkFBOEJQLCtDQUFRLENBQUMsSUFBRCxDQUF0QztFQUFBO0VBQUEsSUFBT1EsT0FBUDtFQUFBLElBQWdCQyxVQUFoQjs7RUFDQSxTQUFTQyxNQUFULENBQWdCQyxJQUFoQixFQUFzQjtJQUNsQkYsVUFBVSxDQUFDRSxJQUFELENBQVY7SUFDQUosWUFBWSxDQUFDLElBQUQsQ0FBWjtFQUNIOztFQUNELG9CQUNJO0lBQUssU0FBUyxFQUFDLHdDQUFmO0lBQUEsd0JBQ0k7TUFBSSxTQUFTLEVBQUMsc0JBQWQ7TUFBQTtJQUFBLEVBREosZUFFSTtNQUFPLFNBQVMsRUFBQyxtQkFBakI7TUFBQSx3QkFDSTtRQUFBLHVCQUNJO1VBQUEsd0JBQ0k7WUFBQTtVQUFBLEVBREosZUFFSTtZQUFBO1VBQUEsRUFGSixlQUdJO1lBQUE7VUFBQSxFQUhKLGVBSUk7WUFBQTtVQUFBLEVBSkosZUFLSTtZQUFBO1VBQUEsRUFMSjtRQUFBO01BREosRUFESixlQVVJO1FBQUEsVUFDQ0YsS0FBSyxDQUFDTyxNQUFOLEdBQWUsQ0FBZixJQUFvQlAsS0FBSyxDQUFDUSxNQUFOLENBQWEsVUFBQUMsQ0FBQztVQUFBLE9BQUlBLENBQUMsQ0FBQ0MsTUFBTjtRQUFBLENBQWQsRUFBNEJDLEdBQTVCLENBQWdDLFVBQUNMLElBQUQsRUFBT00sQ0FBUCxFQUFhO1VBQzlELElBQUtDLEVBQUwsR0FBeUNQLElBQXpDLENBQUtPLEVBQUw7VUFBQSxJQUFTQyxJQUFULEdBQXlDUixJQUF6QyxDQUFTUSxJQUFUO1VBQUEsSUFBZUMsS0FBZixHQUF5Q1QsSUFBekMsQ0FBZVMsS0FBZjtVQUFBLElBQXNCQyxNQUF0QixHQUF5Q1YsSUFBekMsQ0FBc0JVLE1BQXRCO1VBQUEsSUFBOEJDLE9BQTlCLEdBQXlDWCxJQUF6QyxDQUE4QlcsT0FBOUI7VUFDQSxvQkFDSTtZQUFBLHdCQUNJO2NBQUEsVUFBS0wsQ0FBQyxHQUFHO1lBQVQsRUFESixlQUVJO2NBQUEsVUFBS0U7WUFBTCxFQUZKLGVBR0k7Y0FBQSxVQUFLQztZQUFMLEVBSEosZUFJSTtjQUFBLFVBQUtqQix1REFBYSxDQUFDa0IsTUFBRCxFQUFTLElBQVQ7WUFBbEIsRUFKSixlQUtJO2NBQUEsVUFDSUMsT0FBTyxLQUFLLElBQVosZ0JBQ0U7Z0JBQVEsU0FBUyxFQUFDLHdCQUFsQjtnQkFBMkMsT0FBTyxFQUFFO2tCQUFBLE9BQU1aLE1BQU0sQ0FBQ0MsSUFBRCxDQUFaO2dCQUFBLENBQXBEO2dCQUFBO2NBQUEsRUFERixnQkFFRTtnQkFBQSx3QkFBTTtrQkFBRyxTQUFTLEVBQUM7Z0JBQWIsRUFBTjtjQUFBO1lBSE4sRUFMSjtVQUFBLEdBQVNPLEVBQVQsQ0FESjtRQWFILENBZm9CO01BRHJCLEVBVko7SUFBQSxFQUZKLEVBK0JLWixTQUFTLElBQUlFLE9BQWIsaUJBQXlCLHVEQUFDLHFEQUFEO01BQWMsRUFBRSxFQUFFQSxPQUFPLENBQUNVLEVBQTFCO01BQThCLE1BQU0sRUFBRVYsT0FBTyxDQUFDYSxNQUE5QztNQUFzRCxLQUFLLEVBQUU7UUFBQSxPQUFNZCxZQUFZLENBQUMsS0FBRCxDQUFsQjtNQUFBO0lBQTdELEVBL0I5QjtFQUFBLEVBREo7QUFtQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvdXNlcmFyZWEvUGFnZXMvUHJpdmF0ZS9GaW5hbmNlL0ludm9pY2VzL2NvbXBvbmVudHMvQmlsbHMuanN4Pzk0ZWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCBsYXp5IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUGF5bWVudFBvcHVwIGZyb20gJy4vUGF5bWVudFBvcHVwJ1xuaW1wb3J0IHsgbnVtYmVyX2Zvcm1hdCB9IGZyb20gXCIuLi8uLi8uLi8uLi8uLi8uLi9oZWxwZXJzXCJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQmlsbHMoe2JpbGxzfSkge1xuICAgIGNvbnN0IFtzaG93UG9wdXAsIHNldFNob3dQb3B1cF0gPSB1c2VTdGF0ZShmYWxzZSlcbiAgICBjb25zdCBbcGF5YWJsZSwgc2V0UGF5YWJsZV0gPSB1c2VTdGF0ZShudWxsKVxuICAgIGZ1bmN0aW9uIHNlbGVjdChiaWxsKSB7XG4gICAgICAgIHNldFBheWFibGUoYmlsbClcbiAgICAgICAgc2V0U2hvd1BvcHVwKHRydWUpXG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxvYXQtbGVmdCB3LTEwMCB0YWJsZS1yZXNwb25zaXZlIG10LTVcIj5cbiAgICAgICAgICAgIDxoMyBjbGFzc05hbWU9XCJmYWN0b3Itc2VjdGlvbi10aXRsZVwiPtmI2LbYuduM2Kog2b7Ysdiv2KfYrtiq24w8L2gzPlxuICAgICAgICAgICAgPHRhYmxlIGNsYXNzTmFtZT1cInRhYmxlIHRhYmxlLWhvdmVyXCI+XG4gICAgICAgICAgICAgICAgPHRoZWFkPlxuICAgICAgICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGg+IzwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGg+2LTZhdin2LHZhyDZgtio2LY8L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoPti52YbZiNin2YY8L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoPtmF2YLYr9in2LE8L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoPtmI2LbYuduM2Kog2b7Ysdiv2KfYrtiqPC90aD5cbiAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICA8L3RoZWFkPlxuICAgICAgICAgICAgICAgIDx0Ym9keT5cbiAgICAgICAgICAgICAgICB7YmlsbHMubGVuZ3RoID4gMCAmJiBiaWxscy5maWx0ZXIoeCA9PiB4LmFjdGl2ZSkubWFwKChiaWxsLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7aWQsIGNvZGUsIHRpdGxlLCBhbW91bnQsIHBhaWRfYXR9ID0gYmlsbFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgPHRyIGtleT17aWR9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aD57aSArIDF9PC90aD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+e2NvZGV9PC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+e3RpdGxlfTwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPntudW1iZXJfZm9ybWF0KGFtb3VudCwgdHJ1ZSl9PC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWlkX2F0ID09PSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gPGJ1dHRvbiBjbGFzc05hbWU9J2J0biBidG4tc20gYnRuLXByaW1hcnknIG9uQ2xpY2s9eygpID0+IHNlbGVjdChiaWxsKX0+2b7Ysdiv2KfYrtiqPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogPHNwYW4+PGkgY2xhc3NOYW1lPSdmYXIgZmEtY2hlY2sgdGV4dC1zdWNjZXNzJz48L2k+INm+2LHYr9in2K7YqiDYtNiv2Yc8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgICAgPC90Ym9keT5cbiAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgICAgICB7c2hvd1BvcHVwICYmIHBheWFibGUgJiYgKDxQYXltZW50UG9wdXAgaWQ9e3BheWFibGUuaWR9IGFtb3VudD17cGF5YWJsZS5hbW91bnR9IGNsb3NlPXsoKSA9PiBzZXRTaG93UG9wdXAoZmFsc2UpfSAvPil9XG4gICAgICAgIDwvZGl2PlxuICAgIClcbn0iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsImxhenkiLCJQYXltZW50UG9wdXAiLCJudW1iZXJfZm9ybWF0IiwiQmlsbHMiLCJiaWxscyIsInNob3dQb3B1cCIsInNldFNob3dQb3B1cCIsInBheWFibGUiLCJzZXRQYXlhYmxlIiwic2VsZWN0IiwiYmlsbCIsImxlbmd0aCIsImZpbHRlciIsIngiLCJhY3RpdmUiLCJtYXAiLCJpIiwiaWQiLCJjb2RlIiwidGl0bGUiLCJhbW91bnQiLCJwYWlkX2F0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/userarea/Pages/Private/Finance/Invoices/components/Bills.jsx\n");

/***/ }),

/***/ "./resources/js/userarea/Pages/Private/Finance/Invoices/components/DirectPayment.jsx":
/*!*******************************************************************************************!*\
  !*** ./resources/js/userarea/Pages/Private/Finance/Invoices/components/DirectPayment.jsx ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DirectPayment)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var _components_copy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../../components/copy */ \"./resources/js/components/copy.js\");\n/* harmony import */ var validator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! validator */ \"./node_modules/validator/index.js\");\n/* harmony import */ var validator__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(validator__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _services_AlertService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../../../services/AlertService */ \"./resources/js/services/AlertService.js\");\n/* harmony import */ var _components_datepicker__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../../../components/datepicker */ \"./resources/js/components/datepicker.js\");\n/* harmony import */ var _components_datepicker__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_components_datepicker__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../../../helpers */ \"./resources/js/helpers/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\n\nfunction DirectPayment(_ref) {\n  var amount = _ref.amount,\n      pay = _ref.pay;\n\n  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\"),\n      _useState2 = _slicedToArray(_useState, 2),\n      transactionDate = _useState2[0],\n      setTransactionDate = _useState2[1],\n      _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\"),\n      _useState4 = _slicedToArray(_useState3, 2),\n      enDate = _useState4[0],\n      setEnDate = _useState4[1],\n      _useState5 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\"),\n      _useState6 = _slicedToArray(_useState5, 2),\n      transactionCode = _useState6[0],\n      setTransactionCode = _useState6[1],\n      _useState7 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\"),\n      _useState8 = _slicedToArray(_useState7, 2),\n      fourDigits = _useState8[0],\n      setForDigits = _useState8[1],\n      _useState9 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),\n      _useState10 = _slicedToArray(_useState9, 2),\n      disabled = _useState10[0],\n      disable = _useState10[1],\n      ba_card = '6104 - 3388 - 0004 - 6282',\n      ba_shaba = 'IR-17 0120 0000 0000 9546 6188 31',\n      ba_hesab = \"9546618831\",\n      errs = [],\n      sendForm = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var okay;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              validator__WEBPACK_IMPORTED_MODULE_6___default().isNumeric(transactionCode) && validator__WEBPACK_IMPORTED_MODULE_6___default().isLength(transactionCode, {\n                min: 5,\n                max: 20\n              }) ? null : errs.push(\"شماره پیگیری تراکنش نامعتبر است\");\n              validator__WEBPACK_IMPORTED_MODULE_6___default().isNumeric(fourDigits) && fourDigits.length === 4 || fourDigits.length === 0 ? null : errs.push(\"لطفا 4 رقم آخر کارت خود را به درستی وارد کنید\");\n              validator__WEBPACK_IMPORTED_MODULE_6___default().isDate(enDate) ? null : errs.push(\"تاریخ انجام تراکنش نا معتبر است\");\n\n              if (!errs.length) {\n                _context.next = 7;\n                break;\n              }\n\n              new _services_AlertService__WEBPACK_IMPORTED_MODULE_2__[\"default\"]().error({\n                title: \"ورودی نادرست\",\n                html: \"\".concat(errs.map(function (err) {\n                  return \"<br/>\" + err;\n                })),\n                confirmButtonText: \"بستن\"\n              });\n              _context.next = 11;\n              break;\n\n            case 7:\n              _context.next = 9;\n              return pay({\n                transaction_code: transactionCode,\n                transaction_date: transactionDate,\n                four_digits: fourDigits\n              });\n\n            case 9:\n              okay = _context.sent;\n\n              if (okay) {\n                [setTransactionDate, setTransactionCode, setForDigits].map(function (method) {\n                  method(\"\");\n                });\n                disable(true);\n              }\n\n            case 11:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function sendForm() {\n      return _ref2.apply(this, arguments);\n    };\n  }(),\n      handleValidate = {\n    trCode: function trCode(e, clb) {\n      validator__WEBPACK_IMPORTED_MODULE_6___default().isNumeric(e.target.value.trim()) && validator__WEBPACK_IMPORTED_MODULE_6___default().isLength(e.target.value, {\n        min: 0,\n        max: 20\n      }) || e.target.value.trim().length === 0 ? clb() : e.preventDefault();\n    },\n    trFour: function trFour(e, clb) {\n      validator__WEBPACK_IMPORTED_MODULE_6___default().isNumeric(e.target.value.trim()) && e.target.value.trim().length <= 4 || e.target.value.trim().length === 0 ? clb() : e.preventDefault();\n    },\n    trDate: function trDate(value, clb) {\n      validator__WEBPACK_IMPORTED_MODULE_6___default().isDate(value) ? clb() : null;\n    }\n  };\n\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    $(\"#trDate\").persianDatepicker({\n      onSelect: function onSelect(unix) {\n        handleValidate.trDate(new Date(unix), function () {\n          setTransactionDate(new persianDate(unix).format('YYYY/MM/DD HH:mm:ss'));\n          setEnDate(new Date(unix));\n        });\n      },\n      initialValue: false,\n      observer: true,\n      format: 'YYYY/MM/DD HH:mm:ss',\n      altFormat: 'YYYY/MM/DD HH:mm:ss',\n      calendar: {\n        persian: {\n          leapYearMode: 'astronomical'\n        }\n      },\n      timePicker: {\n        enabled: true\n      }\n    });\n  }, []);\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {\n    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"p\", {\n      children: \"\\u0628\\u0647 \\u0645\\u0646\\u0638\\u0648\\u0631 \\u067E\\u0631\\u062F\\u0627\\u062E\\u062A \\u0647\\u0632\\u06CC\\u0646\\u0647 \\u0627\\u0632 \\u0637\\u0631\\u06CC\\u0642 \\u0648\\u0627\\u0631\\u06CC\\u0632 \\u0648\\u062C\\u0647 \\u0628\\u0647 \\u062D\\u0633\\u0627\\u0628\\u060C \\u0645\\u06CC \\u062A\\u0648\\u0627\\u0646\\u06CC\\u062F \\u0627\\u0632 \\u0634\\u0645\\u0627\\u0631\\u0647 \\u062D\\u0633\\u0627\\u0628 \\u0632\\u06CC\\u0631 \\u0627\\u0633\\u062A\\u0641\\u0627\\u0647 \\u06A9\\u0631\\u062F\\u0647 \\u0648 \\u067E\\u0633 \\u0627\\u0632 \\u0627\\u062A\\u0645\\u0627\\u0645 \\u0639\\u0645\\u0644\\u06CC\\u0627\\u062A \\u067E\\u0631\\u062F\\u0627\\u062E\\u062A \\u0627\\u0637\\u0644\\u0627\\u0639\\u0627\\u062A \\u0641\\u06CC\\u0634 \\u0648\\u0627\\u0631\\u06CC\\u0632\\u06CC \\u0631\\u0627 \\u062F\\u0631 \\u06A9\\u0627\\u062F\\u0631 \\u0632\\u06CC\\u0631 \\u0648\\u0627\\u0631\\u062F \\u0646\\u0645\\u0627\\u06CC\\u06CC\\u062F \\u0648 \\u0628\\u0631 \\u0628\\u0631\\u0648\\u06CC \\u062F\\u06A9\\u0645\\u0647 \\u062B\\u0628\\u062A \\u0648\\u0627\\u0631\\u06CC\\u0632 \\u06A9\\u0644\\u06CC\\u06A9 \\u0646\\u0645\\u0627\\u06CC\\u06CC\\u062F.\"\n    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(\"ul\", {\n      className: \"popup-list\",\n      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(\"li\", {\n        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"i\", {\n          className: \"fad fa-coins\"\n        }), \"\\u0645\\u0628\\u0644\\u063A: \", /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"span\", {\n          children: (0,_helpers__WEBPACK_IMPORTED_MODULE_4__.number_format)(amount, true)\n        })]\n      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(\"li\", {\n        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"i\", {\n          className: \"far fa-university\"\n        }), \"\\u0646\\u0632\\u062F : \", /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"span\", {\n          children: \"\\u0628\\u0627\\u0646\\u06A9 \\u0645\\u0644\\u062A\"\n        })]\n      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(\"li\", {\n        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"i\", {\n          className: \"far fa-building\"\n        }), \"\\u0628\\u0647 \\u0646\\u0627\\u0645: \", /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"span\", {\n          children: \"\\u0627\\u0631\\u0645\\u063A\\u0627\\u0646 \\u06A9\\u0647\\u06A9\\u0634\\u0627\\u0646 \\u067E\\u0627\\u0631\\u0633\"\n        })]\n      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(\"li\", {\n        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"i\", {\n          className: \"fad fa-credit-card-front\"\n        }), \"\\u0634\\u0645\\u0627\\u0631\\u0647 \\u06A9\\u0627\\u0631\\u062A: \", /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"span\", {\n          children: ba_card\n        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"a\", {\n          href: \"#\",\n          className: \"vertical-middle badge badge-pill badge-light mr-1\",\n          onClick: function onClick() {\n            return (0,_components_copy__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"6104338800046282\", \"شماره حساب\");\n          },\n          children: \"\\u06A9\\u067E\\u06CC\"\n        })]\n      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(\"li\", {\n        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"i\", {\n          className: \"far fa-money-check-edit-alt\"\n        }), \"\\u0634\\u0645\\u0627\\u0631\\u0647 \\u0634\\u0628\\u0627: \", /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"span\", {\n          children: ba_shaba\n        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"a\", {\n          href: \"#\",\n          className: \"vertical-middle badge badge-pill badge-light mr-1\",\n          onClick: function onClick() {\n            return (0,_components_copy__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"170120000000009546618831\", \"شماره شبا\");\n          },\n          children: \"\\u06A9\\u067E\\u06CC\"\n        })]\n      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(\"li\", {\n        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"i\", {\n          className: \"far fa-money-check-alt\"\n        }), \"\\u0634\\u0645\\u0627\\u0631\\u0647 \\u062D\\u0633\\u0627\\u0628: \", /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"span\", {\n          className: \"inline-block ltr\",\n          children: ba_hesab\n        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"a\", {\n          href: \"#\",\n          className: \"vertical-middle badge badge-pill badge-light mr-1\",\n          onClick: function onClick() {\n            return (0,_components_copy__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(ba_hesab, \"شماره حساب\");\n          },\n          children: \"\\u06A9\\u067E\\u06CC\"\n        })]\n      })]\n    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(\"div\", {\n      className: \"input-group mt-4\",\n      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"div\", {\n        className: \"input-group-append\",\n        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(\"span\", {\n          className: \"input-group-text\",\n          children: [\"\\u062A\\u0627\\u0631\\u06CC\\u062E \\u067E\\u0631\\u062F\\u0627\\u062E\\u062A \", /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"i\", {\n            className: \"text-danger fas fa-star-of-life mr-1 mb-2 font-10\"\n          })]\n        })\n      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"input\", {\n        type: \"text\",\n        disabled: disabled,\n        id: \"trDate\",\n        className: \"form-control\",\n        placeholder: \"\\u062A\\u0627\\u0631\\u06CC\\u062E \\u0648 \\u0633\\u0627\\u0639\\u062A \\u062F\\u0642\\u06CC\\u0642 \\u062A\\u0631\\u0627\\u06A9\\u0646\\u0634 \\u0631\\u0627 \\u0627\\u0646\\u062A\\u062E\\u0627\\u0628 \\u06A9\\u0646\\u06CC\\u062F\",\n        value: transactionDate,\n        onChange: function onChange() {}\n      })]\n    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(\"div\", {\n      className: \"input-group mt-4\",\n      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"div\", {\n        className: \"input-group-append\",\n        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(\"span\", {\n          className: \"input-group-text\",\n          children: [\"\\u0634\\u0645\\u0627\\u0631\\u0647 \\u067E\\u06CC\\u06AF\\u06CC\\u0631\\u06CC \", /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"i\", {\n            className: \"text-danger fas fa-star-of-life mr-1 mb-2 font-10\"\n          })]\n        })\n      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"input\", {\n        type: \"text\",\n        disabled: disabled,\n        className: \"form-control\",\n        placeholder: \"\\u0634\\u0645\\u0627\\u0631\\u0647 \\u067E\\u06CC\\u06AF\\u06CC\\u0631\\u06CC \\u0631\\u0627 \\u0648\\u0627\\u0631\\u062F \\u06A9\\u0646\\u06CC\\u062F (\\u0627\\u062C\\u0628\\u0627\\u0631\\u06CC)\",\n        value: transactionCode,\n        onChange: function onChange(e) {\n          return handleValidate.trCode(e, function () {\n            return setTransactionCode(e.target.value.trim());\n          });\n        }\n      })]\n    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(\"div\", {\n      className: \"input-group mt-4\",\n      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"div\", {\n        className: \"input-group-append\",\n        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"span\", {\n          className: \"input-group-text\",\n          children: \"4 \\u0631\\u0642\\u0645 \\u0622\\u062E\\u0631 \\u06A9\\u0627\\u0631\\u062A\"\n        })\n      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"input\", {\n        type: \"text\",\n        disabled: disabled,\n        className: \"form-control\",\n        placeholder: \"\\u062F\\u0631 \\u0635\\u0648\\u0631\\u062A \\u06A9\\u0627\\u0631\\u062A \\u0628\\u0647 \\u06A9\\u0627\\u0631\\u062A 4 \\u0631\\u0642\\u0645 \\u0622\\u062E\\u0631 \\u0631\\u0627 \\u0648\\u0627\\u0631\\u062F \\u0646\\u0645\\u0627\\u06CC\\u06CC\\u062F\",\n        value: fourDigits,\n        onChange: function onChange(e) {\n          return handleValidate.trFour(e, function () {\n            return setForDigits(e.target.value.trim());\n          });\n        }\n      })]\n    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"div\", {\n      className: \"w-100 text-center mt-4\",\n      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"a\", {\n        href: \"#check_transaction\",\n        className: \"btn btn-lg btn-light\",\n        onClick: sendForm,\n        children: \"\\u062B\\u0628\\u062A \\u0648\\u0627\\u0631\\u06CC\\u0632\"\n      })\n    })]\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvdXNlcmFyZWEvUGFnZXMvUHJpdmF0ZS9GaW5hbmNlL0ludm9pY2VzL2NvbXBvbmVudHMvRGlyZWN0UGF5bWVudC5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OytDQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFFZSxTQUFTTyxhQUFULE9BQXNDO0VBQUEsSUFBZEMsTUFBYyxRQUFkQSxNQUFjO0VBQUEsSUFBTkMsR0FBTSxRQUFOQSxHQUFNOztFQUNqRCxnQkFBOENQLCtDQUFRLENBQUMsRUFBRCxDQUF0RDtFQUFBO0VBQUEsSUFBT1EsZUFBUDtFQUFBLElBQXdCQyxrQkFBeEI7RUFBQSxpQkFDc0JULCtDQUFRLENBQUMsRUFBRCxDQUQ5QjtFQUFBO0VBQUEsSUFDQ1UsTUFERDtFQUFBLElBQ1NDLFNBRFQ7RUFBQSxpQkFFd0NYLCtDQUFRLENBQUMsRUFBRCxDQUZoRDtFQUFBO0VBQUEsSUFFQ1ksZUFGRDtFQUFBLElBRWtCQyxrQkFGbEI7RUFBQSxpQkFHNkJiLCtDQUFRLENBQUMsRUFBRCxDQUhyQztFQUFBO0VBQUEsSUFHQ2MsVUFIRDtFQUFBLElBR2FDLFlBSGI7RUFBQSxpQkFJc0JmLCtDQUFRLENBQUMsS0FBRCxDQUo5QjtFQUFBO0VBQUEsSUFJQ2dCLFFBSkQ7RUFBQSxJQUlXQyxPQUpYO0VBQUEsSUFLQUMsT0FMQSxHQUtVLDJCQUxWO0VBQUEsSUFNQUMsUUFOQSxHQU1XLG1DQU5YO0VBQUEsSUFPQUMsUUFQQSxHQU9XLFlBUFg7RUFBQSxJQVFBQyxJQVJBLEdBUU8sRUFSUDtFQUFBLElBU0FDLFFBVEE7SUFBQSx1RUFTVztNQUFBO01BQUE7UUFBQTtVQUFBO1lBQUE7Y0FDUHBCLDBEQUFBLENBQW9CVSxlQUFwQixLQUF3Q1YseURBQUEsQ0FBbUJVLGVBQW5CLEVBQW9DO2dCQUFDYSxHQUFHLEVBQUUsQ0FBTjtnQkFBU0MsR0FBRyxFQUFFO2NBQWQsQ0FBcEMs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SixFQUZKO0lBQUEsRUFsQkosZUFzQkk7TUFBSyxTQUFTLEVBQUMsd0JBQWY7TUFBQSx1QkFDSTtRQUFHLElBQUksRUFBQyxvQkFBUjtRQUE2QixTQUFTLEVBQUMsc0JBQXZDO1FBQThELE9BQU8sRUFBRXpCLFFBQXZFO1FBQUE7TUFBQTtJQURKLEVBdEJKO0VBQUEsRUFESjtBQTRCSCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy91c2VyYXJlYS9QYWdlcy9Qcml2YXRlL0ZpbmFuY2UvSW52b2ljZXMvY29tcG9uZW50cy9EaXJlY3RQYXltZW50LmpzeD83OGYyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiXG5pbXBvcnQgY29weVRvQ2xpcGJvYXJkIGZyb20gJy4uLy4uLy4uLy4uLy4uLy4uL2NvbXBvbmVudHMvY29weSdcbmltcG9ydCB2YWxpZGF0b3IgZnJvbSBcInZhbGlkYXRvclwiO1xuaW1wb3J0IEFsZXJ0U2VydmljZSBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vLi4vc2VydmljZXMvQWxlcnRTZXJ2aWNlXCI7XG5pbXBvcnQgJy4uLy4uLy4uLy4uLy4uLy4uL2NvbXBvbmVudHMvZGF0ZXBpY2tlcidcbmltcG9ydCB7IG51bWJlcl9mb3JtYXQgfSBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vLi4vaGVscGVyc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEaXJlY3RQYXltZW50KHthbW91bnQsIHBheX0pIHtcbiAgICBjb25zdCBbdHJhbnNhY3Rpb25EYXRlLCBzZXRUcmFuc2FjdGlvbkRhdGVdID0gdXNlU3RhdGUoXCJcIiksXG4gICAgW2VuRGF0ZSwgc2V0RW5EYXRlXSA9IHVzZVN0YXRlKFwiXCIpLFxuICAgIFt0cmFuc2FjdGlvbkNvZGUsIHNldFRyYW5zYWN0aW9uQ29kZV0gPSB1c2VTdGF0ZShcIlwiKSxcbiAgICBbZm91ckRpZ2l0cywgc2V0Rm9yRGlnaXRzXSA9IHVzZVN0YXRlKFwiXCIpLFxuICAgIFtkaXNhYmxlZCwgZGlzYWJsZV0gPSB1c2VTdGF0ZShmYWxzZSksXG4gICAgYmFfY2FyZCA9ICc2MTA0IC0gMzM4OCAtIDAwMDQgLSA2MjgyJyxcbiAgICBiYV9zaGFiYSA9ICdJUi0xNyAwMTIwIDAwMDAgMDAwMCA5NTQ2IDYxODggMzEnLFxuICAgIGJhX2hlc2FiID0gXCI5NTQ2NjE4ODMxXCIsXG4gICAgZXJycyA9IFtdLFxuICAgIHNlbmRGb3JtID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICB2YWxpZGF0b3IuaXNOdW1lcmljKHRyYW5zYWN0aW9uQ29kZSkgJiYgdmFsaWRhdG9yLmlzTGVuZ3RoKHRyYW5zYWN0aW9uQ29kZSwge21pbjogNSwgbWF4OiAyMH0pID8gbnVsbCA6IGVycnMucHVzaChcIti02YXYp9ix2Ycg2b7bjNqv24zYsduMINiq2LHYp9qp2YbYtCDZhtin2YXYudiq2KjYsSDYp9iz2KpcIilcbiAgICAgICAgdmFsaWRhdG9yLmlzTnVtZXJpYyhmb3VyRGlnaXRzKSAmJiBmb3VyRGlnaXRzLmxlbmd0aCA9PT0gNCB8fCBmb3VyRGlnaXRzLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBlcnJzLnB1c2goXCLZhNi32YHYpyA0INix2YLZhSDYotiu2LEg2qnYp9ix2Kog2K7ZiNivINix2Kcg2KjZhyDYr9ix2LPYqtuMINmI2KfYsdivINqp2YbbjNivXCIpXG4gICAgICAgIHZhbGlkYXRvci5pc0RhdGUoZW5EYXRlKSA/IG51bGwgOiBlcnJzLnB1c2goXCLYqtin2LHbjNiuINin2YbYrNin2YUg2KrYsdin2qnZhti0INmG2Kcg2YXYudiq2KjYsSDYp9iz2KpcIilcbiAgICAgICAgaWYgKGVycnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAobmV3IEFsZXJ0U2VydmljZSkuZXJyb3Ioe3RpdGxlOiBcItmI2LHZiNiv24wg2YbYp9iv2LHYs9iqXCIsIGh0bWw6IGAke2VycnMubWFwKGVyciA9PiAoXCI8YnIvPlwiICsgZXJyKSl9YCwgY29uZmlybUJ1dHRvblRleHQ6IFwi2KjYs9iq2YZcIn0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgb2theSA9IGF3YWl0IHBheSh7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25fY29kZTogdHJhbnNhY3Rpb25Db2RlLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uX2RhdGU6IHRyYW5zYWN0aW9uRGF0ZSxcbiAgICAgICAgICAgICAgICBmb3VyX2RpZ2l0czogZm91ckRpZ2l0c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAob2theSkge1xuICAgICAgICAgICAgICAgIFtzZXRUcmFuc2FjdGlvbkRhdGUsIHNldFRyYW5zYWN0aW9uQ29kZSwgc2V0Rm9yRGlnaXRzXS5tYXAobWV0aG9kID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kKFwiXCIpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBkaXNhYmxlKHRydWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGhhbmRsZVZhbGlkYXRlID0ge1xuICAgICAgICB0ckNvZGU6IChlLCBjbGIpID0+IHtcbiAgICAgICAgICAgICh2YWxpZGF0b3IuaXNOdW1lcmljKGUudGFyZ2V0LnZhbHVlLnRyaW0oKSkgJiYgdmFsaWRhdG9yLmlzTGVuZ3RoKGUudGFyZ2V0LnZhbHVlLCB7bWluOiAwLCBtYXg6IDIwfSkpIHx8IGUudGFyZ2V0LnZhbHVlLnRyaW0oKS5sZW5ndGggPT09IDAgPyBjbGIoKSA6IGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJGb3VyOiAoZSwgY2xiKSA9PiB7XG4gICAgICAgICAgICAodmFsaWRhdG9yLmlzTnVtZXJpYyhlLnRhcmdldC52YWx1ZS50cmltKCkpICYmIGUudGFyZ2V0LnZhbHVlLnRyaW0oKS5sZW5ndGggPD0gNCkgfHwgZS50YXJnZXQudmFsdWUudHJpbSgpLmxlbmd0aCA9PT0gMCA/IGNsYigpIDogZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIH0sXG4gICAgICAgIHRyRGF0ZTogKHZhbHVlLCBjbGIpID0+ICB7XG4gICAgICAgICAgICB2YWxpZGF0b3IuaXNEYXRlKHZhbHVlKSA/IGNsYigpIDogbnVsbFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgJChcIiN0ckRhdGVcIikucGVyc2lhbkRhdGVwaWNrZXIoe1xuICAgICAgICAgICAgb25TZWxlY3Q6ICh1bml4KSA9PiB7XG4gICAgICAgICAgICAgICAgaGFuZGxlVmFsaWRhdGUudHJEYXRlKG5ldyBEYXRlKHVuaXgpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRyYW5zYWN0aW9uRGF0ZShuZXcgcGVyc2lhbkRhdGUodW5peCkuZm9ybWF0KCdZWVlZL01NL0REIEhIOm1tOnNzJykpXG4gICAgICAgICAgICAgICAgICAgIHNldEVuRGF0ZShuZXcgRGF0ZSh1bml4KSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluaXRpYWxWYWx1ZTogZmFsc2UsXG4gICAgICAgICAgICBvYnNlcnZlcjogdHJ1ZSxcbiAgICAgICAgICAgIGZvcm1hdDogJ1lZWVkvTU0vREQgSEg6bW06c3MnLFxuICAgICAgICAgICAgYWx0Rm9ybWF0OiAnWVlZWS9NTS9ERCBISDptbTpzcycsXG4gICAgICAgICAgICBjYWxlbmRhcjp7XG4gICAgICAgICAgICAgICAgcGVyc2lhbjoge1xuICAgICAgICAgICAgICAgICAgICBsZWFwWWVhck1vZGU6ICdhc3Ryb25vbWljYWwnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGltZVBpY2tlcjoge1xuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9LCBbXSlcbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPHA+2KjZhyDZhdmG2LjZiNixINm+2LHYr9in2K7YqiDZh9iy24zZhtmHINin2LIg2LfYsduM2YIg2YjYp9ix24zYsiDZiNis2Ycg2KjZhyDYrdiz2KfYqNiMINmF24wg2KrZiNin2YbbjNivINin2LIg2LTZhdin2LHZhyDYrdiz2KfYqCDYstuM2LEg2KfYs9iq2YHYp9mHINqp2LHYr9mHINmIINm+2LMg2KfYsiDYp9iq2YXYp9mFINi52YXZhNuM2KfYqiDZvtix2K/Yp9iu2Kog2KfYt9mE2KfYudin2Kog2YHbjNi0INmI2KfYsduM2LLbjCDYsdinINiv2LEg2qnYp9iv2LEg2LLbjNixINmI2KfYsdivINmG2YXYp9uM24zYryDZiCDYqNixINio2LHZiNuMINiv2qnZhdmHINir2KjYqiDZiNin2LHbjNiyINqp2YTbjNqpINmG2YXYp9uM24zYry48L3A+XG4gICAgICAgICAgICA8dWwgY2xhc3NOYW1lPVwicG9wdXAtbGlzdFwiPlxuICAgICAgICAgICAgICAgIDxsaT48aSBjbGFzc05hbWU9XCJmYWQgZmEtY29pbnNcIj48L2k+2YXYqNmE2Lo6IDxzcGFuPntudW1iZXJfZm9ybWF0KGFtb3VudCwgdHJ1ZSl9PC9zcGFuPjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPjxpIGNsYXNzTmFtZT1cImZhciBmYS11bml2ZXJzaXR5XCI+PC9pPtmG2LLYryA6IDxzcGFuPtio2KfZhtqpINmF2YTYqjwvc3Bhbj48L2xpPlxuICAgICAgICAgICAgICAgIDxsaT48aSBjbGFzc05hbWU9XCJmYXIgZmEtYnVpbGRpbmdcIj48L2k+2KjZhyDZhtin2YU6IDxzcGFuPtin2LHZhdi62KfZhiDaqdmH2qnYtNin2YYg2b7Yp9ix2LM8L3NwYW4+PC9saT5cbiAgICAgICAgICAgICAgICA8bGk+PGkgY2xhc3NOYW1lPVwiZmFkIGZhLWNyZWRpdC1jYXJkLWZyb250XCI+PC9pPti02YXYp9ix2Ycg2qnYp9ix2Ko6IDxzcGFuPntiYV9jYXJkfTwvc3Bhbj48YSBocmVmPVwiI1wiIGNsYXNzTmFtZT1cInZlcnRpY2FsLW1pZGRsZSBiYWRnZSBiYWRnZS1waWxsIGJhZGdlLWxpZ2h0IG1yLTFcIiBvbkNsaWNrPXsoKSA9PiBjb3B5VG9DbGlwYm9hcmQoXCI2MTA0MzM4ODAwMDQ2MjgyXCIsIFwi2LTZhdin2LHZhyDYrdiz2KfYqFwiKX0+2qnZvtuMPC9hPjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPjxpIGNsYXNzTmFtZT1cImZhciBmYS1tb25leS1jaGVjay1lZGl0LWFsdFwiPjwvaT7YtNmF2KfYsdmHINi02KjYpzogPHNwYW4+e2JhX3NoYWJhfTwvc3Bhbj48YSBocmVmPVwiI1wiIGNsYXNzTmFtZT1cInZlcnRpY2FsLW1pZGRsZSBiYWRnZSBiYWRnZS1waWxsIGJhZGdlLWxpZ2h0IG1yLTFcIiBvbkNsaWNrPXsoKSA9PiBjb3B5VG9DbGlwYm9hcmQoXCIxNzAxMjAwMDAwMDAwMDk1NDY2MTg4MzFcIiwgXCLYtNmF2KfYsdmHINi02KjYp1wiKX0+2qnZvtuMPC9hPjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPjxpIGNsYXNzTmFtZT1cImZhciBmYS1tb25leS1jaGVjay1hbHRcIj48L2k+2LTZhdin2LHZhyDYrdiz2KfYqDogPHNwYW4gY2xhc3NOYW1lPVwiaW5saW5lLWJsb2NrIGx0clwiPntiYV9oZXNhYn08L3NwYW4+PGEgaHJlZj1cIiNcIiBjbGFzc05hbWU9XCJ2ZXJ0aWNhbC1taWRkbGUgYmFkZ2UgYmFkZ2UtcGlsbCBiYWRnZS1saWdodCBtci0xXCIgb25DbGljaz17KCkgPT4gY29weVRvQ2xpcGJvYXJkKGJhX2hlc2FiLCBcIti02YXYp9ix2Ycg2K3Ys9in2KhcIil9Ptqp2b7bjDwvYT48L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaW5wdXQtZ3JvdXAgbXQtNFwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaW5wdXQtZ3JvdXAtYXBwZW5kXCI+PHNwYW4gY2xhc3NOYW1lPVwiaW5wdXQtZ3JvdXAtdGV4dFwiPtiq2KfYsduM2K4g2b7Ysdiv2KfYrtiqIDxpIGNsYXNzTmFtZT1cInRleHQtZGFuZ2VyIGZhcyBmYS1zdGFyLW9mLWxpZmUgbXItMSBtYi0yIGZvbnQtMTBcIj48L2k+PC9zcGFuPjwvZGl2PlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGRpc2FibGVkPXtkaXNhYmxlZH0gaWQ9XCJ0ckRhdGVcIiBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2xcIiBwbGFjZWhvbGRlcj1cItiq2KfYsduM2K4g2Ygg2LPYp9i52Kog2K/ZgtuM2YIg2KrYsdin2qnZhti0INix2Kcg2KfZhtiq2K7Yp9ioINqp2YbbjNivXCIgdmFsdWU9e3RyYW5zYWN0aW9uRGF0ZX0gb25DaGFuZ2U9eygpID0+IHt9fSAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImlucHV0LWdyb3VwIG10LTRcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImlucHV0LWdyb3VwLWFwcGVuZFwiPjxzcGFuIGNsYXNzTmFtZT1cImlucHV0LWdyb3VwLXRleHRcIj7YtNmF2KfYsdmHINm+24zar9uM2LHbjCA8aSBjbGFzc05hbWU9XCJ0ZXh0LWRhbmdlciBmYXMgZmEtc3Rhci1vZi1saWZlIG1yLTEgbWItMiBmb250LTEwXCI+PC9pPjwvc3Bhbj48L2Rpdj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBkaXNhYmxlZD17ZGlzYWJsZWR9IGNsYXNzTmFtZT1cImZvcm0tY29udHJvbFwiIHBsYWNlaG9sZGVyPVwi2LTZhdin2LHZhyDZvtuM2q/bjNix24wg2LHYpyDZiNin2LHYryDaqdmG24zYryAo2KfYrNio2KfYsduMKVwiIHZhbHVlPXt0cmFuc2FjdGlvbkNvZGV9IG9uQ2hhbmdlPXsoZSkgPT4gaGFuZGxlVmFsaWRhdGUudHJDb2RlKGUsICgpID0+IHNldFRyYW5zYWN0aW9uQ29kZShlLnRhcmdldC52YWx1ZS50cmltKCkpKX0gLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbnB1dC1ncm91cCBtdC00XCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbnB1dC1ncm91cC1hcHBlbmRcIj48c3BhbiBjbGFzc05hbWU9XCJpbnB1dC1ncm91cC10ZXh0XCI+NCDYsdmC2YUg2KLYrtixINqp2KfYsdiqPC9zcGFuPjwvZGl2PlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGRpc2FibGVkPXtkaXNhYmxlZH0gY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCIgcGxhY2Vob2xkZXI9XCLYr9ixINi12YjYsdiqINqp2KfYsdiqINio2Ycg2qnYp9ix2KogNCDYsdmC2YUg2KLYrtixINix2Kcg2YjYp9ix2K8g2YbZhdin24zbjNivXCIgdmFsdWU9e2ZvdXJEaWdpdHN9IG9uQ2hhbmdlPXsoZSkgPT4gaGFuZGxlVmFsaWRhdGUudHJGb3VyKGUsICgpID0+IHNldEZvckRpZ2l0cyhlLnRhcmdldC52YWx1ZS50cmltKCkpKX0gLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LTEwMCB0ZXh0LWNlbnRlciBtdC00XCI+XG4gICAgICAgICAgICAgICAgPGEgaHJlZj1cIiNjaGVja190cmFuc2FjdGlvblwiIGNsYXNzTmFtZT1cImJ0biBidG4tbGcgYnRuLWxpZ2h0XCIgb25DbGljaz17c2VuZEZvcm19Ptir2KjYqiDZiNin2LHbjNiyPC9hPiAgICBcbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8Lz5cbiAgICApXG59Il0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZVN0YXRlIiwiY29weVRvQ2xpcGJvYXJkIiwidmFsaWRhdG9yIiwiQWxlcnRTZXJ2aWNlIiwibnVtYmVyX2Zvcm1hdCIsIkRpcmVjdFBheW1lbnQiLCJhbW91bnQiLCJwYXkiLCJ0cmFuc2FjdGlvbkRhdGUiLCJzZXRUcmFuc2FjdGlvbkRhdGUiLCJlbkRhdGUiLCJzZXRFbkRhdGUiLCJ0cmFuc2FjdGlvbkNvZGUiLCJzZXRUcmFuc2FjdGlvbkNvZGUiLCJmb3VyRGlnaXRzIiwic2V0Rm9yRGlnaXRzIiwiZGlzYWJsZWQiLCJkaXNhYmxlIiwiYmFfY2FyZCIsImJhX3NoYWJhIiwiYmFfaGVzYWIiLCJlcnJzIiwic2VuZEZvcm0iLCJpc051bWVyaWMiLCJpc0xlbmd0aCIsIm1pbiIsIm1heCIsInB1c2giLCJsZW5ndGgiLCJpc0RhdGUiLCJlcnJvciIsInRpdGxlIiwiaHRtbCIsIm1hcCIsImVyciIsImNvbmZpcm1CdXR0b25UZXh0IiwidHJhbnNhY3Rpb25fY29kZSIsInRyYW5zYWN0aW9uX2RhdGUiLCJmb3VyX2RpZ2l0cyIsIm9rYXkiLCJtZXRob2QiLCJoYW5kbGVWYWxpZGF0ZSIsInRyQ29kZSIsImUiLCJjbGIiLCJ0YXJnZXQiLCJ2YWx1ZSIsInRyaW0iLCJwcmV2ZW50RGVmYXVsdCIsInRyRm91ciIsInRyRGF0ZSIsIiQiLCJwZXJzaWFuRGF0ZXBpY2tlciIsIm9uU2VsZWN0IiwidW5peCIsIkRhdGUiLCJwZXJzaWFuRGF0ZSIsImZvcm1hdCIsImluaXRpYWxWYWx1ZSIsIm9ic2VydmVyIiwiYWx0Rm9ybWF0IiwiY2FsZW5kYXIiLCJwZXJzaWFuIiwibGVhcFllYXJNb2RlIiwidGltZVBpY2tlciIsImVuYWJsZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/userarea/Pages/Private/Finance/Invoices/components/DirectPayment.jsx\n");

/***/ }),

/***/ "./resources/js/userarea/Pages/Private/Finance/Invoices/components/OnlinePayment.jsx":
/*!*******************************************************************************************!*\
  !*** ./resources/js/userarea/Pages/Private/Finance/Invoices/components/OnlinePayment.jsx ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ OnlinePayment)\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../../helpers */ \"./resources/js/helpers/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\n\n\n\n\nfunction OnlinePayment(_ref) {\n  var pay = _ref.pay,\n      amount = _ref.amount;\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"p\", {\n      children: [\"\\u067E\\u0631\\u062F\\u0627\\u062E\\u062A \\u0645\\u0628\\u0644\\u063A : \", (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.number_format)(amount, true)]\n    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"p\", {\n      children: \"\\u0628\\u0627 \\u06A9\\u0644\\u06CC\\u06A9 \\u0628\\u0631 \\u0631\\u0648\\u06CC \\u062F\\u0631\\u06AF\\u0627\\u0647 \\u0632\\u06CC\\u0631 \\u062E\\u0648\\u062F \\u0628\\u0647 \\u062E\\u0648\\u062F \\u0628\\u0647 \\u0635\\u0641\\u062D\\u0647 \\u067E\\u0631\\u062F\\u0627\\u062E\\u062A \\u0645\\u0646\\u062A\\u0642\\u0644 \\u0634\\u062F\\u0647 \\u0648 \\u0627\\u0645\\u06A9\\u0627\\u0646 \\u062A\\u0633\\u0648\\u06CC\\u0647 \\u062D\\u0633\\u0627\\u0628 \\u0628\\u0631\\u0627\\u06CC \\u0634\\u0645\\u0627 \\u0641\\u0631\\u0627\\u0647\\u0645 \\u0645\\u06CC\\u06AF\\u0631\\u062F\\u062F.\"\n    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n      className: \"w-100 text-center my-4\",\n      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"span\", {\n        className: \"gateway-btn cursor-pointer\",\n        onClick: function onClick() {\n          return pay('zarinpal');\n        },\n        children: [\"\\u062F\\u0631\\u06AF\\u0627\\u0647 \\u0628\\u0627\\u0646\\u06A9\\u06CC \\u0632\\u0631\\u06CC\\u0646 \\u067E\\u0627\\u0644\", /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"img\", {\n          src: APP_PATH + \"images/gallery/zarin-paal.jpg\",\n          alt: \"zarin-paal logo\"\n        })]\n      })\n    })]\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvdXNlcmFyZWEvUGFnZXMvUHJpdmF0ZS9GaW5hbmNlL0ludm9pY2VzL2NvbXBvbmVudHMvT25saW5lUGF5bWVudC5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7QUFFZSxTQUFTQyxhQUFULE9BQXNDO0VBQUEsSUFBZEMsR0FBYyxRQUFkQSxHQUFjO0VBQUEsSUFBVEMsTUFBUyxRQUFUQSxNQUFTO0VBQ2pELG9CQUNJO0lBQUEsd0JBQ0k7TUFBQSwrRUFBa0JILHVEQUFhLENBQUNHLE1BQUQsRUFBUyxJQUFULENBQS9CO0lBQUEsRUFESixlQUVJO01BQUE7SUFBQSxFQUZKLGVBR0k7TUFBSyxTQUFTLEVBQUMsd0JBQWY7TUFBQSx1QkFDSTtRQUFNLFNBQVMsRUFBQyw0QkFBaEI7UUFBNkMsT0FBTyxFQUFFO1VBQUEsT0FBTUQsR0FBRyxDQUFDLFVBQUQsQ0FBVDtRQUFBLENBQXREO1FBQUEscUlBRUk7VUFBSyxHQUFHLEVBQUVFLFFBQVEsR0FBRywrQkFBckI7VUFBc0QsR0FBRyxFQUFDO1FBQTFELEVBRko7TUFBQTtJQURKLEVBSEo7RUFBQSxFQURKO0FBWUgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvdXNlcmFyZWEvUGFnZXMvUHJpdmF0ZS9GaW5hbmNlL0ludm9pY2VzL2NvbXBvbmVudHMvT25saW5lUGF5bWVudC5qc3g/NzdhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBudW1iZXJfZm9ybWF0IH0gZnJvbSBcIi4uLy4uLy4uLy4uLy4uLy4uL2hlbHBlcnNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gT25saW5lUGF5bWVudCh7cGF5LCBhbW91bnR9KSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxwPtm+2LHYr9in2K7YqiDZhdio2YTYuiA6IHtudW1iZXJfZm9ybWF0KGFtb3VudCwgdHJ1ZSl9PC9wPlxuICAgICAgICAgICAgPHA+2KjYpyDaqdmE24zaqSDYqNixINix2YjbjCDYr9ix2q/Yp9mHINiy24zYsSDYrtmI2K8g2KjZhyDYrtmI2K8g2KjZhyDYtdmB2K3ZhyDZvtix2K/Yp9iu2Kog2YXZhtiq2YLZhCDYtNiv2Ycg2Ygg2KfZhdqp2KfZhiDYqtiz2YjbjNmHINit2LPYp9ioINio2LHYp9uMINi02YXYpyDZgdix2KfZh9mFINmF24zar9ix2K/Yry48L3A+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctMTAwIHRleHQtY2VudGVyIG15LTRcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJnYXRld2F5LWJ0biBjdXJzb3ItcG9pbnRlclwiIG9uQ2xpY2s9eygpID0+IHBheSgnemFyaW5wYWwnKX0+XG4gICAgICAgICAgICAgICAgICAgINiv2LHar9in2Ycg2KjYp9mG2qnbjCDYstix24zZhiDZvtin2YRcbiAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9e0FQUF9QQVRIICsgXCJpbWFnZXMvZ2FsbGVyeS96YXJpbi1wYWFsLmpwZ1wifSBhbHQ9XCJ6YXJpbi1wYWFsIGxvZ29cIiAvPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8Lz5cbiAgICApXG59Il0sIm5hbWVzIjpbIm51bWJlcl9mb3JtYXQiLCJPbmxpbmVQYXltZW50IiwicGF5IiwiYW1vdW50IiwiQVBQX1BBVEgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/userarea/Pages/Private/Finance/Invoices/components/OnlinePayment.jsx\n");

/***/ }),

/***/ "./resources/js/userarea/Pages/Private/Finance/Invoices/components/PaymentMethod.jsx":
/*!*******************************************************************************************!*\
  !*** ./resources/js/userarea/Pages/Private/Finance/Invoices/components/PaymentMethod.jsx ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../hooks */ \"./resources/js/userarea/hooks.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\nvar PaymentMethod = /*#__PURE__*/function (_Component) {\n  _inherits(PaymentMethod, _Component);\n\n  var _super = _createSuper(PaymentMethod);\n\n  function PaymentMethod(props) {\n    var _this;\n\n    _classCallCheck(this, PaymentMethod);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"onChangeMethod\", function (method) {\n      _this.setState({\n        paymentMethod: method\n      }, function () {\n        return _this.props.setMultiPay(method !== 'all');\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onChangeDiscount\", function (e) {\n      _this.setState({\n        discountCode: e.target.value\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"checkDiscount\", function () {\n      var discountCode = _this.state.discountCode;\n      console.log(\"discount code: \".concat(discountCode));\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"sendActivateRequest\", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var _this$state, paymentMethod, discountCode, response;\n\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _this$state = _this.state, paymentMethod = _this$state.paymentMethod, discountCode = _this$state.discountCode;\n              _context.next = 3;\n              return _this.http.post(\"/\".concat(_this.props.invoice.id, \"/activate\"), {\n                mode: paymentMethod\n              });\n\n            case 3:\n              response = _context.sent;\n\n              if (response.okay) {\n                _this.props.onActive(response.invoice);\n              }\n\n              _this.setState({\n                loading: false\n              });\n\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    })));\n\n    _defineProperty(_assertThisInitialized(_this), \"onSubmit\", function () {\n      _this.setState({\n        loading: true\n      }, _this.sendActivateRequest);\n    });\n\n    _this.state = {\n      paymentMethod: 'all',\n      discountCode: '',\n      loading: false\n    };\n    _this.http = (0,_hooks__WEBPACK_IMPORTED_MODULE_1__.useHttpService)('/userarea/invoices');\n    return _this;\n  }\n\n  _createClass(PaymentMethod, [{\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$state2 = this.state,\n          paymentMethod = _this$state2.paymentMethod,\n          loading = _this$state2.loading;\n      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", {\n        className: \"float-left w-100 mt-4\",\n        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"h3\", {\n          className: \"factor-section-title\",\n          children: \"\\u0627\\u0646\\u062A\\u062E\\u0627\\u0628 \\u0634\\u06CC\\u0648\\u0647 \\u067E\\u0631\\u062F\\u0627\\u062E\\u062A\"\n        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"p\", {\n          className: \"payment-desc\",\n          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", {\n            children: \"\\u067E\\u0631\\u062F\\u0627\\u062E\\u062A \\u0628\\u0647 \\u0635\\u0648\\u0631\\u062A \\u06A9\\u0644\\u06CC: \"\n          }), \"\\u062F\\u0631 \\u0627\\u06CC\\u0646 \\u0634\\u06CC\\u0648\\u0647 \\u0634\\u0645\\u0627 \\u0645\\u062C\\u0645\\u0648\\u0639 \\u0647\\u0632\\u06CC\\u0646\\u0647 \\u0633\\u0641\\u0627\\u0631\\u0634 \\u062E\\u0648\\u062F \\u0631\\u0627 \\u062F\\u0631 \\u06CC\\u06A9 \\u062A\\u0631\\u0627\\u06A9\\u0646\\u0634 \\u0627\\u0646\\u062C\\u0627\\u0645 \\u0645\\u06CC \\u062F\\u0647\\u06CC\\u062F\"]\n        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"p\", {\n          className: \"payment-desc\",\n          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", {\n            children: \"\\u067E\\u0631\\u062F\\u0627\\u062E\\u062A \\u0628\\u0647 \\u0635\\u0648\\u0631\\u062A \\u0645\\u0648\\u0631\\u062F\\u06CC: \"\n          }), \"\\u062F\\u0631 \\u0627\\u06CC\\u0646 \\u0634\\u06CC\\u0648\\u0647 \\u067E\\u0631\\u062F\\u0627\\u062E\\u062A \\u0647\\u0632\\u06CC\\u0646\\u0647 \\u0633\\u0641\\u0627\\u0631\\u0634 \\u0628\\u0647 \\u0635\\u0648\\u0631\\u062A \\u062C\\u062F\\u0627\\u06AF\\u0627\\u0646\\u0647 \\u0628\\u0631\\u0627\\u06CC \\u0647\\u0631 \\u0622\\u06CC\\u062A\\u0645 \\u0637\\u0631\\u0627\\u062D\\u06CC \\u062F\\u0631 \\u0633\\u0628\\u062F \\u0634\\u0645\\u0627 \\u0627\\u0646\\u062C\\u0627\\u0645 \\u0645\\u06CC \\u0634\\u0648\\u062F\"]\n        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", {\n          className: \"payment-method-container\",\n          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"input\", {\n            type: \"radio\",\n            name: \"select\",\n            id: \"option-1\",\n            checked: paymentMethod === 'all',\n            onChange: function onChange() {\n              return _this2.onChangeMethod(\"all\");\n            }\n          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"input\", {\n            type: \"radio\",\n            name: \"select\",\n            id: \"option-2\",\n            checked: paymentMethod === \"items\",\n            onChange: function onChange() {\n              return _this2.onChangeMethod(\"items\");\n            }\n          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"label\", {\n            htmlFor: \"option-1\",\n            className: \"option option-1\",\n            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", {\n              children: \"\\u0628\\u0647 \\u0635\\u0648\\u0631\\u062A \\u06A9\\u0644\\u06CC\"\n            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n              className: \"dot\"\n            })]\n          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"label\", {\n            htmlFor: \"option-2\",\n            className: \"option option-2\",\n            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", {\n              children: \"\\u0628\\u0647 \\u0635\\u0648\\u0631\\u062A \\u0645\\u0648\\u0631\\u062F\\u06CC\"\n            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n              className: \"dot\"\n            })]\n          }), paymentMethod === \"all\" && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", {\n            className: \"input-group\",\n            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n              className: \"input-group-prepend\",\n              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", {\n                className: \"input-group-text\",\n                children: \"\\u06A9\\u062F \\u062A\\u062E\\u0641\\u06CC\\u0641\"\n              })\n            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"input\", {\n              type: \"text\",\n              className: \"form-control\",\n              placeholder: \"\\u0627\\u06CC\\u0646\\u062C\\u0627 \\u0648\\u0627\\u0631\\u062F \\u06A9\\u0646\\u06CC\\u062F\",\n              onChange: this.onChangeDiscount.bind(this)\n            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n              className: \"input-group-append\",\n              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"button\", {\n                className: \"btn btn-light\",\n                onClick: this.checkDiscount,\n                children: \"\\u0627\\u0633\\u062A\\u0639\\u0644\\u0627\\u0645\"\n              })\n            })]\n          })]\n        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n          className: \"w-100 text-center mt-2\",\n          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"button\", {\n            className: \"btn btn-lg btn-light px-5\",\n            disabled: loading,\n            onClick: this.onSubmit,\n            children: loading ? 'در حال پردازش' : 'تایید'\n          })\n        })]\n      });\n    }\n  }]);\n\n  return PaymentMethod;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PaymentMethod);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvdXNlcmFyZWEvUGFnZXMvUHJpdmF0ZS9GaW5hbmNlL0ludm9pY2VzL2NvbXBvbmVudHMvUGF5bWVudE1ldGhvZC5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OytDQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBREE7QUFDQTs7OztJQUVNRzs7Ozs7RUFDRix1QkFBWUMsS0FBWixFQUFtQjtJQUFBOztJQUFBOztJQUNmLDBCQUFNQSxLQUFOOztJQURlLGlFQVNGLFVBQUNDLE1BQUQsRUFBWTtNQUN6QixNQUFLQyxRQUFMLENBQWM7UUFDVkMsYUFBYSxFQUFFRjtNQURMLENBQWQsRUFFRztRQUFBLE9BQU0sTUFBS0QsS0FBTCxDQUFXSSxXQUFYLENBQXVCSCxNQUFNLEtBQUssS0FBbEMsQ0FBTjtNQUFBLENBRkg7SUFHSCxDQWJrQjs7SUFBQSxtRUFjQSxVQUFDSSxDQUFELEVBQU87TUFDdEIsTUFBS0gsUUFBTCxDQUFjO1FBQ1ZJLFlBQVksRUFBRUQsQ0FBQyxDQUFDRSxNQUFGLENBQVNDO01BRGIsQ0FBZDtJQUdILENBbEJrQjs7SUFBQSxnRUFtQkgsWUFBTTtNQUNsQixJQUFNRixZQUFOLEdBQXVCLE1BQUtHLEtBQTVCLENBQU1ILFlBQU47TUFDQUksT0FBTyxDQUFDQyxHQUFSLDBCQUE4QkwsWUFBOUI7SUFDSCxDQXRCa0I7O0lBQUEsOElBdUJHO01BQUE7O01BQUE7UUFBQTtVQUFBO1lBQUE7Y0FBQSxjQUNxQixNQUFLRyxLQUQxQixFQUNaTixhQURZLGVBQ1pBLGFBRFksRUFDR0csWUFESCxlQUNHQSxZQURIO2NBQUE7Y0FBQSxPQUVLLE1BQUtNLElBQUwsQ0FBVUMsSUFBVixZQUFtQixNQUFLYixLQUFMLENBQVdjLE9BQVgsQ0FBbUJDLEVBQXRDLGdCQUFxRDtnQkFBQ0MsSUFBSSxFQUFFYjtjQUFQLENBQXJELENBRkw7O1lBQUE7Y0FFWmMsUUFGWTs7Y0FHbEIsSUFBSUEsUUFBUSxDQUFDQyxJQUFiLEVBQW1CO2dC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QXhEO1lBQWlFLE9BQU8sRUFBRSxLQUFLTSxRQUEvRTtZQUFBLFVBRUlOLE9BQU8sR0FDUCxlQURPLEdBRUw7VUFKTjtRQURKLEVBL0JKO01BQUEsRUFESjtJQTJDSDs7OztFQWxGdUJ2Qjs7QUFxRjVCLGlFQUFlRSxhQUFmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL3VzZXJhcmVhL1BhZ2VzL1ByaXZhdGUvRmluYW5jZS9JbnZvaWNlcy9jb21wb25lbnRzL1BheW1lbnRNZXRob2QuanN4PzY2MjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUh0dHBTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vaG9va3MnO1xuXG5jbGFzcyBQYXltZW50TWV0aG9kIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcylcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHBheW1lbnRNZXRob2Q6ICdhbGwnLFxuICAgICAgICAgICAgZGlzY291bnRDb2RlOiAnJyxcbiAgICAgICAgICAgIGxvYWRpbmc6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5odHRwID0gdXNlSHR0cFNlcnZpY2UoJy91c2VyYXJlYS9pbnZvaWNlcycpXG4gICAgfVxuICAgIG9uQ2hhbmdlTWV0aG9kID0gKG1ldGhvZCkgPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHBheW1lbnRNZXRob2Q6IG1ldGhvZFxuICAgICAgICB9LCAoKSA9PiB0aGlzLnByb3BzLnNldE11bHRpUGF5KG1ldGhvZCAhPT0gJ2FsbCcpKVxuICAgIH1cbiAgICBvbkNoYW5nZURpc2NvdW50ID0gKGUpID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBkaXNjb3VudENvZGU6IGUudGFyZ2V0LnZhbHVlXG4gICAgICAgIH0pXG4gICAgfVxuICAgIGNoZWNrRGlzY291bnQgPSAoKSA9PiB7XG4gICAgICAgIGxldCB7IGRpc2NvdW50Q29kZSB9ID0gdGhpcy5zdGF0ZVxuICAgICAgICBjb25zb2xlLmxvZyhgZGlzY291bnQgY29kZTogJHtkaXNjb3VudENvZGV9YCk7XG4gICAgfVxuICAgIHNlbmRBY3RpdmF0ZVJlcXVlc3QgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGxldCB7IHBheW1lbnRNZXRob2QsIGRpc2NvdW50Q29kZSB9ICA9IHRoaXMuc3RhdGVcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHAucG9zdChgLyR7dGhpcy5wcm9wcy5pbnZvaWNlLmlkfS9hY3RpdmF0ZWAsIHttb2RlOiBwYXltZW50TWV0aG9kfSlcbiAgICAgICAgaWYgKHJlc3BvbnNlLm9rYXkpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25BY3RpdmUocmVzcG9uc2UuaW52b2ljZSlcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFN0YXRlKHsgbG9hZGluZzogZmFsc2UgfSlcbiAgICB9XG4gICAgb25TdWJtaXQgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgbG9hZGluZzogdHJ1ZVxuICAgICAgICB9LCB0aGlzLnNlbmRBY3RpdmF0ZVJlcXVlc3QpXG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcGF5bWVudE1ldGhvZCwgbG9hZGluZyB9ID0gdGhpcy5zdGF0ZVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J2Zsb2F0LWxlZnQgdy0xMDAgbXQtNCc+XG4gICAgICAgICAgICAgICAgPGgzIGNsYXNzTmFtZT0nZmFjdG9yLXNlY3Rpb24tdGl0bGUnPtin2YbYqtiu2KfYqCDYtNuM2YjZhyDZvtix2K/Yp9iu2Ko8L2gzPlxuICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT0ncGF5bWVudC1kZXNjJz48c3Bhbj7Zvtix2K/Yp9iu2Kog2KjZhyDYtdmI2LHYqiDaqdmE24w6IDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAg2K/YsSDYp9uM2YYg2LTbjNmI2Ycg2LTZhdinINmF2KzZhdmI2Lkg2YfYstuM2YbZhyDYs9mB2KfYsdi0INiu2YjYryDYsdinINiv2LEg24zaqSDYqtix2KfaqdmG2LQg2KfZhtis2KfZhSDZhduMINiv2YfbjNivXG4gICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT0ncGF5bWVudC1kZXNjJz48c3Bhbj7Zvtix2K/Yp9iu2Kog2KjZhyDYtdmI2LHYqiDZhdmI2LHYr9uMOiA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgINiv2LEg2KfbjNmGINi024zZiNmHINm+2LHYr9in2K7YqiDZh9iy24zZhtmHINiz2YHYp9ix2LQg2KjZhyDYtdmI2LHYqiDYrNiv2Kfar9in2YbZhyDYqNix2KfbjCDZh9ixINii24zYqtmFINi32LHYp9it24wg2K/YsSDYs9io2K8g2LTZhdinINin2YbYrNin2YUg2YXbjCDYtNmI2K9cbiAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwYXltZW50LW1ldGhvZC1jb250YWluZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5hbWU9XCJzZWxlY3RcIiBpZD1cIm9wdGlvbi0xXCIgY2hlY2tlZD17cGF5bWVudE1ldGhvZCA9PT0gJ2FsbCd9ICAgb25DaGFuZ2U9eygpID0+IHRoaXMub25DaGFuZ2VNZXRob2QoXCJhbGxcIil9IC8+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwicmFkaW9cIiBuYW1lPVwic2VsZWN0XCIgaWQ9XCJvcHRpb24tMlwiIGNoZWNrZWQ9e3BheW1lbnRNZXRob2QgPT09IFwiaXRlbXNcIn0gb25DaGFuZ2U9eygpID0+IHRoaXMub25DaGFuZ2VNZXRob2QoXCJpdGVtc1wiKX0gLz5cbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9XCJvcHRpb24tMVwiIGNsYXNzTmFtZT1cIm9wdGlvbiBvcHRpb24tMVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+2KjZhyDYtdmI2LHYqiDaqdmE24w8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRvdFwiPjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgaHRtbEZvcj1cIm9wdGlvbi0yXCIgY2xhc3NOYW1lPVwib3B0aW9uIG9wdGlvbi0yXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj7YqNmHINi12YjYsdiqINmF2YjYsdiv24w8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRvdFwiPjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICB7cGF5bWVudE1ldGhvZCA9PT0gXCJhbGxcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbnB1dC1ncm91cFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaW5wdXQtZ3JvdXAtcHJlcGVuZFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJpbnB1dC1ncm91cC10ZXh0XCI+2qnYryDYqtiu2YHbjNmBPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzTmFtZT0nZm9ybS1jb250cm9sJyBwbGFjZWhvbGRlcj0n2KfbjNmG2KzYpyDZiNin2LHYryDaqdmG24zYrycgb25DaGFuZ2U9e3RoaXMub25DaGFuZ2VEaXNjb3VudC5iaW5kKHRoaXMpfSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaW5wdXQtZ3JvdXAtYXBwZW5kXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPSdidG4gYnRuLWxpZ2h0JyBvbkNsaWNrPXt0aGlzLmNoZWNrRGlzY291bnR9Ptin2LPYqti52YTYp9mFPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSd3LTEwMCB0ZXh0LWNlbnRlciBtdC0yJz5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9J2J0biBidG4tbGcgYnRuLWxpZ2h0IHB4LTUnIGRpc2FibGVkPXtsb2FkaW5nfSBvbkNsaWNrPXt0aGlzLm9uU3VibWl0fT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRpbmcgP1xuICAgICAgICAgICAgICAgICAgICAgICAgJ9iv2LEg2K3Yp9mEINm+2LHYr9in2LLYtCcgXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICfYqtin24zbjNivJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGF5bWVudE1ldGhvZDsiXSwibmFtZXMiOlsiUmVhY3QiLCJDb21wb25lbnQiLCJ1c2VIdHRwU2VydmljZSIsIlBheW1lbnRNZXRob2QiLCJwcm9wcyIsIm1ldGhvZCIsInNldFN0YXRlIiwicGF5bWVudE1ldGhvZCIsInNldE11bHRpUGF5IiwiZSIsImRpc2NvdW50Q29kZSIsInRhcmdldCIsInZhbHVlIiwic3RhdGUiLCJjb25zb2xlIiwibG9nIiwiaHR0cCIsInBvc3QiLCJpbnZvaWNlIiwiaWQiLCJtb2RlIiwicmVzcG9uc2UiLCJva2F5Iiwib25BY3RpdmUiLCJsb2FkaW5nIiwic2VuZEFjdGl2YXRlUmVxdWVzdCIsIm9uQ2hhbmdlTWV0aG9kIiwib25DaGFuZ2VEaXNjb3VudCIsImJpbmQiLCJjaGVja0Rpc2NvdW50Iiwib25TdWJtaXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/userarea/Pages/Private/Finance/Invoices/components/PaymentMethod.jsx\n");

/***/ }),

/***/ "./resources/js/userarea/Pages/Private/Finance/Invoices/components/PaymentPopup.jsx":
/*!******************************************************************************************!*\
  !*** ./resources/js/userarea/Pages/Private/Finance/Invoices/components/PaymentPopup.jsx ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PaymentPopup)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../hooks */ \"./resources/js/userarea/hooks.js\");\n/* harmony import */ var _OnlinePayment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OnlinePayment */ \"./resources/js/userarea/Pages/Private/Finance/Invoices/components/OnlinePayment.jsx\");\n/* harmony import */ var _DirectPayment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DirectPayment */ \"./resources/js/userarea/Pages/Private/Finance/Invoices/components/DirectPayment.jsx\");\n/* harmony import */ var _services_AlertService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../../../services/AlertService */ \"./resources/js/services/AlertService.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nfunction PaymentPopup(_ref) {\n  var close = _ref.close,\n      id = _ref.id,\n      amount = _ref.amount;\n  var http = (0,_hooks__WEBPACK_IMPORTED_MODULE_1__.useHttpService)(\"/userarea/bills/\".concat(id, \"/\"));\n  var methods = {\n    online: 'پرداخت به صورت آنلاین',\n    direct: 'پرداخت از طریق واریز به حساب'\n  };\n\n  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"online\"),\n      _useState2 = _slicedToArray(_useState, 2),\n      payMethod = _useState2[0],\n      setPayMethod = _useState2[1];\n\n  var onClose = function onClose(e) {\n    if (!$(e.target).closest(\"#popup-box\").length) {\n      close();\n    }\n  };\n\n  function payOnline(_x) {\n    return _payOnline.apply(this, arguments);\n  }\n\n  function _payOnline() {\n    _payOnline = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(method) {\n      var response, gateway;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return http.post(\"pay/\".concat(method));\n\n            case 2:\n              response = _context.sent;\n\n              if (response.okay) {\n                gateway = response.gateway;\n                window.location.href = gateway;\n              }\n\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n    return _payOnline.apply(this, arguments);\n  }\n\n  function sendPaymentDetails(_x2) {\n    return _sendPaymentDetails.apply(this, arguments);\n  }\n\n  function _sendPaymentDetails() {\n    _sendPaymentDetails = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(details) {\n      var _response$okay;\n\n      var response;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return http.post('pay/manual', {\n                details: details\n              });\n\n            case 2:\n              response = _context2.sent;\n\n              if (response.okay) {\n                new _services_AlertService__WEBPACK_IMPORTED_MODULE_4__[\"default\"]().success({\n                  title: \"ثبت شد\",\n                  html: response.message\n                });\n              }\n\n              return _context2.abrupt(\"return\", (_response$okay = response.okay) !== null && _response$okay !== void 0 ? _response$okay : false);\n\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n    return _sendPaymentDetails.apply(this, arguments);\n  }\n\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"div\", {\n    className: \"popup-container\",\n    onClick: onClose,\n    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(\"div\", {\n      className: \"popup-box alert-light animated fadeInDown\",\n      id: \"popup-box\",\n      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"div\", {\n        className: \"popup-header-tab\",\n        children: Object.entries(methods).map(function (_ref2) {\n          var _ref3 = _slicedToArray(_ref2, 2),\n              name = _ref3[0],\n              title = _ref3[1];\n\n          return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"span\", {\n            className: \"cursor-pointer \".concat(payMethod === name ? \"active\" : ''),\n            onClick: function onClick() {\n              return setPayMethod(name);\n            },\n            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(\"span\", {\n              children: title\n            })\n          }, name);\n        })\n      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(\"div\", {\n        className: \"popup-content\",\n        children: [payMethod === \"online\" && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_OnlinePayment__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n          amount: amount,\n          pay: payOnline\n        }), payMethod === \"direct\" && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_DirectPayment__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n          amount: amount,\n          pay: sendPaymentDetails\n        })]\n      })]\n    })\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvdXNlcmFyZWEvUGFnZXMvUHJpdmF0ZS9GaW5hbmNlL0ludm9pY2VzL2NvbXBvbmVudHMvUGF5bWVudFBvcHVwLmpzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7K0NBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVlLFNBQVNNLFlBQVQsT0FBMkM7RUFBQSxJQUFwQkMsS0FBb0IsUUFBcEJBLEtBQW9CO0VBQUEsSUFBYkMsRUFBYSxRQUFiQSxFQUFhO0VBQUEsSUFBVEMsTUFBUyxRQUFUQSxNQUFTO0VBQ3RELElBQU1DLElBQUksR0FBR1Isc0RBQWMsMkJBQW9CTSxFQUFwQixPQUEzQjtFQUNBLElBQU1HLE9BQU8sR0FBRztJQUNaQyxNQUFNLEVBQUUsdUJBREk7SUFFWkMsTUFBTSxFQUFFO0VBRkksQ0FBaEI7O0VBSUEsZ0JBQWtDWiwrQ0FBUSxDQUFDLFFBQUQsQ0FBMUM7RUFBQTtFQUFBLElBQU9hLFNBQVA7RUFBQSxJQUFrQkMsWUFBbEI7O0VBQ0EsSUFBTUMsT0FBTyxHQUFHLFNBQVZBLE9BQVUsQ0FBQ0MsQ0FBRCxFQUFPO0lBQ25CLElBQUksQ0FBQ0MsQ0FBQyxDQUFDRCxDQUFDLENBQUNFLE1BQUgsQ0FBRCxDQUFZQyxPQUFaLENBQW9CLFlBQXBCLEVBQWtDQyxNQUF2QyxFQUErQztNQUMzQ2QsS0FBSztJQUNSO0VBQ0osQ0FKRDs7RUFQc0QsU0FZdkNlLFNBWnVDO0lBQUE7RUFBQTs7RUFBQTtJQUFBLHdFQVl0RCxpQkFBeUJDLE1BQXpCO01BQUE7TUFBQTtRQUFBO1VBQUE7WUFBQTtjQUFBO2NBQUEsT0FDMkJiLElBQUksQ0FBQ2MsSUFBTCxlQUFpQkQsTUFBakIsRUFEM0I7O1lBQUE7Y0FDVUUsUUFEVjs7Y0FFSSxJQUFJQSxRQUFRLENBQUNDLElBQWIsRUFBbUI7Z0JBQ1ZDLE9BRFUsR0FDQ0YsUUFERCxDQUNWRSxPQURVO2dCQUVmQyxNQUFNLENBQUNDLFFBQVAsQ0FBZ0JDLElBQWhCLEdBQXVCSCxPQUF2QjtjQUNIOztZQUxMO1lBQUE7Y0FBQTtVQUFBO1FBQUE7TUFBQTtJQUFBLENBWnNEO0lBQUE7RUFBQTs7RUFBQSxTQW1CdkNJLGtCQW5CdUM7SUFBQTtFQUFBOztFQUFBO0lBQUEsaUZBbUJ0RCxrQkFBa0NDLE9BQWxDO01BQUE7O01BQUE7TUFBQTtRQUFBO1VBQUE7WUFBQTtjQUFBO2NBQUEsT0FDMkJ0QixJQUFJLENBQUNjLElBQUwsQ0FBVSxZQUFWLEVBQXdCO2dCQUFDUSxPQUFPLEVBQVBBO2NBQUQsQ0FBeEIsQ0FEM0I7O1lBQUE7Y0FDVVAsUUFEVjs7Y0FFSSxJQUFJQSxRQUFRLENBQUNDLElBQWIsRUFBbUI7Z0JBQ2QsSUFBSXJCLDhEQUFKLEVBQUQsQ0FBbUI0QixPQUFuQixDQUEyQjtrQkFDdkJDLEtBQUssRUFBRSxRQURnQjtrQkFFdkJDLElBQUksRUFBRVYsUUFBUSxDQUFDVztnQkFGUSxDQUEzQjtjQUlIOztjQVBMLG9EQVFXWCxRQUFRLENBQUNDLElBUnBCLDJEQVE0QixLQVI1Qjs7WUFBQTtZQUFBO2NBQUE7VUFBQTtRQUFBO01BQUE7SUFBQSxDQW5Cc0Q7SUFBQTtFQUFBOztFQTZCdEQsb0JBQ0k7SUFBSyxTQUFTLEVBQUMsaUJBQWY7SUFBaUMsT0FBTyxFQUFFVixPQUExQztJQUFBLHVCQUNJO01BQUssU0FBUyxFQUFDLDJDQUFmO01BQTJELEVBQUUsRUFBQyxXQUE5RDtNQUFBLHdCQUNJO1FBQUssU0FBUyxFQUFDLGtCQUFmO1FBQUEsVUFDS3FCLE1BQU0sQ0FBQ0MsT0FBUCxDQUFlM0IsT0FBZixFQUF3QjRCLEdBQXhCLENBQTRCO1VBQUE7VUFBQSxJQUFFQyxJQUFGO1VBQUEsSUFBUU4sS0FBUjs7VUFBQSxvQkFDekI7WUFBaUIsU0FBUywyQkFBb0JwQixTQUFTLEtBQUswQixJQUFkLEdBQXFCLFFBQXJCLEdBQWdDLEVBQXBELENBQTFCO1lBQW9GLE9BQU8sRUFBRTtjQUFBLE9BQU16QixZQUFZLENBQUN5QixJQUFELENBQWxCO1lBQUEsQ0FBN0Y7WUFBQSx1QkFDSTtjQUFBLFVBQU9OO1lBQVA7VUFESixHQUFXTSxJQUFYLENBRHlCO1FBQUEsQ0FBNUI7TUFETCxFQURKLGVBUUk7UUFBSyxTQUFTLEVBQUMsZUFBZjtRQUFBLFdBQ0sxQixTQUFTLEtBQUssUUFBZCxpQkFBMEIsdURBQUMsc0RBQUQ7VUFBZSxNQUFNLEVBQUVMLE1BQXZCO1VBQStCLEdBQUcsRUFBRWE7UUFBcEMsRUFEL0IsRUFFS1IsU0FBUyxLQUFLLFFBQWQsaUJBQTBCLHVEQUFDLHNEQUFEO1VBQWUsTUFBTSxFQUFFTCxNQUF2QjtVQUErQixHQUFHLEVBQUVzQjtRQUFwQyxFQUYvQjtNQUFBLEVBUko7SUFBQTtFQURKLEVBREo7QUFpQkgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvdXNlcmFyZWEvUGFnZXMvUHJpdmF0ZS9GaW5hbmNlL0ludm9pY2VzL2NvbXBvbmVudHMvUGF5bWVudFBvcHVwLmpzeD9lOTkwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiXG5pbXBvcnQgeyB1c2VIdHRwU2VydmljZSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL2hvb2tzJ1xuaW1wb3J0IE9ubGluZVBheW1lbnQgZnJvbSAnLi9PbmxpbmVQYXltZW50J1xuaW1wb3J0IERpcmVjdFBheW1lbnQgZnJvbSAnLi9EaXJlY3RQYXltZW50J1xuaW1wb3J0IEFsZXJ0U2VydmljZSBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vLi4vc2VydmljZXMvQWxlcnRTZXJ2aWNlXCJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUGF5bWVudFBvcHVwKHtjbG9zZSwgaWQsIGFtb3VudH0pIHtcbiAgICBjb25zdCBodHRwID0gdXNlSHR0cFNlcnZpY2UoYC91c2VyYXJlYS9iaWxscy8ke2lkfS9gKVxuICAgIGNvbnN0IG1ldGhvZHMgPSB7XG4gICAgICAgIG9ubGluZTogJ9m+2LHYr9in2K7YqiDYqNmHINi12YjYsdiqINii2YbZhNin24zZhicsXG4gICAgICAgIGRpcmVjdDogJ9m+2LHYr9in2K7YqiDYp9iyINi32LHbjNmCINmI2KfYsduM2LIg2KjZhyDYrdiz2KfYqCdcbiAgICB9XG4gICAgY29uc3QgW3BheU1ldGhvZCwgc2V0UGF5TWV0aG9kXSA9IHVzZVN0YXRlKFwib25saW5lXCIpXG4gICAgY29uc3Qgb25DbG9zZSA9IChlKSA9PiB7XG4gICAgICAgIGlmICghJChlLnRhcmdldCkuY2xvc2VzdChcIiNwb3B1cC1ib3hcIikubGVuZ3RoKSB7XG4gICAgICAgICAgICBjbG9zZSgpXG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gcGF5T25saW5lKG1ldGhvZCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGh0dHAucG9zdChgcGF5LyR7bWV0aG9kfWApXG4gICAgICAgIGlmIChyZXNwb25zZS5va2F5KSB7XG4gICAgICAgICAgICBsZXQge2dhdGV3YXl9ID0gcmVzcG9uc2VcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gZ2F0ZXdheVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHNlbmRQYXltZW50RGV0YWlscyhkZXRhaWxzKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaHR0cC5wb3N0KCdwYXkvbWFudWFsJywge2RldGFpbHN9KVxuICAgICAgICBpZiAocmVzcG9uc2Uub2theSkge1xuICAgICAgICAgICAgKG5ldyBBbGVydFNlcnZpY2UpLnN1Y2Nlc3Moe1xuICAgICAgICAgICAgICAgIHRpdGxlOiBcItir2KjYqiDYtNivXCIsXG4gICAgICAgICAgICAgICAgaHRtbDogcmVzcG9uc2UubWVzc2FnZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2Uub2theSA/PyBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwb3B1cC1jb250YWluZXJcIiBvbkNsaWNrPXtvbkNsb3NlfT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicG9wdXAtYm94IGFsZXJ0LWxpZ2h0IGFuaW1hdGVkIGZhZGVJbkRvd25cIiBpZD1cInBvcHVwLWJveFwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicG9wdXAtaGVhZGVyLXRhYlwiPlxuICAgICAgICAgICAgICAgICAgICB7T2JqZWN0LmVudHJpZXMobWV0aG9kcykubWFwKChbbmFtZSwgdGl0bGVdKSA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBrZXk9e25hbWV9IGNsYXNzTmFtZT17YGN1cnNvci1wb2ludGVyICR7cGF5TWV0aG9kID09PSBuYW1lID8gXCJhY3RpdmVcIiA6ICcnfWB9IG9uQ2xpY2s9eygpID0+IHNldFBheU1ldGhvZChuYW1lKX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3RpdGxlfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwb3B1cC1jb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgIHtwYXlNZXRob2QgPT09IFwib25saW5lXCIgJiYgPE9ubGluZVBheW1lbnQgYW1vdW50PXthbW91bnR9IHBheT17cGF5T25saW5lfS8+fVxuICAgICAgICAgICAgICAgICAgICB7cGF5TWV0aG9kID09PSBcImRpcmVjdFwiICYmIDxEaXJlY3RQYXltZW50IGFtb3VudD17YW1vdW50fSBwYXk9e3NlbmRQYXltZW50RGV0YWlsc30vPn1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICApXG59Il0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3RhdGUiLCJ1c2VIdHRwU2VydmljZSIsIk9ubGluZVBheW1lbnQiLCJEaXJlY3RQYXltZW50IiwiQWxlcnRTZXJ2aWNlIiwiUGF5bWVudFBvcHVwIiwiY2xvc2UiLCJpZCIsImFtb3VudCIsImh0dHAiLCJtZXRob2RzIiwib25saW5lIiwiZGlyZWN0IiwicGF5TWV0aG9kIiwic2V0UGF5TWV0aG9kIiwib25DbG9zZSIsImUiLCIkIiwidGFyZ2V0IiwiY2xvc2VzdCIsImxlbmd0aCIsInBheU9ubGluZSIsIm1ldGhvZCIsInBvc3QiLCJyZXNwb25zZSIsIm9rYXkiLCJnYXRld2F5Iiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwic2VuZFBheW1lbnREZXRhaWxzIiwiZGV0YWlscyIsInN1Y2Nlc3MiLCJ0aXRsZSIsImh0bWwiLCJtZXNzYWdlIiwiT2JqZWN0IiwiZW50cmllcyIsIm1hcCIsIm5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/userarea/Pages/Private/Finance/Invoices/components/PaymentPopup.jsx\n");

/***/ }),

/***/ "./node_modules/persian-date/dist/persian-date.js":
/*!********************************************************!*\
  !*** ./node_modules/persian-date/dist/persian-date.js ***!
  \********************************************************/
/***/ (function(module) {

eval("/*!\n * \n * persian-date -  1.1.0\n * Reza Babakhani <babakhani.reza@gmail.com>\n * http://babakhani.github.io/PersianWebToolkit/docs/persian-date/\n * Under MIT license \n * \n * \n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_724__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_724__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_724__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_724__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__nested_webpack_require_724__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_724__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_724__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_724__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_724__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_724__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_724__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_724__(__nested_webpack_require_724__.s = 8);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __nested_webpack_require_3157__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar durationUnit = __nested_webpack_require_3157__(4).durationUnit;\n\nvar Helpers = function () {\n    function Helpers() {\n        _classCallCheck(this, Helpers);\n    }\n\n    _createClass(Helpers, [{\n        key: 'toPersianDigit',\n\n\n        /**\n         * @description return converted string to persian digit\n         * @param digit\n         * @returns {string|*}\n         */\n        value: function toPersianDigit(digit) {\n            var latinDigit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n            return digit.toString().replace(/\\d+/g, function (digit) {\n                var enDigitArr = [],\n                    peDigitArr = [],\n                    i = void 0,\n                    j = void 0;\n                for (i = 0; i < digit.length; i += 1) {\n                    enDigitArr.push(digit.charCodeAt(i));\n                }\n                for (j = 0; j < enDigitArr.length; j += 1) {\n                    peDigitArr.push(String.fromCharCode(enDigitArr[j] + (!!latinDigit && latinDigit === true ? 1584 : 1728)));\n                }\n                return peDigitArr.join('');\n            });\n        }\n\n        /**\n         * @param number\n         * @param targetLength\n         * @returns {string}\n         */\n\n    }, {\n        key: 'leftZeroFill',\n        value: function leftZeroFill(number, targetLength) {\n            var output = number + '';\n            while (output.length < targetLength) {\n                output = '0' + output;\n            }\n            return output;\n        }\n\n        /**\n         * @description normalize duration params and return valid param\n         * @return {{unit: *, value: *}}\n         */\n\n    }, {\n        key: 'normalizeDuration',\n        value: function normalizeDuration() {\n            var unit = void 0,\n                value = void 0;\n            if (typeof arguments[0] === 'string') {\n                unit = arguments[0];\n                value = arguments[1];\n            } else {\n                value = arguments[0];\n                unit = arguments[1];\n            }\n            if (durationUnit.year.indexOf(unit) > -1) {\n                unit = 'year';\n            } else if (durationUnit.month.indexOf(unit) > -1) {\n                unit = 'month';\n            } else if (durationUnit.week.indexOf(unit) > -1) {\n                unit = 'week';\n            } else if (durationUnit.day.indexOf(unit) > -1) {\n                unit = 'day';\n            } else if (durationUnit.hour.indexOf(unit) > -1) {\n                unit = 'hour';\n            } else if (durationUnit.minute.indexOf(unit) > -1) {\n                unit = 'minute';\n            } else if (durationUnit.second.indexOf(unit) > -1) {\n                unit = 'second';\n            } else if (durationUnit.millisecond.indexOf(unit) > -1) {\n                unit = 'millisecond';\n            }\n            return {\n                unit: unit,\n                value: value\n            };\n        }\n\n        /**\n         *\n         * @param number\n         * @returns {number}\n         */\n\n    }, {\n        key: 'absRound',\n        value: function absRound(number) {\n            if (number < 0) {\n                return Math.ceil(number);\n            } else {\n                return Math.floor(number);\n            }\n        }\n\n        /**\n         *\n         * @param number\n         * @return {number}\n         */\n\n    }, {\n        key: 'absFloor',\n        value: function absFloor(number) {\n            if (number < 0) {\n                // -0 -> 0\n                return Math.ceil(number) || 0;\n            } else {\n                return Math.floor(number);\n            }\n        }\n    }]);\n\n    return Helpers;\n}();\n\nmodule.exports = Helpers;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __nested_webpack_require_7654__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TypeChecking = __nested_webpack_require_7654__(10);\nvar Algorithms = __nested_webpack_require_7654__(2);\nvar Helpers = __nested_webpack_require_7654__(0);\nvar Duration = __nested_webpack_require_7654__(5);\nvar Validator = __nested_webpack_require_7654__(11);\nvar toPersianDigit = new Helpers().toPersianDigit;\nvar leftZeroFill = new Helpers().leftZeroFill;\nvar normalizeDuration = new Helpers().normalizeDuration;\nvar fa = __nested_webpack_require_7654__(7);\nvar en = __nested_webpack_require_7654__(6);\n\n/**\n * @description persian date class\n */\n\nvar PersianDateClass = function () {\n\n    /**\n     * @param input\n     * @return {PersianDateClass}\n     */\n    function PersianDateClass(input) {\n        _classCallCheck(this, PersianDateClass);\n\n        this.calendarType = PersianDateClass.calendarType;\n        this.localType = PersianDateClass.localType;\n        this.leapYearMode = PersianDateClass.leapYearMode;\n\n        this.algorithms = new Algorithms(this);\n        this.version = \"1.1.0\";\n        this._utcMode = false;\n        if (this.localType !== 'fa') {\n            this.formatPersian = false;\n        } else {\n            this.formatPersian = '_default';\n        }\n        this.State = this.algorithms.State;\n        this.setup(input);\n        if (this.State.isInvalidDate) {\n            // Return Date like message\n            return new Date([-1, -1]);\n        }\n        return this;\n    }\n\n    /**\n     * @param input\n     */\n\n\n    _createClass(PersianDateClass, [{\n        key: 'setup',\n        value: function setup(input) {\n            // Convert Any thing to Gregorian Date\n            if (TypeChecking.isDate(input)) {\n                this._gDateToCalculators(input);\n            } else if (TypeChecking.isArray(input)) {\n                if (!Validator.validateInputArray(input)) {\n                    this.State.isInvalidDate = true;\n                    return false;\n                }\n                this.algorithmsCalc([input[0], input[1] ? input[1] : 1, input[2] ? input[2] : 1, input[3] ? input[3] : 0, input[4] ? input[4] : 0, input[5] ? input[5] : 0, input[6] ? input[6] : 0]);\n            } else if (TypeChecking.isNumber(input)) {\n                var fromUnix = new Date(input);\n                this._gDateToCalculators(fromUnix);\n            }\n            // instance of pDate\n            else if (input instanceof PersianDateClass) {\n                    this.algorithmsCalc([input.year(), input.month(), input.date(), input.hour(), input.minute(), input.second(), input.millisecond()]);\n                }\n                // ASP.NET JSON Date\n                else if (input && input.substring(0, 6) === '/Date(') {\n                        var fromDotNet = new Date(parseInt(input.substr(6)));\n                        this._gDateToCalculators(fromDotNet);\n                    } else {\n                        var now = new Date();\n                        this._gDateToCalculators(now);\n                    }\n        }\n\n        /**\n         * @param input\n         * @return {*}\n         * @private\n         */\n\n    }, {\n        key: '_getSyncedClass',\n        value: function _getSyncedClass(input) {\n            var syncedCelander = PersianDateClass.toCalendar(this.calendarType).toLocale(this.localType).toLeapYearMode(this.leapYearMode);\n            return new syncedCelander(input);\n        }\n\n        /**\n         * @param inputgDate\n         * @private\n         */\n\n    }, {\n        key: '_gDateToCalculators',\n        value: function _gDateToCalculators(inputgDate) {\n            this.algorithms.calcGregorian([inputgDate.getFullYear(), inputgDate.getMonth(), inputgDate.getDate(), inputgDate.getHours(), inputgDate.getMinutes(), inputgDate.getSeconds(), inputgDate.getMilliseconds()]);\n        }\n\n        /**\n         * @since 1.0.0\n         * @description Helper method that return date range name like week days name, month names, month days names (specially in persian calendar).\n         * @static\n         * @return {*}\n         */\n\n    }, {\n        key: 'rangeName',\n\n\n        /**\n         * @since 1.0.0\n         * @description Helper method that return date range name like week days name, month names, month days names (specially in persian calendar).\n         * @return {*}\n         */\n        value: function rangeName() {\n            var t = this.calendarType;\n            if (this.localType === 'fa') {\n                if (t === 'persian') {\n                    return fa.persian;\n                } else {\n                    return fa.gregorian;\n                }\n            } else {\n                if (t === 'persian') {\n                    return en.persian;\n                } else {\n                    return en.gregorian;\n                }\n            }\n        }\n\n        /**\n         * @since 1.0.0\n         * @param input\n         * @return {PersianDateClass}\n         */\n\n    }, {\n        key: 'toLeapYearMode',\n        value: function toLeapYearMode(input) {\n            this.leapYearMode = input;\n            if (input === 'astronomical' && this.calendarType == 'persian') {\n                this.leapYearMode = 'astronomical';\n            } else if (input === 'algorithmic' && this.calendarType == 'persian') {\n                this.leapYearMode = 'algorithmic';\n            }\n            this.algorithms.updateFromGregorian();\n            return this;\n        }\n\n        /**\n         * @since 1.0.0\n         * @static\n         * @param input\n         * @return {PersianDateClass}\n         */\n\n    }, {\n        key: 'toCalendar',\n\n\n        /**\n         * @since 1.0.0\n         * @param input\n         * @return {PersianDateClass}\n         */\n        value: function toCalendar(input) {\n            this.calendarType = input;\n            this.algorithms.updateFromGregorian();\n            return this;\n        }\n\n        /**\n         * @since 1.0.0\n         * @static\n         * @param input\n         * @return {PersianDateClass}\n         */\n\n    }, {\n        key: 'toLocale',\n\n\n        /**\n         * @since 1.0.0\n         * @param input\n         * @return {PersianDateClass}\n         */\n        value: function toLocale(input) {\n            this.localType = input;\n            if (this.localType !== 'fa') {\n                this.formatPersian = false;\n            } else {\n                this.formatPersian = '_default';\n            }\n            return this;\n        }\n\n        /**\n         * @return {*}\n         * @private\n         */\n\n    }, {\n        key: '_locale',\n        value: function _locale() {\n            var t = this.calendarType;\n            if (this.localType === 'fa') {\n                if (t === 'persian') {\n                    return fa.persian;\n                } else {\n                    return fa.gregorian;\n                }\n            } else {\n                if (t === 'persian') {\n                    return en.persian;\n                } else {\n                    return en.gregorian;\n                }\n            }\n        }\n\n        /**\n         * @param input\n         * @private\n         */\n\n    }, {\n        key: '_weekName',\n        value: function _weekName(input) {\n            return this._locale().weekdays[input - 1];\n        }\n\n        /**\n         * @param input\n         * @private\n         */\n\n    }, {\n        key: '_weekNameShort',\n        value: function _weekNameShort(input) {\n            return this._locale().weekdaysShort[input - 1];\n        }\n\n        /**\n         * @param input\n         * @private\n         */\n\n    }, {\n        key: '_weekNameMin',\n        value: function _weekNameMin(input) {\n            return this._locale().weekdaysMin[input - 1];\n        }\n\n        /**\n         * @param input\n         * @return {*}\n         * @private\n         */\n\n    }, {\n        key: '_dayName',\n        value: function _dayName(input) {\n            return this._locale().persianDaysName[input - 1];\n        }\n\n        /**\n         * @param input\n         * @private\n         */\n\n    }, {\n        key: '_monthName',\n        value: function _monthName(input) {\n            return this._locale().months[input - 1];\n        }\n\n        /**\n         * @param input\n         * @private\n         */\n\n    }, {\n        key: '_monthNameShort',\n        value: function _monthNameShort(input) {\n            return this._locale().monthsShort[input - 1];\n        }\n\n        /**\n         * @param obj\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isPersianDate',\n\n\n        /**\n         * @param obj\n         * @return {boolean}\n         */\n        value: function isPersianDate(obj) {\n            return obj instanceof PersianDateClass;\n        }\n\n        /**\n         * @returns {PersianDate}\n         */\n\n    }, {\n        key: 'clone',\n        value: function clone() {\n            return this._getSyncedClass(this.State.gDate);\n        }\n\n        /**\n         * @since 1.0.0\n         * @param dateArray\n         * @return {*}\n         */\n\n    }, {\n        key: 'algorithmsCalc',\n        value: function algorithmsCalc(dateArray) {\n            if (this.isPersianDate(dateArray)) {\n                dateArray = [dateArray.year(), dateArray.month(), dateArray.date(), dateArray.hour(), dateArray.minute(), dateArray.second(), dateArray.millisecond()];\n            }\n            if (this.calendarType === 'persian' && this.leapYearMode == 'algorithmic') {\n                return this.algorithms.calcPersian(dateArray);\n            } else if (this.calendarType === 'persian' && this.leapYearMode == 'astronomical') {\n                return this.algorithms.calcPersiana(dateArray);\n            } else if (this.calendarType === 'gregorian') {\n                dateArray[1] = dateArray[1] - 1;\n                return this.algorithms.calcGregorian(dateArray);\n            }\n        }\n\n        /**\n         * @since 1.0.0\n         * @return {*}\n         */\n\n    }, {\n        key: 'calendar',\n        value: function calendar() {\n            var key = void 0;\n            if (this.calendarType == 'persian') {\n                if (this.leapYearMode == 'astronomical') {\n                    key = 'persianAstro';\n                } else if (this.leapYearMode == 'algorithmic') {\n                    key = 'persianAlgo';\n                }\n            } else {\n                key = 'gregorian';\n            }\n            return this.State[key];\n        }\n\n        /**\n         * @description return Duration object\n         * @param input\n         * @param key\n         * @returns {Duration}\n         */\n\n    }, {\n        key: 'duration',\n\n\n        /**\n         * @description return Duration object\n         * @param input\n         * @param key\n         * @returns {Duration}\n         */\n        value: function duration(input, key) {\n            return new Duration(input, key);\n        }\n\n        /**\n         * @description check if passed object is duration\n         * @param obj\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isDuration',\n\n\n        /**\n         * @description check if passed object is duration\n         * @param obj\n         * @returns {boolean}\n         */\n        value: function isDuration(obj) {\n            return obj instanceof Duration;\n        }\n\n        /**\n         * @param input\n         * @returns {*}\n         */\n\n    }, {\n        key: 'years',\n        value: function years(input) {\n            return this.year(input);\n        }\n\n        /**\n         * @param input\n         * @returns {*}\n         */\n\n    }, {\n        key: 'year',\n        value: function year(input) {\n            if (input || input === 0) {\n                this.algorithmsCalc([input, this.month(), this.date(), this.hour(), this.minute(), this.second(), this.millisecond()]);\n                return this;\n            } else {\n                return this.calendar().year;\n            }\n        }\n\n        /**\n         * @param input\n         * @returns {*}\n         */\n\n    }, {\n        key: 'month',\n        value: function month(input) {\n            if (input || input === 0) {\n                this.algorithmsCalc([this.year(), input, this.date()]);\n                return this;\n            } else {\n                return this.calendar().month + 1;\n            }\n        }\n\n        /**\n         * Day of week\n         * @returns {Function|Date.toJSON.day|date_json.day|PersianDate.day|day|output.day|*}\n         */\n\n    }, {\n        key: 'days',\n        value: function days() {\n            return this.day();\n        }\n\n        /**\n         * @returns {Function|Date.toJSON.day|date_json.day|PersianDate.day|day|output.day|*}\n         */\n\n    }, {\n        key: 'day',\n        value: function day() {\n            return this.calendar().weekday;\n        }\n\n        /**\n         * Day of Months\n         * @param input\n         * @returns {*}\n         */\n\n    }, {\n        key: 'dates',\n        value: function dates(input) {\n            return this.date(input);\n        }\n\n        /**\n         * @param input\n         * @returns {*}\n         */\n\n    }, {\n        key: 'date',\n        value: function date(input) {\n            if (input || input === 0) {\n                this.algorithmsCalc([this.year(), this.month(), input]);\n                return this;\n            } else {\n                return this.calendar().day;\n            }\n        }\n\n        /**\n         * @param input\n         * @returns {*}\n         */\n\n    }, {\n        key: 'hour',\n        value: function hour(input) {\n            return this.hours(input);\n        }\n\n        /**\n         * @param input\n         * @returns {*}\n         */\n\n    }, {\n        key: 'hours',\n        value: function hours(input) {\n            if (input || input === 0) {\n                if (input === 0) {\n                    input = 24;\n                }\n                this.algorithmsCalc([this.year(), this.month(), this.date(), input]);\n                return this;\n            } else {\n                return this.State.gDate.getHours();\n            }\n        }\n\n        /**\n         * @param input\n         * @returns {*}\n         */\n\n    }, {\n        key: 'minute',\n        value: function minute(input) {\n            return this.minutes(input);\n        }\n\n        /**\n         * @param input\n         * @returns {*}\n         */\n\n    }, {\n        key: 'minutes',\n        value: function minutes(input) {\n            if (input || input === 0) {\n                this.algorithmsCalc([this.year(), this.month(), this.date(), this.hour(), input]);\n                return this;\n            } else {\n                return this.State.gDate.getMinutes();\n            }\n        }\n\n        /**\n         * @param input\n         * @returns {*}\n         */\n\n    }, {\n        key: 'second',\n        value: function second(input) {\n            return this.seconds(input);\n        }\n\n        /**\n         * @param input\n         * @returns {*}\n         */\n\n    }, {\n        key: 'seconds',\n        value: function seconds(input) {\n            if (input || input === 0) {\n                this.algorithmsCalc([this.year(), this.month(), this.date(), this.hour(), this.minute(), input]);\n                return this;\n            } else {\n                return this.State.gDate.getSeconds();\n            }\n        }\n\n        /**\n         * @param input\n         * @returns {*}\n         * Getter Setter\n         */\n\n    }, {\n        key: 'millisecond',\n        value: function millisecond(input) {\n            return this.milliseconds(input);\n        }\n\n        /**\n         * @param input\n         * @returns {*}\n         */\n\n    }, {\n        key: 'milliseconds',\n        value: function milliseconds(input) {\n            if (input || input === 0) {\n                this.algorithmsCalc([this.year(), this.month(), this.date(), this.hour(), this.minute(), this.second(), input]);\n                return this;\n            } else {\n                return this.State.gregorian.millisecond;\n            }\n        }\n\n        /**\n         * Return Milliseconds since the Unix Epoch (1318874398806)\n         * @returns {*}\n         * @private\n         */\n        //    _valueOf () {\n        //        return this.State.gDate.valueOf();\n        //    }\n\n\n    }, {\n        key: 'unix',\n\n\n        /**\n         * Return Unix Timestamp (1318874398)\n         * @param timestamp\n         * @returns {*}\n         */\n        value: function unix(timestamp) {\n            var output = void 0;\n            if (timestamp) {\n                return this._getSyncedClass(timestamp * 1000);\n            } else {\n                var str = this.State.gDate.valueOf().toString();\n                output = str.substring(0, str.length - 3);\n            }\n            return parseInt(output);\n        }\n\n        /**\n         * @returns {*}\n         */\n\n    }, {\n        key: 'valueOf',\n        value: function valueOf() {\n            return this.State.gDate.valueOf();\n        }\n\n        /**\n         * @param year\n         * @param month\n         * @returns {*}\n         * @since 1.0.0\n         */\n\n    }, {\n        key: 'getFirstWeekDayOfMonth',\n\n\n        /**\n         * @param year\n         * @param month\n         * @returns {*}\n         * @since 1.0.0\n         */\n        value: function getFirstWeekDayOfMonth(year, month) {\n            return this._getSyncedClass([year, month, 1]).day();\n        }\n\n        /**\n         * @param input\n         * @param val\n         * @param asFloat\n         * @returns {*}\n         */\n\n    }, {\n        key: 'diff',\n        value: function diff(input, val, asFloat) {\n            var self = this,\n                inputMoment = input,\n                zoneDiff = 0,\n                diff = self.State.gDate - inputMoment.toDate() - zoneDiff,\n                year = self.year() - inputMoment.year(),\n                month = self.month() - inputMoment.month(),\n                date = (self.date() - inputMoment.date()) * -1,\n                output = void 0;\n\n            if (val === 'months' || val === 'month') {\n                output = year * 12 + month + date / 30;\n            } else if (val === 'years' || val === 'year') {\n                output = year + (month + date / 30) / 12;\n            } else {\n                output = val === 'seconds' || val === 'second' ? diff / 1e3 : // 1000\n                val === 'minutes' || val === 'minute' ? diff / 6e4 : // 1000 * 60\n                val === 'hours' || val === 'hour' ? diff / 36e5 : // 1000 * 60 * 60\n                val === 'days' || val === 'day' ? diff / 864e5 : // 1000 * 60 * 60 * 24\n                val === 'weeks' || val === 'week' ? diff / 6048e5 : // 1000 * 60 * 60 * 24 * 7\n                diff;\n            }\n            return asFloat ? output : Math.round(output);\n        }\n\n        /**\n         * @param key\n         * @returns {*}\n         */\n\n    }, {\n        key: 'startOf',\n        value: function startOf(key) {\n            var syncedCelander = PersianDateClass.toCalendar(this.calendarType).toLocale(this.localType);\n            var newArray = new PersianDateClass(this.valueOf() - (this.calendar().weekday - 1) * 86400000).toArray();\n            // Simplify this\\\n            /* jshint ignore:start */\n            switch (key) {\n                case 'years':\n                case 'year':\n                    return new syncedCelander([this.year(), 1, 1]);\n                case 'months':\n                case 'month':\n                    return new syncedCelander([this.year(), this.month(), 1]);\n                case 'days':\n                case 'day':\n                    return new syncedCelander([this.year(), this.month(), this.date(), 0, 0, 0]);\n                case 'hours':\n                case 'hour':\n                    return new syncedCelander([this.year(), this.month(), this.date(), this.hours(), 0, 0]);\n                case 'minutes':\n                case 'minute':\n                    return new syncedCelander([this.year(), this.month(), this.date(), this.hours(), this.minutes(), 0]);\n                case 'seconds':\n                case 'second':\n                    return new syncedCelander([this.year(), this.month(), this.date(), this.hours(), this.minutes(), this.seconds()]);\n                case 'weeks':\n                case 'week':\n                    return new syncedCelander(newArray);\n                default:\n                    return this.clone();\n            }\n            /* jshint ignore:end */\n        }\n\n        /**\n         * @param key\n         * @returns {*}\n         */\n        /* eslint-disable no-case-declarations */\n\n    }, {\n        key: 'endOf',\n        value: function endOf(key) {\n            var syncedCelander = PersianDateClass.toCalendar(this.calendarType).toLocale(this.localType);\n            // Simplify this\n            switch (key) {\n                case 'years':\n                case 'year':\n                    var days = this.isLeapYear() ? 30 : 29;\n                    return new syncedCelander([this.year(), 12, days, 23, 59, 59]);\n                case 'months':\n                case 'month':\n                    var monthDays = this.daysInMonth(this.year(), this.month());\n                    return new syncedCelander([this.year(), this.month(), monthDays, 23, 59, 59]);\n                case 'days':\n                case 'day':\n                    return new syncedCelander([this.year(), this.month(), this.date(), 23, 59, 59]);\n                case 'hours':\n                case 'hour':\n                    return new syncedCelander([this.year(), this.month(), this.date(), this.hours(), 59, 59]);\n                case 'minutes':\n                case 'minute':\n                    return new syncedCelander([this.year(), this.month(), this.date(), this.hours(), this.minutes(), 59]);\n                case 'seconds':\n                case 'second':\n                    return new syncedCelander([this.year(), this.month(), this.date(), this.hours(), this.minutes(), this.seconds()]);\n                case 'weeks':\n                case 'week':\n                    var weekDayNumber = this.calendar().weekday;\n                    return new syncedCelander([this.year(), this.month(), this.date() + (7 - weekDayNumber)]);\n                default:\n                    return this.clone();\n            }\n            /* eslint-enable no-case-declarations */\n        }\n\n        /**\n         * @returns {*}\n         */\n\n    }, {\n        key: 'sod',\n        value: function sod() {\n            return this.startOf('day');\n        }\n\n        /**\n         * @returns {*}\n         */\n\n    }, {\n        key: 'eod',\n        value: function eod() {\n            return this.endOf('day');\n        }\n\n        /** Get the timezone offset in minutes.\n         * @return {*}\n         */\n\n    }, {\n        key: 'zone',\n        value: function zone(input) {\n            if (input || input === 0) {\n                this.State.zone = input;\n                return this;\n            } else {\n                return this.State.zone;\n            }\n        }\n\n        /**\n         * @returns {PersianDate}\n         */\n\n    }, {\n        key: 'local',\n        value: function local() {\n            var utcStamp = void 0;\n            if (this._utcMode) {\n                var ThatDayOffset = new Date(this.toDate()).getTimezoneOffset();\n                var offsetMils = ThatDayOffset * 60 * 1000;\n                if (ThatDayOffset < 0) {\n                    utcStamp = this.valueOf() - offsetMils;\n                } else {\n                    /* istanbul ignore next */\n                    utcStamp = this.valueOf() + offsetMils;\n                }\n                this.toCalendar(PersianDateClass.calendarType);\n                var utcDate = new Date(utcStamp);\n                this._gDateToCalculators(utcDate);\n                this._utcMode = false;\n                this.zone(ThatDayOffset);\n                return this;\n            } else {\n                return this;\n            }\n        }\n\n        /**\n         * @param input\n         * @return {*}\n         */\n\n    }, {\n        key: 'utc',\n\n\n        /**\n         * @description Current date/time in UTC mode\n         * @param input\n         * @returns {*}\n         */\n        value: function utc(input) {\n            var utcStamp = void 0;\n            if (input) {\n                return this._getSyncedClass(input).utc();\n            }\n            if (this._utcMode) {\n                return this;\n            } else {\n                var offsetMils = this.zone() * 60 * 1000;\n                if (this.zone() < 0) {\n                    utcStamp = this.valueOf() + offsetMils;\n                } else {\n                    /* istanbul ignore next */\n                    utcStamp = this.valueOf() - offsetMils;\n                }\n                var utcDate = new Date(utcStamp),\n                    d = this._getSyncedClass(utcDate);\n                this.algorithmsCalc(d);\n                this._utcMode = true;\n                this.zone(0);\n                return this;\n            }\n        }\n\n        /**\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isUtc',\n        value: function isUtc() {\n            return this._utcMode;\n        }\n\n        /**\n         * @returns {boolean}\n         * @link https://fa.wikipedia.org/wiki/%D8%B3%D8%A7%D8%B9%D8%AA_%D8%AA%D8%A7%D8%A8%D8%B3%D8%AA%D8%A7%D9%86%DB%8C\n         */\n\n    }, {\n        key: 'isDST',\n        value: function isDST() {\n            var month = this.month(),\n                day = this.date();\n            if (month == 1 && day > 1 || month == 6 && day < 31 || month < 6 && month >= 2) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        /**\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isLeapYear',\n        value: function isLeapYear(year) {\n            if (year === undefined) {\n                year = this.year();\n            }\n            if (this.calendarType == 'persian' && this.leapYearMode === 'algorithmic') {\n                return this.algorithms.leap_persian(year);\n            }\n            if (this.calendarType == 'persian' && this.leapYearMode === 'astronomical') {\n                return this.algorithms.leap_persiana(year);\n            } else if (this.calendarType == 'gregorian') {\n                return this.algorithms.leap_gregorian(year);\n            }\n        }\n\n        /**\n         * @param yearInput\n         * @param monthInput\n         * @returns {number}\n         */\n\n    }, {\n        key: 'daysInMonth',\n        value: function daysInMonth(yearInput, monthInput) {\n            var year = yearInput ? yearInput : this.year(),\n                month = monthInput ? monthInput : this.month();\n            if (this.calendarType === 'persian') {\n                if (month < 1 || month > 12) return 0;\n                if (month < 7) return 31;\n                if (month < 12) return 30;\n                if (this.isLeapYear(year)) {\n                    return 30;\n                }\n                return 29;\n            }\n            if (this.calendarType === 'gregorian') {\n                return new Date(year, month, 0).getDate();\n            }\n        }\n\n        /**\n         * @description Return Native Javascript Date\n         * @returns {*|PersianDate.gDate}\n         */\n\n    }, {\n        key: 'toDate',\n        value: function toDate() {\n            return this.State.gDate;\n        }\n\n        /**\n         * @description Returns Array Of Persian Date\n         * @returns {array}\n         */\n\n    }, {\n        key: 'toArray',\n        value: function toArray() {\n            return [this.year(), this.month(), this.date(), this.hour(), this.minute(), this.second(), this.millisecond()];\n        }\n\n        /**\n         * @returns {*}\n         */\n\n    }, {\n        key: 'formatNumber',\n        value: function formatNumber() {\n            var output = void 0,\n                self = this;\n\n            // if default conf dosent set follow golbal config\n            if (this.formatPersian === '_default') {\n                if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n                    /* istanbul ignore next */\n                    if (self.formatPersian === false) {\n                        output = false;\n                    } else {\n                        // Default Conf\n                        output = true;\n                    }\n                }\n                /* istanbul ignore next */\n                else {\n                        if (window.formatPersian === false) {\n                            output = false;\n                        } else {\n                            // Default Conf\n                            output = true;\n                        }\n                    }\n            } else {\n                if (this.formatPersian === true) {\n                    output = true;\n                } else if (this.formatPersian === false) {\n                    output = false;\n                } else {\n                    Error('Invalid Config \"formatPersian\" !!');\n                }\n            }\n            return output;\n        }\n\n        /**\n         * @param inputString\n         * @returns {*}\n         */\n\n    }, {\n        key: 'format',\n        value: function format(inputString) {\n            if (this.State.isInvalidDate) {\n                return false;\n            }\n            var self = this,\n                formattingTokens = /([[^[]*])|(\\\\)?(Mo|MM?M?M?|Do|DD?D?D?|dddddd?|ddddd?|dddd?|do?|w[o|w]?|YYYY|YY|a|A|hh?|HH?|mm?|ss?|SS?S?|zz?|ZZ?|X|LT|ll?l?l?|LL?L?L?)/g,\n                info = {\n                year: self.year(),\n                month: self.month(),\n                hour: self.hours(),\n                minute: self.minutes(),\n                second: self.seconds(),\n                date: self.date(),\n                timezone: self.zone(),\n                unix: self.unix()\n            },\n                formatToPersian = self.formatNumber();\n\n            var checkPersian = function checkPersian(i) {\n                if (formatToPersian) {\n                    return toPersianDigit(i);\n                } else {\n                    return i;\n                }\n            };\n\n            /* jshint ignore:start */\n            function replaceFunction(input) {\n                switch (input) {\n                    // AM/PM\n                    case 'a':\n                        {\n                            if (formatToPersian) return info.hour >= 12 ? 'ب ظ' : 'ق ظ';else return info.hour >= 12 ? 'PM' : 'AM';\n                        }\n                    // Hours (Int)\n                    case 'H':\n                        {\n                            return checkPersian(info.hour);\n                        }\n                    case 'HH':\n                        {\n                            return checkPersian(leftZeroFill(info.hour, 2));\n                        }\n                    case 'h':\n                        {\n                            return checkPersian(info.hour % 12);\n                        }\n                    case 'hh':\n                        {\n                            return checkPersian(leftZeroFill(info.hour % 12, 2));\n                        }\n                    // Minutes\n                    case 'm':\n                        {\n                            return checkPersian(leftZeroFill(info.minute, 2));\n                        }\n                    // Two Digit Minutes\n                    case 'mm':\n                        {\n                            return checkPersian(leftZeroFill(info.minute, 2));\n                        }\n                    // Second\n                    case 's':\n                        {\n                            return checkPersian(info.second);\n                        }\n                    case 'ss':\n                        {\n                            return checkPersian(leftZeroFill(info.second, 2));\n                        }\n                    // Day (Int)\n                    case 'D':\n                        {\n                            return checkPersian(leftZeroFill(info.date));\n                        }\n                    // Return Two Digit\n                    case 'DD':\n                        {\n                            return checkPersian(leftZeroFill(info.date, 2));\n                        }\n                    // Return day Of Month\n                    case 'DDD':\n                        {\n                            var t = self.startOf('year');\n                            return checkPersian(leftZeroFill(self.diff(t, 'days'), 3));\n                        }\n                    // Return Day of Year\n                    case 'DDDD':\n                        {\n                            var _t = self.startOf('year');\n                            return checkPersian(leftZeroFill(self.diff(_t, 'days'), 3));\n                        }\n                    // Return day Of week\n                    case 'd':\n                        {\n                            return checkPersian(self.calendar().weekday);\n                        }\n                    // Return week day name abbr\n                    case 'ddd':\n                        {\n                            return self._weekNameShort(self.calendar().weekday);\n                        }\n                    case 'dddd':\n                        {\n                            return self._weekName(self.calendar().weekday);\n                        }\n                    // Return Persian Day Name\n                    case 'ddddd':\n                        {\n                            return self._dayName(self.calendar().day);\n                        }\n                    // Return Persian Day Name\n                    case 'dddddd':\n                        {\n                            return self._weekNameMin(self.calendar().weekday);\n                        }\n                    // Return Persian Day Name\n                    case 'w':\n                        {\n                            var _t2 = self.startOf('year'),\n                                day = parseInt(self.diff(_t2, 'days') / 7) + 1;\n                            return checkPersian(day);\n                        }\n                    // Return Persian Day Name\n                    case 'ww':\n                        {\n                            var _t3 = self.startOf('year'),\n                                _day = leftZeroFill(parseInt(self.diff(_t3, 'days') / 7) + 1, 2);\n                            return checkPersian(_day);\n                        }\n                    // Month  (Int)\n                    case 'M':\n                        {\n                            return checkPersian(info.month);\n                        }\n                    // Two Digit Month (Str)\n                    case 'MM':\n                        {\n                            return checkPersian(leftZeroFill(info.month, 2));\n                        }\n                    // Abbr String of Month (Str)\n                    case 'MMM':\n                        {\n                            return self._monthNameShort(info.month);\n                        }\n                    // Full String name of Month (Str)\n                    case 'MMMM':\n                        {\n                            return self._monthName(info.month);\n                        }\n                    // Year\n                    // Two Digit Year (Str)\n                    case 'YY':\n                        {\n                            var yearDigitArray = info.year.toString().split('');\n                            return checkPersian(yearDigitArray[2] + yearDigitArray[3]);\n                        }\n                    // Full Year (Int)\n                    case 'YYYY':\n                        {\n                            return checkPersian(info.year);\n                        }\n                    /* istanbul ignore next */\n                    case 'Z':\n                        {\n                            var flag = '+',\n                                hours = Math.round(info.timezone / 60),\n                                minutes = info.timezone % 60;\n\n                            if (minutes < 0) {\n                                minutes *= -1;\n                            }\n                            if (hours < 0) {\n                                flag = '-';\n                                hours *= -1;\n                            }\n\n                            var z = flag + leftZeroFill(hours, 2) + ':' + leftZeroFill(minutes, 2);\n                            return checkPersian(z);\n                        }\n                    /* istanbul ignore next */\n                    case 'ZZ':\n                        {\n                            var _flag = '+',\n                                _hours = Math.round(info.timezone / 60),\n                                _minutes = info.timezone % 60;\n\n                            if (_minutes < 0) {\n                                _minutes *= -1;\n                            }\n                            if (_hours < 0) {\n                                _flag = '-';\n                                _hours *= -1;\n                            }\n                            var _z = _flag + leftZeroFill(_hours, 2) + '' + leftZeroFill(_minutes, 2);\n                            return checkPersian(_z);\n                        }\n                    /* istanbul ignore next */\n                    case 'X':\n                        {\n                            return self.unix();\n                        }\n                    // 8:30 PM\n                    case 'LT':\n                        {\n                            return self.format('H:m a');\n                        }\n                    // 09/04/1986\n                    case 'L':\n                        {\n                            return self.format('YYYY/MM/DD');\n                        }\n                    // 9/4/1986\n                    case 'l':\n                        {\n                            return self.format('YYYY/M/D');\n                        }\n                    // September 4th 1986\n                    case 'LL':\n                        {\n                            return self.format('MMMM DD YYYY');\n                        }\n                    // Sep 4 1986\n                    case 'll':\n                        {\n                            return self.format('MMM DD YYYY');\n                        }\n                    //September 4th 1986 8:30 PM\n                    case 'LLL':\n                        {\n                            return self.format('MMMM YYYY DD   H:m  a');\n                        }\n                    // Sep 4 1986 8:30 PM\n                    case 'lll':\n                        {\n                            return self.format('MMM YYYY DD   H:m  a');\n                        }\n                    //Thursday, September 4th 1986 8:30 PM\n                    case 'LLLL':\n                        {\n                            return self.format('dddd D MMMM YYYY  H:m  a');\n                        }\n                    // Thu, Sep 4 1986 8:30 PM\n                    case 'llll':\n                        {\n                            return self.format('ddd D MMM YYYY  H:m  a');\n                        }\n                }\n            }\n\n            /* jshint ignore:end */\n\n            if (inputString) {\n                return inputString.replace(formattingTokens, replaceFunction);\n            } else {\n                var _inputString = 'YYYY-MM-DD HH:mm:ss a';\n                return _inputString.replace(formattingTokens, replaceFunction);\n            }\n        }\n\n        /**\n         * @param key\n         * @param value\n         * @returns {PersianDate}\n         */\n\n    }, {\n        key: 'add',\n        value: function add(key, value) {\n            if (value === 0) {\n                return this;\n            }\n            var unit = normalizeDuration(key, value).unit,\n                arr = this.toArray();\n            value = normalizeDuration(key, value).value;\n            if (unit === 'year') {\n                var normalizedDate = arr[2],\n                    monthDays = this.daysInMonth(arr[0] + value, arr[1]);\n                if (arr[2] > monthDays) {\n                    normalizedDate = monthDays;\n                }\n                var tempDate = new PersianDateClass([arr[0] + value, arr[1], normalizedDate, arr[3], arr[4], arr[5], arr[6], arr[7]]);\n                return tempDate;\n            }\n            if (unit === 'month') {\n                var tempYear = Math.floor(value / 12);\n                var remainingMonth = value - tempYear * 12,\n                    calcedMonth = null;\n                if (arr[1] + remainingMonth > 12) {\n                    tempYear += 1;\n                    calcedMonth = arr[1] + remainingMonth - 12;\n                } else {\n                    calcedMonth = arr[1] + remainingMonth;\n                }\n                var normalizaedDate = arr[2],\n                    tempDateArray = new PersianDateClass([arr[0] + tempYear, calcedMonth, 1, arr[3], arr[4], arr[5], arr[6], arr[7]]).toArray(),\n                    _monthDays = this.daysInMonth(arr[0] + tempYear, calcedMonth);\n                if (arr[2] > _monthDays) {\n                    normalizaedDate = _monthDays;\n                }\n                return new PersianDateClass([tempDateArray[0], tempDateArray[1], normalizaedDate, tempDateArray[3], tempDateArray[4], tempDateArray[5], tempDateArray[6], tempDateArray[7]]);\n            }\n            if (unit === 'day') {\n                var calcedDay = new PersianDateClass(this.valueOf()).hour(12),\n                    newMillisecond = calcedDay.valueOf() + value * 86400000,\n                    newDate = new PersianDateClass(newMillisecond);\n                return newDate.hour(arr[3]);\n            }\n            if (unit === 'week') {\n                var _calcedDay = new PersianDateClass(this.valueOf()).hour(12),\n                    _newMillisecond = _calcedDay.valueOf() + 7 * value * 86400000,\n                    _newDate = new PersianDateClass(_newMillisecond);\n                return _newDate.hour(arr[3]);\n            }\n            if (unit === 'hour') {\n                var _newMillisecond2 = this.valueOf() + value * 3600000;\n                return this.unix(_newMillisecond2 / 1000);\n            }\n            if (unit === 'minute') {\n                var _newMillisecond3 = this.valueOf() + value * 60000;\n                return this.unix(_newMillisecond3 / 1000);\n            }\n            if (unit === 'second') {\n                var _newMillisecond4 = this.valueOf() + value * 1000;\n                return this.unix(_newMillisecond4 / 1000);\n            }\n            if (unit === 'millisecond') {\n                var _newMillisecond5 = this.valueOf() + value;\n                return this.unix(_newMillisecond5 / 1000);\n            }\n            return this._getSyncedClass(this.valueOf());\n        }\n\n        /**\n         * @param key\n         * @param value\n         * @returns {PersianDate}\n         */\n\n    }, {\n        key: 'subtract',\n        value: function subtract(key, value) {\n            return this.add(key, value * -1);\n        }\n\n        /**\n         * check if a date is same as b\n         * @param dateA\n         * @param dateB\n         * @since 1.0.0\n         * @return {boolean}\n         * @static\n         */\n\n    }, {\n        key: 'isSameDay',\n\n\n        /**\n         * @param dateB\n         * @since 1.0.0\n         * @return {PersianDateClass|*|boolean}\n         */\n        value: function isSameDay(dateB) {\n            return this && dateB && this.date() == dateB.date() && this.year() == dateB.year() && this.month() == dateB.month();\n        }\n\n        /**\n         * @desc check if a month is same as b\n         * @param {Date} dateA\n         * @param {Date} dateB\n         * @return {boolean}\n         * @since 1.0.0\n         * @static\n         */\n\n    }, {\n        key: 'isSameMonth',\n\n\n        /**\n         * @desc check two for month similarity\n         * @param dateA\n         * @param dateB\n         * @since 1.0.0\n         * @return {*|boolean}\n         */\n        value: function isSameMonth(dateB) {\n            return this && dateB && this.year() == this.year() && this.month() == dateB.month();\n        }\n    }], [{\n        key: 'rangeName',\n        value: function rangeName() {\n            var p = PersianDateClass,\n                t = p.calendarType;\n            if (p.localType === 'fa') {\n                if (t === 'persian') {\n                    return fa.persian;\n                } else {\n                    return fa.gregorian;\n                }\n            } else {\n                if (t === 'persian') {\n                    return en.persian;\n                } else {\n                    return en.gregorian;\n                }\n            }\n        }\n    }, {\n        key: 'toLeapYearMode',\n        value: function toLeapYearMode(input) {\n            var d = PersianDateClass;\n            d.leapYearMode = input;\n            return d;\n        }\n    }, {\n        key: 'toCalendar',\n        value: function toCalendar(input) {\n            var d = PersianDateClass;\n            d.calendarType = input;\n            return d;\n        }\n\n        /**\n         * @since 1.0.0\n         * @static\n         * @param input\n         * @return {PersianDateClass}\n         */\n\n    }, {\n        key: 'toLocale',\n        value: function toLocale(input) {\n            var d = PersianDateClass;\n            d.localType = input;\n            if (d.localType !== 'fa') {\n                d.formatPersian = false;\n            } else {\n                d.formatPersian = '_default';\n            }\n            return d;\n        }\n    }, {\n        key: 'isPersianDate',\n        value: function isPersianDate(obj) {\n            return obj instanceof PersianDateClass;\n        }\n    }, {\n        key: 'duration',\n        value: function duration(input, key) {\n            return new Duration(input, key);\n        }\n    }, {\n        key: 'isDuration',\n        value: function isDuration(obj) {\n            return obj instanceof Duration;\n        }\n    }, {\n        key: 'unix',\n        value: function unix(timestamp) {\n            if (timestamp) {\n                return new PersianDateClass(timestamp * 1000);\n            } else {\n                return new PersianDateClass().unix();\n            }\n        }\n    }, {\n        key: 'getFirstWeekDayOfMonth',\n        value: function getFirstWeekDayOfMonth(year, month) {\n            return new PersianDateClass([year, month, 1]).day();\n        }\n    }, {\n        key: 'utc',\n        value: function utc(input) {\n            if (input) {\n                return new PersianDateClass(input).utc();\n            } else {\n                return new PersianDateClass().utc();\n            }\n        }\n    }, {\n        key: 'isSameDay',\n        value: function isSameDay(dateA, dateB) {\n            return dateA && dateB && dateA.date() == dateB.date() && dateA.year() == dateB.year() && dateA.month() == dateB.month();\n        }\n    }, {\n        key: 'isSameMonth',\n        value: function isSameMonth(dateA, dateB) {\n            return dateA && dateB && dateA.year() == dateB.year() && dateA.month() == dateB.month();\n        }\n    }]);\n\n    return PersianDateClass;\n}();\n\n/**\n * @type {PersianDateClass}\n */\n\n\nmodule.exports = PersianDateClass;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __nested_webpack_require_55436__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Start algorithm class\nvar ASTRO = __nested_webpack_require_55436__(3);\nvar State = __nested_webpack_require_55436__(9);\n\nvar Algorithms = function () {\n    function Algorithms(parent) {\n        _classCallCheck(this, Algorithms);\n\n        this.parent = parent;\n        this.ASTRO = new ASTRO();\n        this.State = new State();\n        /*  You may notice that a variety of array variables logically local\n         to functions are declared globally here.  In JavaScript, construction\n         of an array variable from source code occurs as the code is\n         interpreted.  Making these variables pseudo-globals permits us\n         to avoid overhead constructing and disposing of them in each\n         call on the function in which whey are used.  */\n        // TODO this block didnt used in main agorithm\n        this.J0000 = 1721424.5; // Julian date of Gregorian epoch: 0000-01-01\n        this.J1970 = 2440587.5; // Julian date at Unix epoch: 1970-01-01\n        this.JMJD = 2400000.5; // Epoch of Modified Julian Date system\n        this.NormLeap = [false /*\"Normal year\"*/, true /*\"Leap year\"*/];\n        // TODO END\n        this.GREGORIAN_EPOCH = 1721425.5;\n        this.PERSIAN_EPOCH = 1948320.5;\n    }\n\n    /**\n     * @desc LEAP_GREGORIAN  --  Is a given year in the Gregorian calendar a leap year ?\n     * @param year\n     * @return {boolean}\n     */\n\n\n    _createClass(Algorithms, [{\n        key: 'leap_gregorian',\n        value: function leap_gregorian(year) {\n            return year % 4 === 0 && !(year % 100 === 0 && year % 400 !== 0);\n        }\n\n        /**\n         * @desc Determine Julian day number from Gregorian calendar date\n         * @param {*} year\n         * @param {*} month\n         * @param {*} day\n         */\n\n    }, {\n        key: 'gregorian_to_jd',\n        value: function gregorian_to_jd(year, month, day) {\n            return this.GREGORIAN_EPOCH - 1 + 365 * (year - 1) + Math.floor((year - 1) / 4) + -Math.floor((year - 1) / 100) + Math.floor((year - 1) / 400) + Math.floor((367 * month - 362) / 12 + (month <= 2 ? 0 : this.leap_gregorian(year) ? -1 : -2) + day);\n        }\n\n        /**\n         * @desc Calculate Gregorian calendar date from Julian day\n         * @param {*} jd\n         */\n\n    }, {\n        key: 'jd_to_gregorian',\n        value: function jd_to_gregorian(jd) {\n            var wjd = void 0,\n                depoch = void 0,\n                quadricent = void 0,\n                dqc = void 0,\n                cent = void 0,\n                dcent = void 0,\n                quad = void 0,\n                dquad = void 0,\n                yindex = void 0,\n                year = void 0,\n                yearday = void 0,\n                leapadj = void 0,\n                month = void 0,\n                day = void 0;\n\n            wjd = Math.floor(jd - 0.5) + 0.5;\n            depoch = wjd - this.GREGORIAN_EPOCH;\n            quadricent = Math.floor(depoch / 146097);\n            dqc = this.ASTRO.mod(depoch, 146097);\n            cent = Math.floor(dqc / 36524);\n            dcent = this.ASTRO.mod(dqc, 36524);\n            quad = Math.floor(dcent / 1461);\n            dquad = this.ASTRO.mod(dcent, 1461);\n            yindex = Math.floor(dquad / 365);\n            year = quadricent * 400 + cent * 100 + quad * 4 + yindex;\n            if (!(cent === 4 || yindex === 4)) {\n                year++;\n            }\n            yearday = wjd - this.gregorian_to_jd(year, 1, 1);\n            leapadj = wjd < this.gregorian_to_jd(year, 3, 1) ? 0 : this.leap_gregorian(year) ? 1 : 2;\n            month = Math.floor(((yearday + leapadj) * 12 + 373) / 367);\n            day = wjd - this.gregorian_to_jd(year, month, 1) + 1;\n\n            return [year, month, day];\n        }\n\n        /**\n         * @param {*} year\n         */\n        //    leap_julian (year) {\n        //        return this.ASTRO.mod(year, 4) === ((year > 0) ? 0 : 3);\n        //    }\n\n\n        /**\n         * @desc Calculate Julian calendar date from Julian day\n         * @param {*} td\n         */\n        //    jd_to_julian (td) {\n        //        let z, a, b, c, d, e, year, month, day;\n        //\n        //        td += 0.5;\n        //        z = Math.floor(td);\n        //\n        //        a = z;\n        //        b = a + 1524;\n        //        c = Math.floor((b - 122.1) / 365.25);\n        //        d = Math.floor(365.25 * c);\n        //        e = Math.floor((b - d) / 30.6001);\n        //\n        //        month = Math.floor((e < 14) ? (e - 1) : (e - 13));\n        //        year = Math.floor((month > 2) ? (c - 4716) : (c - 4715));\n        //        day = b - d - Math.floor(30.6001 * e);\n        //\n        //        /*  If year is less than 1, subtract one to convert from\n        //         a zero based date system to the common era system in\n        //         which the year -1 (1 B.C.E) is followed by year 1 (1 C.E.).  */\n        //\n        //        if (year < 1) {\n        //            year--;\n        //        }\n        //\n        //        return [year, month, day];\n        //    }\n\n\n        /**\n         * @desc TEHRAN_EQUINOX  --  Determine Julian day and fraction of the\n         March equinox at the Tehran meridian in\n         a given Gregorian year.\n         * @param {*} year\n         */\n\n    }, {\n        key: 'tehran_equinox',\n        value: function tehran_equinox(year) {\n            var equJED = void 0,\n                equJD = void 0,\n                equAPP = void 0,\n                equTehran = void 0,\n                dtTehran = void 0;\n\n            //  March equinox in dynamical time\n            equJED = this.ASTRO.equinox(year, 0);\n\n            //  Correct for delta T to obtain Universal time\n            equJD = equJED - this.ASTRO.deltat(year) / (24 * 60 * 60);\n\n            //  Apply the equation of time to yield the apparent time at Greenwich\n            equAPP = equJD + this.ASTRO.equationOfTime(equJED);\n\n            /*  Finally, we must correct for the constant difference between\n             the Greenwich meridian andthe time zone standard for\n             Iran Standard time, 52°30' to the East.  */\n\n            dtTehran = (52 + 30 / 60.0 + 0 / (60.0 * 60.0)) / 360;\n            equTehran = equAPP + dtTehran;\n\n            return equTehran;\n        }\n\n        /**\n         * @desc TEHRAN_EQUINOX_JD  --  Calculate Julian day during which the\n         March equinox, reckoned from the Tehran\n         meridian, occurred for a given Gregorian\n         year.\n         * @param {*} year\n         */\n\n    }, {\n        key: 'tehran_equinox_jd',\n        value: function tehran_equinox_jd(year) {\n            var ep = void 0,\n                epg = void 0;\n\n            ep = this.tehran_equinox(year);\n            epg = Math.floor(ep);\n\n            return epg;\n        }\n\n        /**\n         * @desc  PERSIANA_YEAR  --  Determine the year in the Persian\n         astronomical calendar in which a\n         given Julian day falls.  Returns an\n         array of two elements:\n          [0]  Persian year\n         [1]  Julian day number containing\n         equinox for this year.\n         * @param {*} jd\n         */\n\n    }, {\n        key: 'persiana_year',\n        value: function persiana_year(jd) {\n            var guess = this.jd_to_gregorian(jd)[0] - 2,\n                lasteq = void 0,\n                nexteq = void 0,\n                adr = void 0;\n\n            lasteq = this.tehran_equinox_jd(guess);\n            while (lasteq > jd) {\n                guess--;\n                lasteq = this.tehran_equinox_jd(guess);\n            }\n            nexteq = lasteq - 1;\n            while (!(lasteq <= jd && jd < nexteq)) {\n                lasteq = nexteq;\n                guess++;\n                nexteq = this.tehran_equinox_jd(guess);\n            }\n            adr = Math.round((lasteq - this.PERSIAN_EPOCH) / this.ASTRO.TropicalYear) + 1;\n\n            return [adr, lasteq];\n        }\n\n        /**\n         * @desc Calculate date in the Persian astronomical\n         calendar from Julian day.\n         * @param {*} jd\n         */\n\n    }, {\n        key: 'jd_to_persiana',\n        value: function jd_to_persiana(jd) {\n            var year = void 0,\n                month = void 0,\n                day = void 0,\n                adr = void 0,\n                equinox = void 0,\n                yday = void 0;\n\n            jd = Math.floor(jd) + 0.5;\n            adr = this.persiana_year(jd);\n            year = adr[0];\n            equinox = adr[1];\n            day = Math.floor((jd - equinox) / 30) + 1;\n\n            yday = Math.floor(jd) - this.persiana_to_jd(year, 1, 1) + 1;\n            month = yday <= 186 ? Math.ceil(yday / 31) : Math.ceil((yday - 6) / 30);\n            day = Math.floor(jd) - this.persiana_to_jd(year, month, 1) + 1;\n\n            return [year, month, day];\n        }\n\n        /**\n         * @desc Obtain Julian day from a given Persian\n         astronomical calendar date.\n         * @param {*} year\n         * @param {*} month\n         * @param {*} day\n         */\n\n    }, {\n        key: 'persiana_to_jd',\n        value: function persiana_to_jd(year, month, day) {\n            var adr = void 0,\n                equinox = void 0,\n                guess = void 0,\n                jd = void 0;\n\n            guess = this.PERSIAN_EPOCH - 1 + this.ASTRO.TropicalYear * (year - 1 - 1);\n            adr = [year - 1, 0];\n\n            while (adr[0] < year) {\n                adr = this.persiana_year(guess);\n                guess = adr[1] + (this.ASTRO.TropicalYear + 2);\n            }\n            equinox = adr[1];\n\n            jd = equinox + (month <= 7 ? (month - 1) * 31 : (month - 1) * 30 + 6) + (day - 1);\n            return jd;\n        }\n\n        /**\n         * @desc Is a given year a leap year in the Persian astronomical calendar ?\n         * @param {*} year\n         */\n\n    }, {\n        key: 'leap_persiana',\n        value: function leap_persiana(year) {\n            return this.persiana_to_jd(year + 1, 1, 1) - this.persiana_to_jd(year, 1, 1) > 365;\n        }\n\n        /**\n         * @desc Is a given year a leap year in the Persian calendar ?\n         * also nasa use this algorithm https://eclipse.gsfc.nasa.gov/SKYCAL/algorithm.js search for 'getLastDayOfPersianMonth' and you can find it\n         * @param {*} year\n         *\n         */\n\n    }, {\n        key: 'leap_persian',\n        value: function leap_persian(year) {\n            return ((year - (year > 0 ? 474 : 473)) % 2820 + 474 + 38) * 682 % 2816 < 682;\n        }\n\n        /**\n         * @desc Determine Julian day from Persian date\n         * @param {*} year\n         * @param {*} month\n         * @param {*} day\n         */\n\n    }, {\n        key: 'persian_to_jd',\n        value: function persian_to_jd(year, month, day) {\n            var epbase = void 0,\n                epyear = void 0;\n\n            epbase = year - (year >= 0 ? 474 : 473);\n            epyear = 474 + this.ASTRO.mod(epbase, 2820);\n\n            return day + (month <= 7 ? (month - 1) * 31 : (month - 1) * 30 + 6) + Math.floor((epyear * 682 - 110) / 2816) + (epyear - 1) * 365 + Math.floor(epbase / 2820) * 1029983 + (this.PERSIAN_EPOCH - 1);\n        }\n\n        /**\n         * @desc Calculate Persian date from Julian day\n         * @param {*} jd\n         */\n\n    }, {\n        key: 'jd_to_persian',\n        value: function jd_to_persian(jd) {\n            var year = void 0,\n                month = void 0,\n                day = void 0,\n                depoch = void 0,\n                cycle = void 0,\n                cyear = void 0,\n                ycycle = void 0,\n                aux1 = void 0,\n                aux2 = void 0,\n                yday = void 0;\n\n            jd = Math.floor(jd) + 0.5;\n\n            depoch = jd - this.persian_to_jd(475, 1, 1);\n            cycle = Math.floor(depoch / 1029983);\n            cyear = this.ASTRO.mod(depoch, 1029983);\n            if (cyear === 1029982) {\n                ycycle = 2820;\n            } else {\n                aux1 = Math.floor(cyear / 366);\n                aux2 = this.ASTRO.mod(cyear, 366);\n                ycycle = Math.floor((2134 * aux1 + 2816 * aux2 + 2815) / 1028522) + aux1 + 1;\n            }\n            year = ycycle + 2820 * cycle + 474;\n            if (year <= 0) {\n                year--;\n            }\n            yday = jd - this.persian_to_jd(year, 1, 1) + 1;\n            month = yday <= 186 ? Math.ceil(yday / 31) : Math.ceil((yday - 6) / 30);\n            day = jd - this.persian_to_jd(year, month, 1) + 1;\n            return [year, month, day];\n        }\n\n        /**\n         *\n         * @param {*} weekday\n         */\n\n    }, {\n        key: 'gWeekDayToPersian',\n        value: function gWeekDayToPersian(weekday) {\n            if (weekday + 2 === 8) {\n                return 1;\n            } else if (weekday + 2 === 7) {\n                return 7;\n            } else {\n                return weekday + 2;\n            }\n        }\n\n        /**\n         * @desc updateFromGregorian  --  Update all calendars from Gregorian.\n         \"Why not Julian date?\" you ask.  Because\n         starting from Gregorian guarantees we're\n         already snapped to an integral second, so\n         we don't get roundoff errors in other\n         calendars.\n         */\n\n    }, {\n        key: 'updateFromGregorian',\n        value: function updateFromGregorian() {\n            var j = void 0,\n                year = void 0,\n                mon = void 0,\n                mday = void 0,\n                hour = void 0,\n                min = void 0,\n                sec = void 0,\n                weekday = void 0,\n                utime = void 0,\n                perscal = void 0;\n\n            year = this.State.gregorian.year;\n            mon = this.State.gregorian.month;\n            mday = this.State.gregorian.day;\n            hour = 0; //this.State.gregorian.hour;\n            min = 0; //this.State.gregorian.minute;\n            sec = 0; //this.State.gregorian.second;\n\n            this.State.gDate = new Date(year, mon, mday, this.State.gregorian.hour, this.State.gregorian.minute, this.State.gregorian.second, this.State.gregorian.millisecond);\n\n            if (this.parent._utcMode === false) {\n                this.State.zone = this.State.gDate.getTimezoneOffset();\n            }\n\n            // Added for this algorithms cant parse 2016,13,32 successfully\n            this.State.gregorian.year = this.State.gDate.getFullYear();\n            this.State.gregorian.month = this.State.gDate.getMonth();\n            this.State.gregorian.day = this.State.gDate.getDate();\n\n            //  Update Julian day\n            // ---------------------------------------------------------------------------\n            j = this.gregorian_to_jd(year, mon + 1, mday) + Math.floor(sec + 60 * (min + 60 * hour) + 0.5) / 86400.0;\n\n            this.State.julianday = j;\n            this.State.modifiedjulianday = j - this.JMJD;\n\n            //  Update day of week in Gregorian box\n            // ---------------------------------------------------------------------------\n            weekday = this.ASTRO.jwday(j);\n            // Move to 1 indexed number\n            this.State.gregorian.weekday = weekday + 1;\n\n            //  Update leap year status in Gregorian box\n            // ---------------------------------------------------------------------------\n            this.State.gregorian.leap = this.NormLeap[this.leap_gregorian(year) ? 1 : 0];\n\n            //  Update Julian Calendar\n            // ---------------------------------------------------------------------------\n            //        julcal = this.jd_to_julian(j);\n            //\n            //        this.State.juliancalendar.year = julcal[0];\n            //        this.State.juliancalendar.month = julcal[1] - 1;\n            //        this.State.juliancalendar.day = julcal[2];\n            //        this.State.juliancalendar.leap = this.NormLeap[this.leap_julian(julcal[0]) ? 1 : 0];\n            weekday = this.ASTRO.jwday(j);\n            //        this.State.juliancalendar.weekday = weekday;\n\n            //  Update Persian Calendar\n            // ---------------------------------------------------------------------------\n            if (this.parent.calendarType == 'persian' && this.parent.leapYearMode == 'algorithmic') {\n                perscal = this.jd_to_persian(j);\n                this.State.persian.year = perscal[0];\n                this.State.persian.month = perscal[1] - 1;\n                this.State.persian.day = perscal[2];\n                this.State.persian.weekday = this.gWeekDayToPersian(weekday);\n                this.State.persian.leap = this.NormLeap[this.leap_persian(perscal[0]) ? 1 : 0];\n            }\n\n            //  Update Persian Astronomical Calendar\n            // ---------------------------------------------------------------------------\n            if (this.parent.calendarType == 'persian' && this.parent.leapYearMode == 'astronomical') {\n                perscal = this.jd_to_persiana(j);\n                this.State.persianAstro.year = perscal[0];\n                this.State.persianAstro.month = perscal[1] - 1;\n                this.State.persianAstro.day = perscal[2];\n                this.State.persianAstro.weekday = this.gWeekDayToPersian(weekday);\n                this.State.persianAstro.leap = this.NormLeap[this.leap_persiana(perscal[0]) ? 1 : 0];\n            }\n            //  Update Gregorian serial number\n            // ---------------------------------------------------------------------------\n            if (this.State.gregserial.day !== null) {\n                this.State.gregserial.day = j - this.J0000;\n            }\n\n            //  Update Unix time()\n            // ---------------------------------------------------------------------------\n            utime = (j - this.J1970) * (60 * 60 * 24 * 1000);\n\n            this.State.unixtime = Math.round(utime / 1000);\n        }\n\n        /**\n         * @desc Perform calculation starting with a Gregorian date\n         * @param {*} dateArray\n         */\n\n    }, {\n        key: 'calcGregorian',\n        value: function calcGregorian(dateArray) {\n            if (dateArray[0] || dateArray[0] === 0) {\n                this.State.gregorian.year = dateArray[0];\n            }\n            if (dateArray[1] || dateArray[1] === 0) {\n                this.State.gregorian.month = dateArray[1];\n            }\n            if (dateArray[2] || dateArray[2] === 0) {\n                this.State.gregorian.day = dateArray[2];\n            }\n            if (dateArray[3] || dateArray[3] === 0) {\n                this.State.gregorian.hour = dateArray[3];\n            }\n            if (dateArray[4] || dateArray[4] === 0) {\n                this.State.gregorian.minute = dateArray[4];\n            }\n            if (dateArray[5] || dateArray[5] === 0) {\n                this.State.gregorian.second = dateArray[5];\n            }\n            if (dateArray[6] || dateArray[6] === 0) {\n                this.State.gregorian.millisecond = dateArray[6];\n            }\n            this.updateFromGregorian();\n        }\n\n        /**\n         * @desc Perform calculation starting with a Julian date\n         */\n\n    }, {\n        key: 'calcJulian',\n        value: function calcJulian() {\n            var j = void 0,\n                date = void 0;\n            j = this.State.julianday;\n            date = this.jd_to_gregorian(j);\n            this.State.gregorian.year = date[0];\n            this.State.gregorian.month = date[1] - 1;\n            this.State.gregorian.day = date[2];\n            //        this.State.gregorian.hour = this.pad(time[0], 2, \" \");\n            //        this.State.gregorian.minute = this.pad(time[1], 2, \"0\");\n            //        this.State.gregorian.second = this.pad(time[2], 2, \"0\");\n            this.updateFromGregorian();\n        }\n\n        /**\n         * @desc Set Julian date and update all calendars\n         * @param {*} j\n         */\n\n    }, {\n        key: 'setJulian',\n        value: function setJulian(j) {\n            this.State.julianday = j;\n            this.calcJulian();\n        }\n\n        /**\n         * @desc  Update from Persian calendar\n         * @param {*} dateArray\n         */\n\n    }, {\n        key: 'calcPersian',\n        value: function calcPersian(dateArray) {\n            if (dateArray[0] || dateArray[0] === 0) {\n                this.State.persian.year = dateArray[0];\n            }\n            if (dateArray[1] || dateArray[1] === 0) {\n                this.State.persian.month = dateArray[1];\n            }\n            if (dateArray[2] || dateArray[2] === 0) {\n                this.State.persian.day = dateArray[2];\n            }\n            if (dateArray[3] || dateArray[3] === 0) {\n                this.State.gregorian.hour = dateArray[3];\n            }\n            if (dateArray[4] || dateArray[4] === 0) {\n                this.State.gregorian.minute = dateArray[4];\n            }\n            if (dateArray[5] || dateArray[5] === 0) {\n                this.State.gregorian.second = dateArray[5];\n            }\n            if (dateArray[6] || dateArray[6] === 0) {\n                this.State.gregorian.millisecond = dateArray[6];\n            }\n\n            this.setJulian(this.persian_to_jd(this.State.persian.year, this.State.persian.month, this.State.persian.day));\n        }\n\n        /**\n         * @desc Update from Persian astronomical calendar\n         * @param {*} dateArray\n         */\n\n    }, {\n        key: 'calcPersiana',\n        value: function calcPersiana(dateArray) {\n            if (dateArray[0] || dateArray[0] === 0) {\n                this.State.persianAstro.year = dateArray[0];\n            }\n            if (dateArray[1] || dateArray[1] === 0) {\n                this.State.persianAstro.month = dateArray[1];\n            }\n            if (dateArray[2] || dateArray[2] === 0) {\n                this.State.persianAstro.day = dateArray[2];\n            }\n\n            if (dateArray[3] || dateArray[3] === 0) {\n                this.State.gregorian.hour = dateArray[3];\n            }\n            if (dateArray[4] || dateArray[4] === 0) {\n                this.State.gregorian.minute = dateArray[4];\n            }\n            if (dateArray[5] || dateArray[5] === 0) {\n                this.State.gregorian.second = dateArray[5];\n            }\n            if (dateArray[6] || dateArray[6] === 0) {\n                this.State.gregorian.millisecond = dateArray[6];\n            }\n            this.setJulian(this.persiana_to_jd(this.State.persianAstro.year, this.State.persianAstro.month, this.State.persianAstro.day + 0.5));\n        }\n    }]);\n\n    return Algorithms;\n}();\n\nmodule.exports = Algorithms;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*\n JavaScript functions for positional astronomy\n by John Walker  --  September, MIM\n http://www.fourmilab.ch/\n This program is in the public domain.\n */\n\nvar ASTRO = function () {\n    function ASTRO() {\n        _classCallCheck(this, ASTRO);\n\n        //  Frequently-used constants\n        this.J2000 = 2451545.0; // Julian day of J2000 epoch\n        this.JulianCentury = 36525.0; // Days in Julian century\n        this.JulianMillennium = this.JulianCentury * 10; // Days in Julian millennium\n        //        this.AstronomicalUnit = 149597870.0;           // Astronomical unit in kilometres\n        this.TropicalYear = 365.24219878; // Mean solar tropical year\n\n        /*  OBLIQEQ  --  Calculate the obliquity of the ecliptic for a given\n         Julian date.  This uses Laskar's tenth-degree\n         polynomial fit (J. Laskar, Astronomy and\n         Astrophysics, Vol. 157, page 68 [1986]) which is\n         accurate to within 0.01 arc second between AD 1000\n         and AD 3000, and within a few seconds of arc for\n         +/-10000 years around AD 2000.  If we're outside the\n         range in which this fit is valid (deep time) we\n         simply return the J2000 value of the obliquity, which\n         happens to be almost precisely the mean.  */\n        this.oterms = [-4680.93, -1.55, 1999.25, -51.38, -249.67, -39.05, 7.12, 27.87, 5.79, 2.45];\n        /* Periodic terms for nutation in longiude (delta \\Psi) and\n         obliquity (delta \\Epsilon) as given in table 21.A of\n         Meeus, \"Astronomical Algorithms\", first edition. */\n        this.nutArgMult = [0, 0, 0, 0, 1, -2, 0, 0, 2, 2, 0, 0, 0, 2, 2, 0, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, -2, 1, 0, 2, 2, 0, 0, 0, 2, 1, 0, 0, 1, 2, 2, -2, -1, 0, 2, 2, -2, 0, 1, 0, 0, -2, 0, 0, 2, 1, 0, 0, -1, 2, 2, 2, 0, 0, 0, 0, 0, 0, 1, 0, 1, 2, 0, -1, 2, 2, 0, 0, -1, 0, 1, 0, 0, 1, 2, 1, -2, 0, 2, 0, 0, 0, 0, -2, 2, 1, 2, 0, 0, 2, 2, 0, 0, 2, 2, 2, 0, 0, 2, 0, 0, -2, 0, 1, 2, 2, 0, 0, 0, 2, 0, -2, 0, 0, 2, 0, 0, 0, -1, 2, 1, 0, 2, 0, 0, 0, 2, 0, -1, 0, 1, -2, 2, 0, 2, 2, 0, 1, 0, 0, 1, -2, 0, 1, 0, 1, 0, -1, 0, 0, 1, 0, 0, 2, -2, 0, 2, 0, -1, 2, 1, 2, 0, 1, 2, 2, 0, 1, 0, 2, 2, -2, 1, 1, 0, 0, 0, -1, 0, 2, 2, 2, 0, 0, 2, 1, 2, 0, 1, 0, 0, -2, 0, 2, 2, 2, -2, 0, 1, 2, 1, 2, 0, -2, 0, 1, 2, 0, 0, 0, 1, 0, -1, 1, 0, 0, -2, -1, 0, 2, 1, -2, 0, 0, 0, 1, 0, 0, 2, 2, 1, -2, 0, 2, 0, 1, -2, 1, 0, 2, 1, 0, 0, 1, -2, 0, -1, 0, 1, 0, 0, -2, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 2, 0, -1, -1, 1, 0, 0, 0, 1, 1, 0, 0, 0, -1, 1, 2, 2, 2, -1, -1, 2, 2, 0, 0, -2, 2, 2, 0, 0, 3, 2, 2, 2, -1, 0, 2, 2];\n\n        this.nutArgCoeff = [-171996, -1742, 92095, 89, /*  0,  0,  0,  0,  1 */\n        -13187, -16, 5736, -31, /* -2,  0,  0,  2,  2 */\n        -2274, -2, 977, -5, /*  0,  0,  0,  2,  2 */\n        2062, 2, -895, 5, /*  0,  0,  0,  0,  2 */\n        1426, -34, 54, -1, /*  0,  1,  0,  0,  0 */\n        712, 1, -7, 0, /*  0,  0,  1,  0,  0 */\n        -517, 12, 224, -6, /* -2,  1,  0,  2,  2 */\n        -386, -4, 200, 0, /*  0,  0,  0,  2,  1 */\n        -301, 0, 129, -1, /*  0,  0,  1,  2,  2 */\n        217, -5, -95, 3, /* -2, -1,  0,  2,  2 */\n        -158, 0, 0, 0, /* -2,  0,  1,  0,  0 */\n        129, 1, -70, 0, /* -2,  0,  0,  2,  1 */\n        123, 0, -53, 0, /*  0,  0, -1,  2,  2 */\n        63, 0, 0, 0, /*  2,  0,  0,  0,  0 */\n        63, 1, -33, 0, /*  0,  0,  1,  0,  1 */\n        -59, 0, 26, 0, /*  2,  0, -1,  2,  2 */\n        -58, -1, 32, 0, /*  0,  0, -1,  0,  1 */\n        -51, 0, 27, 0, /*  0,  0,  1,  2,  1 */\n        48, 0, 0, 0, /* -2,  0,  2,  0,  0 */\n        46, 0, -24, 0, /*  0,  0, -2,  2,  1 */\n        -38, 0, 16, 0, /*  2,  0,  0,  2,  2 */\n        -31, 0, 13, 0, /*  0,  0,  2,  2,  2 */\n        29, 0, 0, 0, /*  0,  0,  2,  0,  0 */\n        29, 0, -12, 0, /* -2,  0,  1,  2,  2 */\n        26, 0, 0, 0, /*  0,  0,  0,  2,  0 */\n        -22, 0, 0, 0, /* -2,  0,  0,  2,  0 */\n        21, 0, -10, 0, /*  0,  0, -1,  2,  1 */\n        17, -1, 0, 0, /*  0,  2,  0,  0,  0 */\n        16, 0, -8, 0, /*  2,  0, -1,  0,  1 */\n        -16, 1, 7, 0, /* -2,  2,  0,  2,  2 */\n        -15, 0, 9, 0, /*  0,  1,  0,  0,  1 */\n        -13, 0, 7, 0, /* -2,  0,  1,  0,  1 */\n        -12, 0, 6, 0, /*  0, -1,  0,  0,  1 */\n        11, 0, 0, 0, /*  0,  0,  2, -2,  0 */\n        -10, 0, 5, 0, /*  2,  0, -1,  2,  1 */\n        -8, 0, 3, 0, /*  2,  0,  1,  2,  2 */\n        7, 0, -3, 0, /*  0,  1,  0,  2,  2 */\n        -7, 0, 0, 0, /* -2,  1,  1,  0,  0 */\n        -7, 0, 3, 0, /*  0, -1,  0,  2,  2 */\n        -7, 0, 3, 0, /*  2,  0,  0,  2,  1 */\n        6, 0, 0, 0, /*  2,  0,  1,  0,  0 */\n        6, 0, -3, 0, /* -2,  0,  2,  2,  2 */\n        6, 0, -3, 0, /* -2,  0,  1,  2,  1 */\n        -6, 0, 3, 0, /*  2,  0, -2,  0,  1 */\n        -6, 0, 3, 0, /*  2,  0,  0,  0,  1 */\n        5, 0, 0, 0, /*  0, -1,  1,  0,  0 */\n        -5, 0, 3, 0, /* -2, -1,  0,  2,  1 */\n        -5, 0, 3, 0, /* -2,  0,  0,  0,  1 */\n        -5, 0, 3, 0, /*  0,  0,  2,  2,  1 */\n        4, 0, 0, 0, /* -2,  0,  2,  0,  1 */\n        4, 0, 0, 0, /* -2,  1,  0,  2,  1 */\n        4, 0, 0, 0, /*  0,  0,  1, -2,  0 */\n        -4, 0, 0, 0, /* -1,  0,  1,  0,  0 */\n        -4, 0, 0, 0, /* -2,  1,  0,  0,  0 */\n        -4, 0, 0, 0, /*  1,  0,  0,  0,  0 */\n        3, 0, 0, 0, /*  0,  0,  1,  2,  0 */\n        -3, 0, 0, 0, /* -1, -1,  1,  0,  0 */\n        -3, 0, 0, 0, /*  0,  1,  1,  0,  0 */\n        -3, 0, 0, 0, /*  0, -1,  1,  2,  2 */\n        -3, 0, 0, 0, /*  2, -1, -1,  2,  2 */\n        -3, 0, 0, 0, /*  0,  0, -2,  2,  2 */\n        -3, 0, 0, 0, /*  0,  0,  3,  2,  2 */\n        -3, 0, 0, 0 /*  2, -1,  0,  2,  2 */\n        ];\n\n        /**\n         * @desc Table of observed Delta T values at the beginning of even numbered years from 1620 through 2002.\n         * @type Array\n         */\n        this.deltaTtab = [121, 112, 103, 95, 88, 82, 77, 72, 68, 63, 60, 56, 53, 51, 48, 46, 44, 42, 40, 38, 35, 33, 31, 29, 26, 24, 22, 20, 18, 16, 14, 12, 11, 10, 9, 8, 7, 7, 7, 7, 7, 7, 8, 8, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 15, 15, 14, 13, 13.1, 12.5, 12.2, 12, 12, 12, 12, 12, 12, 11.9, 11.6, 11, 10.2, 9.2, 8.2, 7.1, 6.2, 5.6, 5.4, 5.3, 5.4, 5.6, 5.9, 6.2, 6.5, 6.8, 7.1, 7.3, 7.5, 7.6, 7.7, 7.3, 6.2, 5.2, 2.7, 1.4, -1.2, -2.8, -3.8, -4.8, -5.5, -5.3, -5.6, -5.7, -5.9, -6, -6.3, -6.5, -6.2, -4.7, -2.8, -0.1, 2.6, 5.3, 7.7, 10.4, 13.3, 16, 18.2, 20.2, 21.1, 22.4, 23.5, 23.8, 24.3, 24, 23.9, 23.9, 23.7, 24, 24.3, 25.3, 26.2, 27.3, 28.2, 29.1, 30, 30.7, 31.4, 32.2, 33.1, 34, 35, 36.5, 38.3, 40.2, 42.2, 44.5, 46.5, 48.5, 50.5, 52.2, 53.8, 54.9, 55.8, 56.9, 58.3, 60, 61.6, 63, 65, 66.6];\n\n        /*  EQUINOX  --  Determine the Julian Ephemeris Day of an\n         equinox or solstice.  The \"which\" argument\n         selects the item to be computed:\n          0   March equinox\n         1   June solstice\n         2   September equinox\n         3   December solstice\n          */\n        /**\n         * @desc Periodic terms to obtain true time\n         * @type Array\n         */\n        this.EquinoxpTerms = [485, 324.96, 1934.136, 203, 337.23, 32964.467, 199, 342.08, 20.186, 182, 27.85, 445267.112, 156, 73.14, 45036.886, 136, 171.52, 22518.443, 77, 222.54, 65928.934, 74, 296.72, 3034.906, 70, 243.58, 9037.513, 58, 119.81, 33718.147, 52, 297.17, 150.678, 50, 21.02, 2281.226, 45, 247.54, 29929.562, 44, 325.15, 31555.956, 29, 60.93, 4443.417, 18, 155.12, 67555.328, 17, 288.79, 4562.452, 16, 198.04, 62894.029, 14, 199.76, 31436.921, 12, 95.39, 14577.848, 12, 287.11, 31931.756, 12, 320.81, 34777.259, 9, 227.73, 1222.114, 8, 15.45, 16859.074];\n\n        this.JDE0tab1000 = [new Array(1721139.29189, 365242.13740, 0.06134, 0.00111, -0.00071), new Array(1721233.25401, 365241.72562, -0.05323, 0.00907, 0.00025), new Array(1721325.70455, 365242.49558, -0.11677, -0.00297, 0.00074), new Array(1721414.39987, 365242.88257, -0.00769, -0.00933, -0.00006)];\n\n        this.JDE0tab2000 = [new Array(2451623.80984, 365242.37404, 0.05169, -0.00411, -0.00057), new Array(2451716.56767, 365241.62603, 0.00325, 0.00888, -0.00030), new Array(2451810.21715, 365242.01767, -0.11575, 0.00337, 0.00078), new Array(2451900.05952, 365242.74049, -0.06223, -0.00823, 0.00032)];\n    }\n\n    /**\n     *\n     * @param Degrees to radians.\n     * @return {number}\n     */\n\n\n    _createClass(ASTRO, [{\n        key: \"dtr\",\n        value: function dtr(d) {\n            return d * Math.PI / 180.0;\n        }\n\n        /**\n         * @desc Radians to degrees.\n         * @param r\n         * @return {number}\n         */\n\n    }, {\n        key: \"rtd\",\n        value: function rtd(r) {\n            return r * 180.0 / Math.PI;\n        }\n\n        /**\n         * @desc Range reduce angle in degrees.\n         * @param a\n         * @return {number}\n         */\n\n    }, {\n        key: \"fixangle\",\n        value: function fixangle(a) {\n            return a - 360.0 * Math.floor(a / 360.0);\n        }\n\n        /**\n         * @desc Range reduce angle in radians.\n         * @param a\n         * @return {number}\n         */\n\n    }, {\n        key: \"fixangr\",\n        value: function fixangr(a) {\n            return a - 2 * Math.PI * Math.floor(a / (2 * Math.PI));\n        }\n\n        /**\n         * @desc  Sine of an angle in degrees\n         * @param d\n         * @return {number}\n         */\n\n    }, {\n        key: \"dsin\",\n        value: function dsin(d) {\n            return Math.sin(this.dtr(d));\n        }\n\n        /**\n         * @desc Cosine of an angle in degrees\n         * @param d\n         * @return {number}\n         */\n\n    }, {\n        key: \"dcos\",\n        value: function dcos(d) {\n            return Math.cos(this.dtr(d));\n        }\n\n        /**\n         * @desc Modulus function which works for non-integers.\n         * @param a\n         * @param b\n         * @return {number}\n         */\n\n    }, {\n        key: \"mod\",\n        value: function mod(a, b) {\n            return a - b * Math.floor(a / b);\n        }\n\n        /**\n         *\n         * @param j\n         * @return {number}\n         */\n\n    }, {\n        key: \"jwday\",\n        value: function jwday(j) {\n            return this.mod(Math.floor(j + 1.5), 7);\n        }\n\n        /**\n         *\n         * @param jd\n         * @return {number|*}\n         */\n\n    }, {\n        key: \"obliqeq\",\n        value: function obliqeq(jd) {\n            var eps, u, v, i;\n            v = u = (jd - this.J2000) / (this.JulianCentury * 100);\n            eps = 23 + 26 / 60.0 + 21.448 / 3600.0;\n\n            if (Math.abs(u) < 1.0) {\n                for (i = 0; i < 10; i++) {\n                    eps += this.oterms[i] / 3600.0 * v;\n                    v *= u;\n                }\n            }\n            return eps;\n        }\n\n        /**\n         * @desc  Calculate the nutation in longitude, deltaPsi, and\n         obliquity, deltaEpsilon for a given Julian date\n         jd.  Results are returned as a two element Array\n         giving (deltaPsi, deltaEpsilon) in degrees.\n         * @param jd\n         * @return Object\n         */\n\n    }, {\n        key: \"nutation\",\n        value: function nutation(jd) {\n            var deltaPsi,\n                deltaEpsilon,\n                i,\n                j,\n                t = (jd - 2451545.0) / 36525.0,\n                t2,\n                t3,\n                to10,\n                ta = [],\n                dp = 0,\n                de = 0,\n                ang;\n\n            t3 = t * (t2 = t * t);\n\n            /* Calculate angles.  The correspondence between the elements\n             of our array and the terms cited in Meeus are:\n              ta[0] = D  ta[0] = M  ta[2] = M'  ta[3] = F  ta[4] = \\Omega\n              */\n\n            ta[0] = this.dtr(297.850363 + 445267.11148 * t - 0.0019142 * t2 + t3 / 189474.0);\n            ta[1] = this.dtr(357.52772 + 35999.05034 * t - 0.0001603 * t2 - t3 / 300000.0);\n            ta[2] = this.dtr(134.96298 + 477198.867398 * t + 0.0086972 * t2 + t3 / 56250.0);\n            ta[3] = this.dtr(93.27191 + 483202.017538 * t - 0.0036825 * t2 + t3 / 327270);\n            ta[4] = this.dtr(125.04452 - 1934.136261 * t + 0.0020708 * t2 + t3 / 450000.0);\n\n            /* Range reduce the angles in case the sine and cosine functions\n             don't do it as accurately or quickly. */\n\n            for (i = 0; i < 5; i++) {\n                ta[i] = this.fixangr(ta[i]);\n            }\n\n            to10 = t / 10.0;\n            for (i = 0; i < 63; i++) {\n                ang = 0;\n                for (j = 0; j < 5; j++) {\n                    if (this.nutArgMult[i * 5 + j] !== 0) {\n                        ang += this.nutArgMult[i * 5 + j] * ta[j];\n                    }\n                }\n                dp += (this.nutArgCoeff[i * 4 + 0] + this.nutArgCoeff[i * 4 + 1] * to10) * Math.sin(ang);\n                de += (this.nutArgCoeff[i * 4 + 2] + this.nutArgCoeff[i * 4 + 3] * to10) * Math.cos(ang);\n            }\n\n            /* Return the result, converting from ten thousandths of arc\n             seconds to radians in the process. */\n\n            deltaPsi = dp / (3600.0 * 10000.0);\n            deltaEpsilon = de / (3600.0 * 10000.0);\n\n            return [deltaPsi, deltaEpsilon];\n        }\n\n        /**\n         * @desc  Determine the difference, in seconds, between\n         Dynamical time and Universal time.\n         * @param year\n         * @return {*}\n         */\n\n    }, {\n        key: \"deltat\",\n        value: function deltat(year) {\n            var dt, f, i, t;\n\n            if (year >= 1620 && year <= 2000) {\n                i = Math.floor((year - 1620) / 2);\n                f = (year - 1620) / 2 - i;\n                /* Fractional part of year */\n                dt = this.deltaTtab[i] + (this.deltaTtab[i + 1] - this.deltaTtab[i]) * f;\n            } else {\n                t = (year - 2000) / 100;\n                if (year < 948) {\n                    dt = 2177 + 497 * t + 44.1 * t * t;\n                } else {\n                    dt = 102 + 102 * t + 25.3 * t * t;\n                    if (year > 2000 && year < 2100) {\n                        dt += 0.37 * (year - 2100);\n                    }\n                }\n            }\n            return dt;\n        }\n\n        /**\n         *\n         * @param year\n         * @param which\n         * @return {*}\n         */\n\n    }, {\n        key: \"equinox\",\n        value: function equinox(year, which) {\n            var deltaL = void 0,\n                i = void 0,\n                j = void 0,\n                JDE0 = void 0,\n                JDE = void 0,\n                JDE0tab = void 0,\n                S = void 0,\n                T = void 0,\n                W = void 0,\n                Y = void 0;\n            /*  Initialise terms for mean equinox and solstices.  We\n             have two sets: one for years prior to 1000 and a second\n             for subsequent years.  */\n\n            if (year < 1000) {\n                JDE0tab = this.JDE0tab1000;\n                Y = year / 1000;\n            } else {\n                JDE0tab = this.JDE0tab2000;\n                Y = (year - 2000) / 1000;\n            }\n\n            JDE0 = JDE0tab[which][0] + JDE0tab[which][1] * Y + JDE0tab[which][2] * Y * Y + JDE0tab[which][3] * Y * Y * Y + JDE0tab[which][4] * Y * Y * Y * Y;\n            T = (JDE0 - 2451545.0) / 36525;\n            W = 35999.373 * T - 2.47;\n            deltaL = 1 + 0.0334 * this.dcos(W) + 0.0007 * this.dcos(2 * W);\n            S = 0;\n            for (i = j = 0; i < 24; i++) {\n                S += this.EquinoxpTerms[j] * this.dcos(this.EquinoxpTerms[j + 1] + this.EquinoxpTerms[j + 2] * T);\n                j += 3;\n            }\n            JDE = JDE0 + S * 0.00001 / deltaL;\n            return JDE;\n        }\n\n        /**\n         * @desc  Position of the Sun.  Please see the comments\n         on the return statement at the end of this function\n         which describe the array it returns.  We return\n         intermediate values because they are useful in a\n         variety of other contexts.\n         * @param jd\n         * @return Object\n         */\n\n    }, {\n        key: \"sunpos\",\n        value: function sunpos(jd) {\n            var T = void 0,\n                T2 = void 0,\n                L0 = void 0,\n                M = void 0,\n                e = void 0,\n                C = void 0,\n                sunLong = void 0,\n                sunAnomaly = void 0,\n                sunR = void 0,\n                Omega = void 0,\n                Lambda = void 0,\n                epsilon = void 0,\n                epsilon0 = void 0,\n                Alpha = void 0,\n                Delta = void 0,\n                AlphaApp = void 0,\n                DeltaApp = void 0;\n\n            T = (jd - this.J2000) / this.JulianCentury;\n            T2 = T * T;\n            L0 = 280.46646 + 36000.76983 * T + 0.0003032 * T2;\n            L0 = this.fixangle(L0);\n            M = 357.52911 + 35999.05029 * T + -0.0001537 * T2;\n            M = this.fixangle(M);\n            e = 0.016708634 + -0.000042037 * T + -0.0000001267 * T2;\n            C = (1.914602 + -0.004817 * T + -0.000014 * T2) * this.dsin(M) + (0.019993 - 0.000101 * T) * this.dsin(2 * M) + 0.000289 * this.dsin(3 * M);\n            sunLong = L0 + C;\n            sunAnomaly = M + C;\n            sunR = 1.000001018 * (1 - e * e) / (1 + e * this.dcos(sunAnomaly));\n            Omega = 125.04 - 1934.136 * T;\n            Lambda = sunLong + -0.00569 + -0.00478 * this.dsin(Omega);\n            epsilon0 = this.obliqeq(jd);\n            epsilon = epsilon0 + 0.00256 * this.dcos(Omega);\n            Alpha = this.rtd(Math.atan2(this.dcos(epsilon0) * this.dsin(sunLong), this.dcos(sunLong)));\n            Alpha = this.fixangle(Alpha);\n            Delta = this.rtd(Math.asin(this.dsin(epsilon0) * this.dsin(sunLong)));\n            AlphaApp = this.rtd(Math.atan2(this.dcos(epsilon) * this.dsin(Lambda), this.dcos(Lambda)));\n            AlphaApp = this.fixangle(AlphaApp);\n            DeltaApp = this.rtd(Math.asin(this.dsin(epsilon) * this.dsin(Lambda)));\n\n            return [//  Angular quantities are expressed in decimal degrees\n            L0, //  [0] Geometric mean longitude of the Sun\n            M, //  [1] Mean anomaly of the Sun\n            e, //  [2] Eccentricity of the Earth's orbit\n            C, //  [3] Sun's equation of the Centre\n            sunLong, //  [4] Sun's true longitude\n            sunAnomaly, //  [5] Sun's true anomaly\n            sunR, //  [6] Sun's radius vector in AU\n            Lambda, //  [7] Sun's apparent longitude at true equinox of the date\n            Alpha, //  [8] Sun's true right ascension\n            Delta, //  [9] Sun's true declination\n            AlphaApp, // [10] Sun's apparent right ascension\n            DeltaApp // [11] Sun's apparent declination\n            ];\n        }\n\n        /**\n         * @desc Compute equation of time for a given moment. Returns the equation of time as a fraction of a day.\n         * @param jd\n         * @return {number|*}\n         */\n\n    }, {\n        key: \"equationOfTime\",\n        value: function equationOfTime(jd) {\n            var alpha = void 0,\n                deltaPsi = void 0,\n                E = void 0,\n                epsilon = void 0,\n                L0 = void 0,\n                tau = void 0;\n            tau = (jd - this.J2000) / this.JulianMillennium;\n            L0 = 280.4664567 + 360007.6982779 * tau + 0.03032028 * tau * tau + tau * tau * tau / 49931 + -(tau * tau * tau * tau / 15300) + -(tau * tau * tau * tau * tau / 2000000);\n            L0 = this.fixangle(L0);\n            alpha = this.sunpos(jd)[10];\n            deltaPsi = this.nutation(jd)[0];\n            epsilon = this.obliqeq(jd) + this.nutation(jd)[1];\n            E = L0 + -0.0057183 + -alpha + deltaPsi * this.dcos(epsilon);\n            E = E - 20.0 * Math.floor(E / 20.0);\n            E = E / (24 * 60);\n            return E;\n        }\n    }]);\n\n    return ASTRO;\n}();\n\nmodule.exports = ASTRO;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Constants\n * @module constants\n */\n\nmodule.exports = {\n    durationUnit: {\n        year: ['y', 'years', 'year'],\n        month: ['M', 'months', 'month'],\n        day: ['d', 'days', 'day'],\n        hour: ['h', 'hours', 'hour'],\n        minute: ['m', 'minutes', 'minute'],\n        second: ['s', 'second', 'seconds'],\n        millisecond: ['ms', 'milliseconds', 'millisecond'],\n        week: ['W', 'w', 'weeks', 'week']\n    }\n};\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __nested_webpack_require_99868__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Helpers = __nested_webpack_require_99868__(0);\nvar normalizeDuration = new Helpers().normalizeDuration;\nvar absRound = new Helpers().absRound;\nvar absFloor = new Helpers().absFloor;\n/**\n * Duration object constructor\n * @param duration\n * @class Duration\n * @constructor\n */\n\nvar Duration = function () {\n    function Duration(key, value) {\n        _classCallCheck(this, Duration);\n\n        var duration = {},\n            data = this._data = {},\n            milliseconds = 0,\n            normalizedUnit = normalizeDuration(key, value),\n            unit = normalizedUnit.unit;\n        duration[unit] = normalizedUnit.value;\n        milliseconds = duration.milliseconds || duration.millisecond || duration.ms || 0;\n\n        var years = duration.years || duration.year || duration.y || 0,\n            months = duration.months || duration.month || duration.M || 0,\n            weeks = duration.weeks || duration.w || duration.week || 0,\n            days = duration.days || duration.d || duration.day || 0,\n            hours = duration.hours || duration.hour || duration.h || 0,\n            minutes = duration.minutes || duration.minute || duration.m || 0,\n            seconds = duration.seconds || duration.second || duration.s || 0;\n        // representation for dateAddRemove\n        this._milliseconds = milliseconds + seconds * 1e3 + minutes * 6e4 + hours * 36e5;\n        // Because of dateAddRemove treats 24 hours as different from a\n        // day when working around DST, we need to store them separately\n        this._days = days + weeks * 7;\n        // It is impossible translate months into days without knowing\n        // which months you are are talking about, so we have to store\n        // it separately.\n        this._months = months + years * 12;\n        // The following code bubbles up values, see the tests for\n        // examples of what that means.\n        data.milliseconds = milliseconds % 1000;\n        seconds += absFloor(milliseconds / 1000);\n        data.seconds = seconds % 60;\n        minutes += absRound(seconds / 60);\n        data.minutes = minutes % 60;\n        hours += absRound(minutes / 60);\n        data.hours = hours % 24;\n        days += absRound(hours / 24);\n        days += weeks * 7;\n        data.days = days % 30;\n        months += absRound(days / 30);\n        data.months = months % 12;\n        years += absRound(months / 12);\n        data.years = years;\n        return this;\n    }\n\n    _createClass(Duration, [{\n        key: 'valueOf',\n        value: function valueOf() {\n            return this._milliseconds + this._days * 864e5 + this._months * 2592e6;\n        }\n    }]);\n\n    return Duration;\n}();\n\nmodule.exports = Duration;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Constants\n * @module constants\n */\n\nmodule.exports = {\n    gregorian: {\n        months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n        monthsShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n        weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n        weekdaysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n        weekdaysMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa']\n    },\n    persian: {\n        months: ['Farvardin', 'Ordibehesht', 'Khordad', 'Tir', 'Mordad', 'Shahrivar', 'Mehr', 'Aban', 'Azar', 'Dey', 'Bahman', 'Esfand'],\n        monthsShort: ['Far', 'Ord', 'Kho', 'Tir', 'Mor', 'Sha', 'Meh', 'Aba', 'Aza', 'Dey', 'Bah', 'Esf'],\n        weekdays: ['Saturday', 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'],\n        weekdaysShort: ['Sat', 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri'],\n        weekdaysMin: ['Sa', 'Su', 'Mo', 'Tu', 'We', 'Th', 'Fr'],\n        persianDaysName: ['Urmazd', 'Bahman', 'Ordibehesht', 'Shahrivar', 'Sepandarmaz', 'Khurdad', 'Amordad', 'Dey-be-azar', 'Azar', 'Aban', 'Khorshid', 'Mah', 'Tir', 'Gush', 'Dey-be-mehr', 'Mehr', 'Sorush', 'Rashn', 'Farvardin', 'Bahram', 'Ram', 'Bad', 'Dey-be-din', 'Din', 'Ord', 'Ashtad', 'Asman', 'Zamyad', 'Mantre-sepand', 'Anaram', 'Ziadi']\n    }\n};\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Constants\n * @module constants\n */\n\nmodule.exports = {\n    gregorian: {\n        months: 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),\n        monthsShort: 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),\n        weekdays: '\\u06CC\\u06A9\\u200C\\u0634\\u0646\\u0628\\u0647_\\u062F\\u0648\\u0634\\u0646\\u0628\\u0647_\\u0633\\u0647\\u200C\\u0634\\u0646\\u0628\\u0647_\\u0686\\u0647\\u0627\\u0631\\u0634\\u0646\\u0628\\u0647_\\u067E\\u0646\\u062C\\u200C\\u0634\\u0646\\u0628\\u0647_\\u062C\\u0645\\u0639\\u0647_\\u0634\\u0646\\u0628\\u0647'.split('_'),\n        weekdaysShort: '\\u06CC\\u06A9\\u200C\\u0634\\u0646\\u0628\\u0647_\\u062F\\u0648\\u0634\\u0646\\u0628\\u0647_\\u0633\\u0647\\u200C\\u0634\\u0646\\u0628\\u0647_\\u0686\\u0647\\u0627\\u0631\\u0634\\u0646\\u0628\\u0647_\\u067E\\u0646\\u062C\\u200C\\u0634\\u0646\\u0628\\u0647_\\u062C\\u0645\\u0639\\u0647_\\u0634\\u0646\\u0628\\u0647'.split('_'),\n        weekdaysMin: 'ی_د_س_چ_پ_ج_ش'.split('_')\n    },\n    persian: {\n        months: ['فروردین', 'اردیبهشت', 'خرداد', 'تیر', 'مرداد', 'شهریور', 'مهر', 'آبان', 'آذر', 'دی', 'بهمن', 'اسفند'],\n        monthsShort: ['فرو', 'ارد', 'خرد', 'تیر', 'مرد', 'شهر', 'مهر', 'آبا', 'آذر', 'دی', 'بهم', 'اسف'],\n        weekdays: ['شنبه', 'یکشنبه', 'دوشنبه', 'سه شنبه', 'چهار شنبه', '\\u067E\\u0646\\u062C\\u200C\\u0634\\u0646\\u0628\\u0647', 'جمعه'],\n        weekdaysShort: ['ش', 'ی', 'د', 'س', 'چ', 'پ', 'ج'],\n        weekdaysMin: ['ش', 'ی', 'د', 'س', 'چ', 'پ', 'ج'],\n        persianDaysName: ['اورمزد', 'بهمن', 'اوردیبهشت', 'شهریور', 'سپندارمذ', 'خورداد', 'امرداد', 'دی به آذز', 'آذز', 'آبان', 'خورشید', 'ماه', 'تیر', 'گوش', 'دی به مهر', 'مهر', 'سروش', 'رشن', 'فروردین', 'بهرام', 'رام', 'باد', 'دی به دین', 'دین', 'ارد', 'اشتاد', 'آسمان', 'زامیاد', 'مانتره سپند', 'انارام', 'زیادی']\n    }\n};\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __nested_webpack_require_106717__) {\n\n\"use strict\";\n\n\nvar PersianDateClass = __nested_webpack_require_106717__(1);\nPersianDateClass.calendarType = 'persian';\nPersianDateClass.leapYearMode = 'astronomical';\nPersianDateClass.localType = 'fa';\nmodule.exports = PersianDateClass;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Container = function Container() {\n    _classCallCheck(this, Container);\n\n    this.isInvalidDate = null;\n\n    this.gDate = null;\n    /**\n     *\n     * @type {number}\n     */\n    this.modifiedjulianday = 0;\n\n    /**\n     *\n     * @type {number}\n     */\n    this.julianday = 0;\n\n    /**\n     *\n     * @type {{day: number}}\n     */\n    this.gregserial = {\n        day: 0\n    };\n\n    this.zone = 0;\n\n    /**\n     *\n     * @type {{year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, weekday: number, unix: number, leap: number}}\n     */\n    this.gregorian = {\n        year: 0,\n        month: 0,\n        day: 0,\n        hour: 0,\n        minute: 0,\n        second: 0,\n        millisecond: 0,\n        weekday: 0,\n        unix: 0,\n        leap: 0\n    };\n\n    /**\n     *\n     * @type {{year: number, month: number, day: number, leap: number, weekday: number}}\n     */\n    this.juliancalendar = {\n        year: 0,\n        month: 0,\n        day: 0,\n        leap: 0,\n        weekday: 0\n    };\n\n    /**\n     *\n     * @type {{year: number, month: number, day: number, leap: number, weekday: number}}\n     */\n    this.islamic = {\n        year: 0,\n        month: 0,\n        day: 0,\n        leap: 0,\n        weekday: 0\n    };\n\n    /**\n     *\n     * @type {{year: number, month: number, day: number, leap: number, weekday: number}}\n     */\n    this.persianAlgo = this.persian = {\n        year: 0,\n        month: 0,\n        day: 0,\n        leap: 0,\n        weekday: 0\n    };\n\n    /**\n     *\n     * @type {{year: number, month: number, day: number, leap: number, weekday: number}}\n     */\n    this.persianAstro = {\n        year: 0,\n        month: 0,\n        day: 0,\n        leap: 0,\n        weekday: 0\n    };\n\n    /**\n     *\n     * @type {{year: number, week: number, day: number}}\n     */\n    this.isoweek = {\n        year: 0,\n        week: 0,\n        day: 0\n    };\n\n    /**\n     *\n     * @type {{year: number, day: number}}\n     */\n    this.isoday = {\n        year: 0,\n        day: 0\n    };\n};\n\nmodule.exports = Container;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = {\n    /**\n     * @param input\n     * @returns {boolean}\n     */\n    isArray: function isArray(input) {\n        return Object.prototype.toString.call(input) === '[object Array]';\n    },\n\n\n    /**\n     *\n     * @param input\n     * @returns {boolean}\n     */\n    isNumber: function isNumber(input) {\n        return typeof input === 'number';\n    },\n\n\n    /**\n     *\n     * @param input\n     * @returns {boolean}\n     */\n    isDate: function isDate(input) {\n        return input instanceof Date;\n    }\n};\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = {\n  /**\n   * @param input\n   * @returns {boolean}\n   */\n  validateInputArray: function validateInputArray(input) {\n    var out = true;\n    // Check month\n    if (input[1] < 1 || input[1] > 12) {\n      out = false;\n    }\n    // Check date\n    if (input[2] < 1 || input[1] > 31) {\n      out = false;\n    }\n    // Check hour \n    if (input[3] < 0 || input[3] > 24) {\n      out = false;\n    }\n    // Check minute \n    if (input[4] < 0 || input[4] > 60) {\n      out = false;\n    }\n    // Check second \n    if (input[5] < 0 || input[5] > 60) {\n      out = false;\n    }\n    return out;\n  }\n};\n\n/***/ })\n/******/ ]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGVyc2lhbi1kYXRlL2Rpc3QvcGVyc2lhbi1kYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUF5RDtBQUM3RDtBQUNBLE1BQU0sRUFLNEI7QUFDbEMsQ0FBQztBQUNELHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4QkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsOEJBQW1CO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQix1QkFBdUI7QUFDcEQ7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCLGVBQWUsOEJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQSxvQ0FBb0MsNEJBQTRCO0FBQ2hFLDBDQUEwQztBQUMxQyxXQUFXLDhCQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CLGtDQUFrQztBQUMvRDtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQTtBQUNBLGlCQUFpQiw4QkFBbUIsQ0FBQyw4QkFBbUI7QUFDeEQsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywrQkFBbUI7O0FBRXBEOzs7QUFHQSxpQ0FBaUMsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsK0RBQStELHlEQUF5RCxxRUFBcUUsNkRBQTZELHdCQUF3Qjs7QUFFampCLGtE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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUEsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUEsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUEsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsR0FBRztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG1CQUFtQixHQUFHO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsR0FBRztBQUN0Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEdBQUc7QUFDdEI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEdBQUc7QUFDdEI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsR0FBRztBQUN0Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixHQUFHO0FBQ3RCLG1CQUFtQixHQUFHO0FBQ3RCLG1CQUFtQixHQUFHO0FBQ3RCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLEdBQUc7QUFDdEI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixHQUFHO0FBQ3RCO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsR0FBRztBQUN0QixtQkFBbUIsR0FBRztBQUN0QixtQkFBbUIsR0FBRztBQUN0Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsR0FBRztBQUN0Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixHQUFHO0FBQ3RCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckIscUJBQXFCOztBQUVyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsR0FBRztBQUN0Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsR0FBRztBQUN0Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLEdBQUc7QUFDdEI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLEdBQUc7QUFDdEI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGdDQUFtQjs7QUFFcEQ7OztBQUdBLGlDQUFpQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwrREFBK0QseURBQXlELHFFQUFxRSw2REFBNkQsd0JBQXdCOztBQUVqakIsa0RBQWtELDBDQUEwQzs7QUFFNUYsY0FBYyxnQ0FBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekIsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDs7O0FBR0EsdUJBQXVCLGlDQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0Esa0RBQWtELDBDQUEwQzs7QUFFNUY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wZXJzaWFuLWRhdGUvZGlzdC9wZXJzaWFuLWRhdGUuanM/OWRmYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFxuICogcGVyc2lhbi1kYXRlIC0gIDEuMS4wXG4gKiBSZXphIEJhYmFraGFuaSA8YmFiYWtoYW5pLnJlemFAZ21haWwuY29tPlxuICogaHR0cDovL2JhYmFraGFuaS5naXRodWIuaW8vUGVyc2lhbldlYlRvb2xraXQvZG9jcy9wZXJzaWFuLWRhdGUvXG4gKiBVbmRlciBNSVQgbGljZW5zZSBcbiAqIFxuICogXG4gKi9cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcInBlcnNpYW5EYXRlXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInBlcnNpYW5EYXRlXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxuLyoqKioqKi8gXHRcdFx0fSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDgpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgZHVyYXRpb25Vbml0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KS5kdXJhdGlvblVuaXQ7XG5cbnZhciBIZWxwZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhlbHBlcnMoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIZWxwZXJzKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoSGVscGVycywgW3tcbiAgICAgICAga2V5OiAndG9QZXJzaWFuRGlnaXQnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiByZXR1cm4gY29udmVydGVkIHN0cmluZyB0byBwZXJzaWFuIGRpZ2l0XG4gICAgICAgICAqIEBwYXJhbSBkaWdpdFxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfCp9XG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9QZXJzaWFuRGlnaXQoZGlnaXQpIHtcbiAgICAgICAgICAgIHZhciBsYXRpbkRpZ2l0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIGRpZ2l0LnRvU3RyaW5nKCkucmVwbGFjZSgvXFxkKy9nLCBmdW5jdGlvbiAoZGlnaXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5EaWdpdEFyciA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBwZURpZ2l0QXJyID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGkgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgIGogPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRpZ2l0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuRGlnaXRBcnIucHVzaChkaWdpdC5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGVuRGlnaXRBcnIubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVEaWdpdEFyci5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoZW5EaWdpdEFycltqXSArICghIWxhdGluRGlnaXQgJiYgbGF0aW5EaWdpdCA9PT0gdHJ1ZSA/IDE1ODQgOiAxNzI4KSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGVEaWdpdEFyci5qb2luKCcnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBudW1iZXJcbiAgICAgICAgICogQHBhcmFtIHRhcmdldExlbmd0aFxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbGVmdFplcm9GaWxsJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxlZnRaZXJvRmlsbChudW1iZXIsIHRhcmdldExlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IG51bWJlciArICcnO1xuICAgICAgICAgICAgd2hpbGUgKG91dHB1dC5sZW5ndGggPCB0YXJnZXRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAnMCcgKyBvdXRwdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBub3JtYWxpemUgZHVyYXRpb24gcGFyYW1zIGFuZCByZXR1cm4gdmFsaWQgcGFyYW1cbiAgICAgICAgICogQHJldHVybiB7e3VuaXQ6ICosIHZhbHVlOiAqfX1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ25vcm1hbGl6ZUR1cmF0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG5vcm1hbGl6ZUR1cmF0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHVuaXQgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB1bml0ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgICAgICB1bml0ID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGR1cmF0aW9uVW5pdC55ZWFyLmluZGV4T2YodW5pdCkgPiAtMSkge1xuICAgICAgICAgICAgICAgIHVuaXQgPSAneWVhcic7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGR1cmF0aW9uVW5pdC5tb250aC5pbmRleE9mKHVuaXQpID4gLTEpIHtcbiAgICAgICAgICAgICAgICB1bml0ID0gJ21vbnRoJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb25Vbml0LndlZWsuaW5kZXhPZih1bml0KSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdW5pdCA9ICd3ZWVrJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb25Vbml0LmRheS5pbmRleE9mKHVuaXQpID4gLTEpIHtcbiAgICAgICAgICAgICAgICB1bml0ID0gJ2RheSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGR1cmF0aW9uVW5pdC5ob3VyLmluZGV4T2YodW5pdCkgPiAtMSkge1xuICAgICAgICAgICAgICAgIHVuaXQgPSAnaG91cic7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGR1cmF0aW9uVW5pdC5taW51dGUuaW5kZXhPZih1bml0KSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdW5pdCA9ICdtaW51dGUnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvblVuaXQuc2Vjb25kLmluZGV4T2YodW5pdCkgPiAtMSkge1xuICAgICAgICAgICAgICAgIHVuaXQgPSAnc2Vjb25kJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb25Vbml0Lm1pbGxpc2Vjb25kLmluZGV4T2YodW5pdCkgPiAtMSkge1xuICAgICAgICAgICAgICAgIHVuaXQgPSAnbWlsbGlzZWNvbmQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1bml0OiB1bml0LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbnVtYmVyXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdhYnNSb3VuZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhYnNSb3VuZChudW1iZXIpIHtcbiAgICAgICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBudW1iZXJcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYWJzRmxvb3InLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWJzRmxvb3IobnVtYmVyKSB7XG4gICAgICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIC0wIC0+IDBcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcikgfHwgMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBIZWxwZXJzO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhlbHBlcnM7XG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgVHlwZUNoZWNraW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG52YXIgQWxnb3JpdGhtcyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgSGVscGVycyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgRHVyYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFZhbGlkYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xudmFyIHRvUGVyc2lhbkRpZ2l0ID0gbmV3IEhlbHBlcnMoKS50b1BlcnNpYW5EaWdpdDtcbnZhciBsZWZ0WmVyb0ZpbGwgPSBuZXcgSGVscGVycygpLmxlZnRaZXJvRmlsbDtcbnZhciBub3JtYWxpemVEdXJhdGlvbiA9IG5ldyBIZWxwZXJzKCkubm9ybWFsaXplRHVyYXRpb247XG52YXIgZmEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xudmFyIGVuID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gcGVyc2lhbiBkYXRlIGNsYXNzXG4gKi9cblxudmFyIFBlcnNpYW5EYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgKiBAcmV0dXJuIHtQZXJzaWFuRGF0ZUNsYXNzfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBlcnNpYW5EYXRlQ2xhc3MoaW5wdXQpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBlcnNpYW5EYXRlQ2xhc3MpO1xuXG4gICAgICAgIHRoaXMuY2FsZW5kYXJUeXBlID0gUGVyc2lhbkRhdGVDbGFzcy5jYWxlbmRhclR5cGU7XG4gICAgICAgIHRoaXMubG9jYWxUeXBlID0gUGVyc2lhbkRhdGVDbGFzcy5sb2NhbFR5cGU7XG4gICAgICAgIHRoaXMubGVhcFllYXJNb2RlID0gUGVyc2lhbkRhdGVDbGFzcy5sZWFwWWVhck1vZGU7XG5cbiAgICAgICAgdGhpcy5hbGdvcml0aG1zID0gbmV3IEFsZ29yaXRobXModGhpcyk7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IFwiMS4xLjBcIjtcbiAgICAgICAgdGhpcy5fdXRjTW9kZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5sb2NhbFR5cGUgIT09ICdmYScpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0UGVyc2lhbiA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mb3JtYXRQZXJzaWFuID0gJ19kZWZhdWx0JztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLlN0YXRlID0gdGhpcy5hbGdvcml0aG1zLlN0YXRlO1xuICAgICAgICB0aGlzLnNldHVwKGlucHV0KTtcbiAgICAgICAgaWYgKHRoaXMuU3RhdGUuaXNJbnZhbGlkRGF0ZSkge1xuICAgICAgICAgICAgLy8gUmV0dXJuIERhdGUgbGlrZSBtZXNzYWdlXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoWy0xLCAtMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoUGVyc2lhbkRhdGVDbGFzcywgW3tcbiAgICAgICAga2V5OiAnc2V0dXAnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXAoaW5wdXQpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgQW55IHRoaW5nIHRvIEdyZWdvcmlhbiBEYXRlXG4gICAgICAgICAgICBpZiAoVHlwZUNoZWNraW5nLmlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9nRGF0ZVRvQ2FsY3VsYXRvcnMoaW5wdXQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChUeXBlQ2hlY2tpbmcuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIVZhbGlkYXRvci52YWxpZGF0ZUlucHV0QXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuU3RhdGUuaXNJbnZhbGlkRGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5hbGdvcml0aG1zQ2FsYyhbaW5wdXRbMF0sIGlucHV0WzFdID8gaW5wdXRbMV0gOiAxLCBpbnB1dFsyXSA/IGlucHV0WzJdIDogMSwgaW5wdXRbM10gPyBpbnB1dFszXSA6IDAsIGlucHV0WzRdID8gaW5wdXRbNF0gOiAwLCBpbnB1dFs1XSA/IGlucHV0WzVdIDogMCwgaW5wdXRbNl0gPyBpbnB1dFs2XSA6IDBdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoVHlwZUNoZWNraW5nLmlzTnVtYmVyKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIHZhciBmcm9tVW5peCA9IG5ldyBEYXRlKGlucHV0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9nRGF0ZVRvQ2FsY3VsYXRvcnMoZnJvbVVuaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaW5zdGFuY2Ugb2YgcERhdGVcbiAgICAgICAgICAgIGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgUGVyc2lhbkRhdGVDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFsZ29yaXRobXNDYWxjKFtpbnB1dC55ZWFyKCksIGlucHV0Lm1vbnRoKCksIGlucHV0LmRhdGUoKSwgaW5wdXQuaG91cigpLCBpbnB1dC5taW51dGUoKSwgaW5wdXQuc2Vjb25kKCksIGlucHV0Lm1pbGxpc2Vjb25kKCldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQVNQLk5FVCBKU09OIERhdGVcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpbnB1dCAmJiBpbnB1dC5zdWJzdHJpbmcoMCwgNikgPT09ICcvRGF0ZSgnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJvbURvdE5ldCA9IG5ldyBEYXRlKHBhcnNlSW50KGlucHV0LnN1YnN0cig2KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ0RhdGVUb0NhbGN1bGF0b3JzKGZyb21Eb3ROZXQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9nRGF0ZVRvQ2FsY3VsYXRvcnMobm93KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2dldFN5bmNlZENsYXNzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTeW5jZWRDbGFzcyhpbnB1dCkge1xuICAgICAgICAgICAgdmFyIHN5bmNlZENlbGFuZGVyID0gUGVyc2lhbkRhdGVDbGFzcy50b0NhbGVuZGFyKHRoaXMuY2FsZW5kYXJUeXBlKS50b0xvY2FsZSh0aGlzLmxvY2FsVHlwZSkudG9MZWFwWWVhck1vZGUodGhpcy5sZWFwWWVhck1vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBzeW5jZWRDZWxhbmRlcihpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGlucHV0Z0RhdGVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19nRGF0ZVRvQ2FsY3VsYXRvcnMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dEYXRlVG9DYWxjdWxhdG9ycyhpbnB1dGdEYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmFsZ29yaXRobXMuY2FsY0dyZWdvcmlhbihbaW5wdXRnRGF0ZS5nZXRGdWxsWWVhcigpLCBpbnB1dGdEYXRlLmdldE1vbnRoKCksIGlucHV0Z0RhdGUuZ2V0RGF0ZSgpLCBpbnB1dGdEYXRlLmdldEhvdXJzKCksIGlucHV0Z0RhdGUuZ2V0TWludXRlcygpLCBpbnB1dGdEYXRlLmdldFNlY29uZHMoKSwgaW5wdXRnRGF0ZS5nZXRNaWxsaXNlY29uZHMoKV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gSGVscGVyIG1ldGhvZCB0aGF0IHJldHVybiBkYXRlIHJhbmdlIG5hbWUgbGlrZSB3ZWVrIGRheXMgbmFtZSwgbW9udGggbmFtZXMsIG1vbnRoIGRheXMgbmFtZXMgKHNwZWNpYWxseSBpbiBwZXJzaWFuIGNhbGVuZGFyKS5cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmFuZ2VOYW1lJyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIEhlbHBlciBtZXRob2QgdGhhdCByZXR1cm4gZGF0ZSByYW5nZSBuYW1lIGxpa2Ugd2VlayBkYXlzIG5hbWUsIG1vbnRoIG5hbWVzLCBtb250aCBkYXlzIG5hbWVzIChzcGVjaWFsbHkgaW4gcGVyc2lhbiBjYWxlbmRhcikuXG4gICAgICAgICAqIEByZXR1cm4geyp9XG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmFuZ2VOYW1lKCkge1xuICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmNhbGVuZGFyVHlwZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvY2FsVHlwZSA9PT0gJ2ZhJykge1xuICAgICAgICAgICAgICAgIGlmICh0ID09PSAncGVyc2lhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhLnBlcnNpYW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhLmdyZWdvcmlhbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0ID09PSAncGVyc2lhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuLnBlcnNpYW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuLmdyZWdvcmlhbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHNpbmNlIDEuMC4wXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAgICAgKiBAcmV0dXJuIHtQZXJzaWFuRGF0ZUNsYXNzfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9MZWFwWWVhck1vZGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9MZWFwWWVhck1vZGUoaW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMubGVhcFllYXJNb2RlID0gaW5wdXQ7XG4gICAgICAgICAgICBpZiAoaW5wdXQgPT09ICdhc3Ryb25vbWljYWwnICYmIHRoaXMuY2FsZW5kYXJUeXBlID09ICdwZXJzaWFuJykge1xuICAgICAgICAgICAgICAgIHRoaXMubGVhcFllYXJNb2RlID0gJ2FzdHJvbm9taWNhbCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0ID09PSAnYWxnb3JpdGhtaWMnICYmIHRoaXMuY2FsZW5kYXJUeXBlID09ICdwZXJzaWFuJykge1xuICAgICAgICAgICAgICAgIHRoaXMubGVhcFllYXJNb2RlID0gJ2FsZ29yaXRobWljJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWxnb3JpdGhtcy51cGRhdGVGcm9tR3JlZ29yaWFuKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgICAgICogQHJldHVybiB7UGVyc2lhbkRhdGVDbGFzc31cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvQ2FsZW5kYXInLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgICAgICogQHJldHVybiB7UGVyc2lhbkRhdGVDbGFzc31cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0NhbGVuZGFyKGlucHV0KSB7XG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyVHlwZSA9IGlucHV0O1xuICAgICAgICAgICAgdGhpcy5hbGdvcml0aG1zLnVwZGF0ZUZyb21HcmVnb3JpYW4oKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAgICAgKiBAcmV0dXJuIHtQZXJzaWFuRGF0ZUNsYXNzfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9Mb2NhbGUnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgICAgICogQHJldHVybiB7UGVyc2lhbkRhdGVDbGFzc31cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0xvY2FsZShpbnB1dCkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbFR5cGUgPSBpbnB1dDtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvY2FsVHlwZSAhPT0gJ2ZhJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0UGVyc2lhbiA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1hdFBlcnNpYW4gPSAnX2RlZmF1bHQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7Kn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19sb2NhbGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2xvY2FsZSgpIHtcbiAgICAgICAgICAgIHZhciB0ID0gdGhpcy5jYWxlbmRhclR5cGU7XG4gICAgICAgICAgICBpZiAodGhpcy5sb2NhbFR5cGUgPT09ICdmYScpIHtcbiAgICAgICAgICAgICAgICBpZiAodCA9PT0gJ3BlcnNpYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYS5wZXJzaWFuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYS5ncmVnb3JpYW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodCA9PT0gJ3BlcnNpYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbi5wZXJzaWFuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbi5ncmVnb3JpYW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3dlZWtOYW1lJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF93ZWVrTmFtZShpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZSgpLndlZWtkYXlzW2lucHV0IC0gMV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGlucHV0XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfd2Vla05hbWVTaG9ydCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2Vla05hbWVTaG9ydChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZSgpLndlZWtkYXlzU2hvcnRbaW5wdXQgLSAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ193ZWVrTmFtZU1pbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2Vla05hbWVNaW4oaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGUoKS53ZWVrZGF5c01pbltpbnB1dCAtIDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2RheU5hbWUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2RheU5hbWUoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGUoKS5wZXJzaWFuRGF5c05hbWVbaW5wdXQgLSAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19tb250aE5hbWUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX21vbnRoTmFtZShpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZSgpLm1vbnRoc1tpbnB1dCAtIDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX21vbnRoTmFtZVNob3J0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tb250aE5hbWVTaG9ydChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZSgpLm1vbnRoc1Nob3J0W2lucHV0IC0gMV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIG9ialxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2lzUGVyc2lhbkRhdGUnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBvYmpcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1BlcnNpYW5EYXRlKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIFBlcnNpYW5EYXRlQ2xhc3M7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMge1BlcnNpYW5EYXRlfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2xvbmUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U3luY2VkQ2xhc3ModGhpcy5TdGF0ZS5nRGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHNpbmNlIDEuMC4wXG4gICAgICAgICAqIEBwYXJhbSBkYXRlQXJyYXlcbiAgICAgICAgICogQHJldHVybiB7Kn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FsZ29yaXRobXNDYWxjJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFsZ29yaXRobXNDYWxjKGRhdGVBcnJheSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNQZXJzaWFuRGF0ZShkYXRlQXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgZGF0ZUFycmF5ID0gW2RhdGVBcnJheS55ZWFyKCksIGRhdGVBcnJheS5tb250aCgpLCBkYXRlQXJyYXkuZGF0ZSgpLCBkYXRlQXJyYXkuaG91cigpLCBkYXRlQXJyYXkubWludXRlKCksIGRhdGVBcnJheS5zZWNvbmQoKSwgZGF0ZUFycmF5Lm1pbGxpc2Vjb25kKCldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY2FsZW5kYXJUeXBlID09PSAncGVyc2lhbicgJiYgdGhpcy5sZWFwWWVhck1vZGUgPT0gJ2FsZ29yaXRobWljJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFsZ29yaXRobXMuY2FsY1BlcnNpYW4oZGF0ZUFycmF5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5jYWxlbmRhclR5cGUgPT09ICdwZXJzaWFuJyAmJiB0aGlzLmxlYXBZZWFyTW9kZSA9PSAnYXN0cm9ub21pY2FsJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFsZ29yaXRobXMuY2FsY1BlcnNpYW5hKGRhdGVBcnJheSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2FsZW5kYXJUeXBlID09PSAnZ3JlZ29yaWFuJykge1xuICAgICAgICAgICAgICAgIGRhdGVBcnJheVsxXSA9IGRhdGVBcnJheVsxXSAtIDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxnb3JpdGhtcy5jYWxjR3JlZ29yaWFuKGRhdGVBcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHNpbmNlIDEuMC4wXG4gICAgICAgICAqIEByZXR1cm4geyp9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjYWxlbmRhcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxlbmRhcigpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAodGhpcy5jYWxlbmRhclR5cGUgPT0gJ3BlcnNpYW4nKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVhcFllYXJNb2RlID09ICdhc3Ryb25vbWljYWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9ICdwZXJzaWFuQXN0cm8nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5sZWFwWWVhck1vZGUgPT0gJ2FsZ29yaXRobWljJykge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSAncGVyc2lhbkFsZ28nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAga2V5ID0gJ2dyZWdvcmlhbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5TdGF0ZVtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiByZXR1cm4gRHVyYXRpb24gb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAgICAgKiBAcGFyYW0ga2V5XG4gICAgICAgICAqIEByZXR1cm5zIHtEdXJhdGlvbn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2R1cmF0aW9uJyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gcmV0dXJuIER1cmF0aW9uIG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgICAgICogQHBhcmFtIGtleVxuICAgICAgICAgKiBAcmV0dXJucyB7RHVyYXRpb259XG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZHVyYXRpb24oaW5wdXQsIGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbihpbnB1dCwga2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gY2hlY2sgaWYgcGFzc2VkIG9iamVjdCBpcyBkdXJhdGlvblxuICAgICAgICAgKiBAcGFyYW0gb2JqXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXNEdXJhdGlvbicsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIGNoZWNrIGlmIHBhc3NlZCBvYmplY3QgaXMgZHVyYXRpb25cbiAgICAgICAgICogQHBhcmFtIG9ialxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0R1cmF0aW9uKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIER1cmF0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3llYXJzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHllYXJzKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55ZWFyKGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd5ZWFyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHllYXIoaW5wdXQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dCB8fCBpbnB1dCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWxnb3JpdGhtc0NhbGMoW2lucHV0LCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpLCB0aGlzLmhvdXIoKSwgdGhpcy5taW51dGUoKSwgdGhpcy5zZWNvbmQoKSwgdGhpcy5taWxsaXNlY29uZCgpXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyKCkueWVhcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdtb250aCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtb250aChpbnB1dCkge1xuICAgICAgICAgICAgaWYgKGlucHV0IHx8IGlucHV0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGdvcml0aG1zQ2FsYyhbdGhpcy55ZWFyKCksIGlucHV0LCB0aGlzLmRhdGUoKV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhcigpLm1vbnRoICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEYXkgb2Ygd2Vla1xuICAgICAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258RGF0ZS50b0pTT04uZGF5fGRhdGVfanNvbi5kYXl8UGVyc2lhbkRhdGUuZGF5fGRheXxvdXRwdXQuZGF5fCp9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkYXlzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRheXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258RGF0ZS50b0pTT04uZGF5fGRhdGVfanNvbi5kYXl8UGVyc2lhbkRhdGUuZGF5fGRheXxvdXRwdXQuZGF5fCp9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkYXknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGF5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXIoKS53ZWVrZGF5O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERheSBvZiBNb250aHNcbiAgICAgICAgICogQHBhcmFtIGlucHV0XG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGF0ZXMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGF0ZXMoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGUoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2RhdGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGF0ZShpbnB1dCkge1xuICAgICAgICAgICAgaWYgKGlucHV0IHx8IGlucHV0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGdvcml0aG1zQ2FsYyhbdGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgaW5wdXRdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXIoKS5kYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGlucHV0XG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaG91cicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBob3VyKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ob3VycyhpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGlucHV0XG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaG91cnMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaG91cnMoaW5wdXQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dCB8fCBpbnB1dCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dCA9IDI0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmFsZ29yaXRobXNDYWxjKFt0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSwgaW5wdXRdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuU3RhdGUuZ0RhdGUuZ2V0SG91cnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdtaW51dGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbWludXRlKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5taW51dGVzKGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdtaW51dGVzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1pbnV0ZXMoaW5wdXQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dCB8fCBpbnB1dCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWxnb3JpdGhtc0NhbGMoW3RoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpLCB0aGlzLmhvdXIoKSwgaW5wdXRdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuU3RhdGUuZ0RhdGUuZ2V0TWludXRlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NlY29uZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZWNvbmQoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlY29uZHMoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NlY29uZHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2Vjb25kcyhpbnB1dCkge1xuICAgICAgICAgICAgaWYgKGlucHV0IHx8IGlucHV0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGdvcml0aG1zQ2FsYyhbdGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCksIHRoaXMuaG91cigpLCB0aGlzLm1pbnV0ZSgpLCBpbnB1dF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5TdGF0ZS5nRGF0ZS5nZXRTZWNvbmRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGlucHV0XG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICAgKiBHZXR0ZXIgU2V0dGVyXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdtaWxsaXNlY29uZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtaWxsaXNlY29uZChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmRzKGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdtaWxsaXNlY29uZHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbWlsbGlzZWNvbmRzKGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQgfHwgaW5wdXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFsZ29yaXRobXNDYWxjKFt0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSwgdGhpcy5ob3VyKCksIHRoaXMubWludXRlKCksIHRoaXMuc2Vjb25kKCksIGlucHV0XSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlN0YXRlLmdyZWdvcmlhbi5taWxsaXNlY29uZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gTWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBVbml4IEVwb2NoICgxMzE4ODc0Mzk4ODA2KVxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIC8vICAgIF92YWx1ZU9mICgpIHtcbiAgICAgICAgLy8gICAgICAgIHJldHVybiB0aGlzLlN0YXRlLmdEYXRlLnZhbHVlT2YoKTtcbiAgICAgICAgLy8gICAgfVxuXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3VuaXgnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiBVbml4IFRpbWVzdGFtcCAoMTMxODg3NDM5OClcbiAgICAgICAgICogQHBhcmFtIHRpbWVzdGFtcFxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB1bml4KHRpbWVzdGFtcCkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh0aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U3luY2VkQ2xhc3ModGltZXN0YW1wICogMTAwMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzdHIgPSB0aGlzLlN0YXRlLmdEYXRlLnZhbHVlT2YoKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG91dHB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd2YWx1ZU9mJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlT2YoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5TdGF0ZS5nRGF0ZS52YWx1ZU9mKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHllYXJcbiAgICAgICAgICogQHBhcmFtIG1vbnRoXG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldEZpcnN0V2Vla0RheU9mTW9udGgnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB5ZWFyXG4gICAgICAgICAqIEBwYXJhbSBtb250aFxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICogQHNpbmNlIDEuMC4wXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rmlyc3RXZWVrRGF5T2ZNb250aCh5ZWFyLCBtb250aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFN5bmNlZENsYXNzKFt5ZWFyLCBtb250aCwgMV0pLmRheSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAgICAgKiBAcGFyYW0gdmFsXG4gICAgICAgICAqIEBwYXJhbSBhc0Zsb2F0XG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGlmZicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaWZmKGlucHV0LCB2YWwsIGFzRmxvYXQpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgICAgICBpbnB1dE1vbWVudCA9IGlucHV0LFxuICAgICAgICAgICAgICAgIHpvbmVEaWZmID0gMCxcbiAgICAgICAgICAgICAgICBkaWZmID0gc2VsZi5TdGF0ZS5nRGF0ZSAtIGlucHV0TW9tZW50LnRvRGF0ZSgpIC0gem9uZURpZmYsXG4gICAgICAgICAgICAgICAgeWVhciA9IHNlbGYueWVhcigpIC0gaW5wdXRNb21lbnQueWVhcigpLFxuICAgICAgICAgICAgICAgIG1vbnRoID0gc2VsZi5tb250aCgpIC0gaW5wdXRNb21lbnQubW9udGgoKSxcbiAgICAgICAgICAgICAgICBkYXRlID0gKHNlbGYuZGF0ZSgpIC0gaW5wdXRNb21lbnQuZGF0ZSgpKSAqIC0xLFxuICAgICAgICAgICAgICAgIG91dHB1dCA9IHZvaWQgMDtcblxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gJ21vbnRocycgfHwgdmFsID09PSAnbW9udGgnKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0geWVhciAqIDEyICsgbW9udGggKyBkYXRlIC8gMzA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbCA9PT0gJ3llYXJzJyB8fCB2YWwgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IHllYXIgKyAobW9udGggKyBkYXRlIC8gMzApIC8gMTI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IHZhbCA9PT0gJ3NlY29uZHMnIHx8IHZhbCA9PT0gJ3NlY29uZCcgPyBkaWZmIC8gMWUzIDogLy8gMTAwMFxuICAgICAgICAgICAgICAgIHZhbCA9PT0gJ21pbnV0ZXMnIHx8IHZhbCA9PT0gJ21pbnV0ZScgPyBkaWZmIC8gNmU0IDogLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICAgICAgdmFsID09PSAnaG91cnMnIHx8IHZhbCA9PT0gJ2hvdXInID8gZGlmZiAvIDM2ZTUgOiAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAgICAgICAgIHZhbCA9PT0gJ2RheXMnIHx8IHZhbCA9PT0gJ2RheScgPyBkaWZmIC8gODY0ZTUgOiAvLyAxMDAwICogNjAgKiA2MCAqIDI0XG4gICAgICAgICAgICAgICAgdmFsID09PSAnd2Vla3MnIHx8IHZhbCA9PT0gJ3dlZWsnID8gZGlmZiAvIDYwNDhlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3XG4gICAgICAgICAgICAgICAgZGlmZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhc0Zsb2F0ID8gb3V0cHV0IDogTWF0aC5yb3VuZChvdXRwdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBrZXlcbiAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzdGFydE9mJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0T2Yoa2V5KSB7XG4gICAgICAgICAgICB2YXIgc3luY2VkQ2VsYW5kZXIgPSBQZXJzaWFuRGF0ZUNsYXNzLnRvQ2FsZW5kYXIodGhpcy5jYWxlbmRhclR5cGUpLnRvTG9jYWxlKHRoaXMubG9jYWxUeXBlKTtcbiAgICAgICAgICAgIHZhciBuZXdBcnJheSA9IG5ldyBQZXJzaWFuRGF0ZUNsYXNzKHRoaXMudmFsdWVPZigpIC0gKHRoaXMuY2FsZW5kYXIoKS53ZWVrZGF5IC0gMSkgKiA4NjQwMDAwMCkudG9BcnJheSgpO1xuICAgICAgICAgICAgLy8gU2ltcGxpZnkgdGhpc1xcXG4gICAgICAgICAgICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4gICAgICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3llYXJzJzpcbiAgICAgICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzeW5jZWRDZWxhbmRlcihbdGhpcy55ZWFyKCksIDEsIDFdKTtcbiAgICAgICAgICAgICAgICBjYXNlICdtb250aHMnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzeW5jZWRDZWxhbmRlcihbdGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgMV0pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RheXMnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3luY2VkQ2VsYW5kZXIoW3RoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpLCAwLCAwLCAwXSk7XG4gICAgICAgICAgICAgICAgY2FzZSAnaG91cnMnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN5bmNlZENlbGFuZGVyKFt0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSwgdGhpcy5ob3VycygpLCAwLCAwXSk7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWludXRlcyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzeW5jZWRDZWxhbmRlcihbdGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCksIHRoaXMuaG91cnMoKSwgdGhpcy5taW51dGVzKCksIDBdKTtcbiAgICAgICAgICAgICAgICBjYXNlICdzZWNvbmRzJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN5bmNlZENlbGFuZGVyKFt0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSwgdGhpcy5ob3VycygpLCB0aGlzLm1pbnV0ZXMoKSwgdGhpcy5zZWNvbmRzKCldKTtcbiAgICAgICAgICAgICAgICBjYXNlICd3ZWVrcyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3luY2VkQ2VsYW5kZXIobmV3QXJyYXkpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBrZXlcbiAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAqL1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jYXNlLWRlY2xhcmF0aW9ucyAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdlbmRPZicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbmRPZihrZXkpIHtcbiAgICAgICAgICAgIHZhciBzeW5jZWRDZWxhbmRlciA9IFBlcnNpYW5EYXRlQ2xhc3MudG9DYWxlbmRhcih0aGlzLmNhbGVuZGFyVHlwZSkudG9Mb2NhbGUodGhpcy5sb2NhbFR5cGUpO1xuICAgICAgICAgICAgLy8gU2ltcGxpZnkgdGhpc1xuICAgICAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd5ZWFycyc6XG4gICAgICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXlzID0gdGhpcy5pc0xlYXBZZWFyKCkgPyAzMCA6IDI5O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN5bmNlZENlbGFuZGVyKFt0aGlzLnllYXIoKSwgMTIsIGRheXMsIDIzLCA1OSwgNTldKTtcbiAgICAgICAgICAgICAgICBjYXNlICdtb250aHMnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vbnRoRGF5cyA9IHRoaXMuZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3luY2VkQ2VsYW5kZXIoW3RoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIG1vbnRoRGF5cywgMjMsIDU5LCA1OV0pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RheXMnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3luY2VkQ2VsYW5kZXIoW3RoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpLCAyMywgNTksIDU5XSk7XG4gICAgICAgICAgICAgICAgY2FzZSAnaG91cnMnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN5bmNlZENlbGFuZGVyKFt0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSwgdGhpcy5ob3VycygpLCA1OSwgNTldKTtcbiAgICAgICAgICAgICAgICBjYXNlICdtaW51dGVzJzpcbiAgICAgICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN5bmNlZENlbGFuZGVyKFt0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSwgdGhpcy5ob3VycygpLCB0aGlzLm1pbnV0ZXMoKSwgNTldKTtcbiAgICAgICAgICAgICAgICBjYXNlICdzZWNvbmRzJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN5bmNlZENlbGFuZGVyKFt0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSwgdGhpcy5ob3VycygpLCB0aGlzLm1pbnV0ZXMoKSwgdGhpcy5zZWNvbmRzKCldKTtcbiAgICAgICAgICAgICAgICBjYXNlICd3ZWVrcyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgICAgIHZhciB3ZWVrRGF5TnVtYmVyID0gdGhpcy5jYWxlbmRhcigpLndlZWtkYXk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3luY2VkQ2VsYW5kZXIoW3RoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpICsgKDcgLSB3ZWVrRGF5TnVtYmVyKV0pO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNhc2UtZGVjbGFyYXRpb25zICovXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzb2QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc29kKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZignZGF5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdlb2QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZW9kKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5kT2YoJ2RheScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEdldCB0aGUgdGltZXpvbmUgb2Zmc2V0IGluIG1pbnV0ZXMuXG4gICAgICAgICAqIEByZXR1cm4geyp9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd6b25lJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHpvbmUoaW5wdXQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dCB8fCBpbnB1dCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuU3RhdGUuem9uZSA9IGlucHV0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5TdGF0ZS56b25lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtQZXJzaWFuRGF0ZX1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2xvY2FsJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxvY2FsKCkge1xuICAgICAgICAgICAgdmFyIHV0Y1N0YW1wID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3V0Y01vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgVGhhdERheU9mZnNldCA9IG5ldyBEYXRlKHRoaXMudG9EYXRlKCkpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldE1pbHMgPSBUaGF0RGF5T2Zmc2V0ICogNjAgKiAxMDAwO1xuICAgICAgICAgICAgICAgIGlmIChUaGF0RGF5T2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB1dGNTdGFtcCA9IHRoaXMudmFsdWVPZigpIC0gb2Zmc2V0TWlscztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgICAgICB1dGNTdGFtcCA9IHRoaXMudmFsdWVPZigpICsgb2Zmc2V0TWlscztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50b0NhbGVuZGFyKFBlcnNpYW5EYXRlQ2xhc3MuY2FsZW5kYXJUeXBlKTtcbiAgICAgICAgICAgICAgICB2YXIgdXRjRGF0ZSA9IG5ldyBEYXRlKHV0Y1N0YW1wKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9nRGF0ZVRvQ2FsY3VsYXRvcnModXRjRGF0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXRjTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuem9uZShUaGF0RGF5T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGlucHV0XG4gICAgICAgICAqIEByZXR1cm4geyp9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd1dGMnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBDdXJyZW50IGRhdGUvdGltZSBpbiBVVEMgbW9kZVxuICAgICAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdXRjKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgdXRjU3RhbXAgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U3luY2VkQ2xhc3MoaW5wdXQpLnV0YygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3V0Y01vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldE1pbHMgPSB0aGlzLnpvbmUoKSAqIDYwICogMTAwMDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy56b25lKCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHV0Y1N0YW1wID0gdGhpcy52YWx1ZU9mKCkgKyBvZmZzZXRNaWxzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgIHV0Y1N0YW1wID0gdGhpcy52YWx1ZU9mKCkgLSBvZmZzZXRNaWxzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdXRjRGF0ZSA9IG5ldyBEYXRlKHV0Y1N0YW1wKSxcbiAgICAgICAgICAgICAgICAgICAgZCA9IHRoaXMuX2dldFN5bmNlZENsYXNzKHV0Y0RhdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWxnb3JpdGhtc0NhbGMoZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXRjTW9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy56b25lKDApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXNVdGMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNVdGMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXRjTW9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICogQGxpbmsgaHR0cHM6Ly9mYS53aWtpcGVkaWEub3JnL3dpa2kvJUQ4JUIzJUQ4JUE3JUQ4JUI5JUQ4JUFBXyVEOCVBQSVEOCVBNyVEOCVBOCVEOCVCMyVEOCVBQSVEOCVBNyVEOSU4NiVEQiU4Q1xuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXNEU1QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNEU1QoKSB7XG4gICAgICAgICAgICB2YXIgbW9udGggPSB0aGlzLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgZGF5ID0gdGhpcy5kYXRlKCk7XG4gICAgICAgICAgICBpZiAobW9udGggPT0gMSAmJiBkYXkgPiAxIHx8IG1vbnRoID09IDYgJiYgZGF5IDwgMzEgfHwgbW9udGggPCA2ICYmIG1vbnRoID49IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXNMZWFwWWVhcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICAgICAgICAgIGlmICh5ZWFyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB5ZWFyID0gdGhpcy55ZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jYWxlbmRhclR5cGUgPT0gJ3BlcnNpYW4nICYmIHRoaXMubGVhcFllYXJNb2RlID09PSAnYWxnb3JpdGhtaWMnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxnb3JpdGhtcy5sZWFwX3BlcnNpYW4oeWVhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jYWxlbmRhclR5cGUgPT0gJ3BlcnNpYW4nICYmIHRoaXMubGVhcFllYXJNb2RlID09PSAnYXN0cm9ub21pY2FsJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFsZ29yaXRobXMubGVhcF9wZXJzaWFuYSh5ZWFyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5jYWxlbmRhclR5cGUgPT0gJ2dyZWdvcmlhbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hbGdvcml0aG1zLmxlYXBfZ3JlZ29yaWFuKHllYXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB5ZWFySW5wdXRcbiAgICAgICAgICogQHBhcmFtIG1vbnRoSW5wdXRcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2RheXNJbk1vbnRoJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXJJbnB1dCwgbW9udGhJbnB1dCkge1xuICAgICAgICAgICAgdmFyIHllYXIgPSB5ZWFySW5wdXQgPyB5ZWFySW5wdXQgOiB0aGlzLnllYXIoKSxcbiAgICAgICAgICAgICAgICBtb250aCA9IG1vbnRoSW5wdXQgPyBtb250aElucHV0IDogdGhpcy5tb250aCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FsZW5kYXJUeXBlID09PSAncGVyc2lhbicpIHtcbiAgICAgICAgICAgICAgICBpZiAobW9udGggPCAxIHx8IG1vbnRoID4gMTIpIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIGlmIChtb250aCA8IDcpIHJldHVybiAzMTtcbiAgICAgICAgICAgICAgICBpZiAobW9udGggPCAxMikgcmV0dXJuIDMwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzTGVhcFllYXIoeWVhcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDMwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gMjk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jYWxlbmRhclR5cGUgPT09ICdncmVnb3JpYW4nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHllYXIsIG1vbnRoLCAwKS5nZXREYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIFJldHVybiBOYXRpdmUgSmF2YXNjcmlwdCBEYXRlXG4gICAgICAgICAqIEByZXR1cm5zIHsqfFBlcnNpYW5EYXRlLmdEYXRlfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9EYXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvRGF0ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLlN0YXRlLmdEYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIEFycmF5IE9mIFBlcnNpYW4gRGF0ZVxuICAgICAgICAgKiBAcmV0dXJucyB7YXJyYXl9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0FycmF5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpLCB0aGlzLmhvdXIoKSwgdGhpcy5taW51dGUoKSwgdGhpcy5zZWNvbmQoKSwgdGhpcy5taWxsaXNlY29uZCgpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zvcm1hdE51bWJlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXROdW1iZXIoKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBpZiBkZWZhdWx0IGNvbmYgZG9zZW50IHNldCBmb2xsb3cgZ29sYmFsIGNvbmZpZ1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9ybWF0UGVyc2lhbiA9PT0gJ19kZWZhdWx0Jykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmZvcm1hdFBlcnNpYW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgQ29uZlxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5mb3JtYXRQZXJzaWFuID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IENvbmZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZvcm1hdFBlcnNpYW4gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZm9ybWF0UGVyc2lhbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgRXJyb3IoJ0ludmFsaWQgQ29uZmlnIFwiZm9ybWF0UGVyc2lhblwiICEhJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gaW5wdXRTdHJpbmdcbiAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmb3JtYXQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KGlucHV0U3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5TdGF0ZS5pc0ludmFsaWREYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGZvcm1hdHRpbmdUb2tlbnMgPSAvKFtbXltdKl0pfChcXFxcKT8oTW98TU0/TT9NP3xEb3xERD9EP0Q/fGRkZGRkZD98ZGRkZGQ/fGRkZGQ/fGRvP3x3W298d10/fFlZWVl8WVl8YXxBfGhoP3xISD98bW0/fHNzP3xTUz9TP3x6ej98Wlo/fFh8TFR8bGw/bD9sP3xMTD9MP0w/KS9nLFxuICAgICAgICAgICAgICAgIGluZm8gPSB7XG4gICAgICAgICAgICAgICAgeWVhcjogc2VsZi55ZWFyKCksXG4gICAgICAgICAgICAgICAgbW9udGg6IHNlbGYubW9udGgoKSxcbiAgICAgICAgICAgICAgICBob3VyOiBzZWxmLmhvdXJzKCksXG4gICAgICAgICAgICAgICAgbWludXRlOiBzZWxmLm1pbnV0ZXMoKSxcbiAgICAgICAgICAgICAgICBzZWNvbmQ6IHNlbGYuc2Vjb25kcygpLFxuICAgICAgICAgICAgICAgIGRhdGU6IHNlbGYuZGF0ZSgpLFxuICAgICAgICAgICAgICAgIHRpbWV6b25lOiBzZWxmLnpvbmUoKSxcbiAgICAgICAgICAgICAgICB1bml4OiBzZWxmLnVuaXgoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmb3JtYXRUb1BlcnNpYW4gPSBzZWxmLmZvcm1hdE51bWJlcigpO1xuXG4gICAgICAgICAgICB2YXIgY2hlY2tQZXJzaWFuID0gZnVuY3Rpb24gY2hlY2tQZXJzaWFuKGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0VG9QZXJzaWFuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b1BlcnNpYW5EaWdpdChpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4gICAgICAgICAgICBmdW5jdGlvbiByZXBsYWNlRnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFNL1BNXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3JtYXRUb1BlcnNpYW4pIHJldHVybiBpbmZvLmhvdXIgPj0gMTIgPyAn2Kgg2LgnIDogJ9mCINi4JztlbHNlIHJldHVybiBpbmZvLmhvdXIgPj0gMTIgPyAnUE0nIDogJ0FNJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSG91cnMgKEludClcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUGVyc2lhbihpbmZvLmhvdXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdISCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUGVyc2lhbihsZWZ0WmVyb0ZpbGwoaW5mby5ob3VyLCAyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVja1BlcnNpYW4oaW5mby5ob3VyICUgMTIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdoaCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUGVyc2lhbihsZWZ0WmVyb0ZpbGwoaW5mby5ob3VyICUgMTIsIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gTWludXRlc1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tQZXJzaWFuKGxlZnRaZXJvRmlsbChpbmZvLm1pbnV0ZSwgMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUd28gRGlnaXQgTWludXRlc1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUGVyc2lhbihsZWZ0WmVyb0ZpbGwoaW5mby5taW51dGUsIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gU2Vjb25kXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVja1BlcnNpYW4oaW5mby5zZWNvbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzcyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUGVyc2lhbihsZWZ0WmVyb0ZpbGwoaW5mby5zZWNvbmQsIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRGF5IChJbnQpXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVja1BlcnNpYW4obGVmdFplcm9GaWxsKGluZm8uZGF0ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gVHdvIERpZ2l0XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0REJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tQZXJzaWFuKGxlZnRaZXJvRmlsbChpbmZvLmRhdGUsIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIGRheSBPZiBNb250aFxuICAgICAgICAgICAgICAgICAgICBjYXNlICdEREQnOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gc2VsZi5zdGFydE9mKCd5ZWFyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUGVyc2lhbihsZWZ0WmVyb0ZpbGwoc2VsZi5kaWZmKHQsICdkYXlzJyksIDMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIERheSBvZiBZZWFyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0REREQnOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdCA9IHNlbGYuc3RhcnRPZigneWVhcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVja1BlcnNpYW4obGVmdFplcm9GaWxsKHNlbGYuZGlmZihfdCwgJ2RheXMnKSwgMykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gZGF5IE9mIHdlZWtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUGVyc2lhbihzZWxmLmNhbGVuZGFyKCkud2Vla2RheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiB3ZWVrIGRheSBuYW1lIGFiYnJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGRkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fd2Vla05hbWVTaG9ydChzZWxmLmNhbGVuZGFyKCkud2Vla2RheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RkZGQnOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl93ZWVrTmFtZShzZWxmLmNhbGVuZGFyKCkud2Vla2RheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBQZXJzaWFuIERheSBOYW1lXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RkZGRkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fZGF5TmFtZShzZWxmLmNhbGVuZGFyKCkuZGF5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIFBlcnNpYW4gRGF5IE5hbWVcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGRkZGRkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fd2Vla05hbWVNaW4oc2VsZi5jYWxlbmRhcigpLndlZWtkYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gUGVyc2lhbiBEYXkgTmFtZVxuICAgICAgICAgICAgICAgICAgICBjYXNlICd3JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3QyID0gc2VsZi5zdGFydE9mKCd5ZWFyJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheSA9IHBhcnNlSW50KHNlbGYuZGlmZihfdDIsICdkYXlzJykgLyA3KSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUGVyc2lhbihkYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gUGVyc2lhbiBEYXkgTmFtZVxuICAgICAgICAgICAgICAgICAgICBjYXNlICd3dyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90MyA9IHNlbGYuc3RhcnRPZigneWVhcicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZGF5ID0gbGVmdFplcm9GaWxsKHBhcnNlSW50KHNlbGYuZGlmZihfdDMsICdkYXlzJykgLyA3KSArIDEsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVja1BlcnNpYW4oX2RheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vbnRoICAoSW50KVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tQZXJzaWFuKGluZm8ubW9udGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUd28gRGlnaXQgTW9udGggKFN0cilcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTU0nOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVja1BlcnNpYW4obGVmdFplcm9GaWxsKGluZm8ubW9udGgsIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQWJiciBTdHJpbmcgb2YgTW9udGggKFN0cilcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTU1NJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fbW9udGhOYW1lU2hvcnQoaW5mby5tb250aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEZ1bGwgU3RyaW5nIG5hbWUgb2YgTW9udGggKFN0cilcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTU1NTSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX21vbnRoTmFtZShpbmZvLm1vbnRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gWWVhclxuICAgICAgICAgICAgICAgICAgICAvLyBUd28gRGlnaXQgWWVhciAoU3RyKVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdZWSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHllYXJEaWdpdEFycmF5ID0gaW5mby55ZWFyLnRvU3RyaW5nKCkuc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVja1BlcnNpYW4oeWVhckRpZ2l0QXJyYXlbMl0gKyB5ZWFyRGlnaXRBcnJheVszXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEZ1bGwgWWVhciAoSW50KVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdZWVlZJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tQZXJzaWFuKGluZm8ueWVhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbGFnID0gJysnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3VycyA9IE1hdGgucm91bmQoaW5mby50aW1lem9uZSAvIDYwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWludXRlcyA9IGluZm8udGltZXpvbmUgJSA2MDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaW51dGVzIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW51dGVzICo9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG91cnMgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsYWcgPSAnLSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvdXJzICo9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB6ID0gZmxhZyArIGxlZnRaZXJvRmlsbChob3VycywgMikgKyAnOicgKyBsZWZ0WmVyb0ZpbGwobWludXRlcywgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUGVyc2lhbih6KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnWlonOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZmxhZyA9ICcrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hvdXJzID0gTWF0aC5yb3VuZChpbmZvLnRpbWV6b25lIC8gNjApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbWludXRlcyA9IGluZm8udGltZXpvbmUgJSA2MDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbWludXRlcyA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX21pbnV0ZXMgKj0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaG91cnMgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbGFnID0gJy0nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaG91cnMgKj0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfeiA9IF9mbGFnICsgbGVmdFplcm9GaWxsKF9ob3VycywgMikgKyAnJyArIGxlZnRaZXJvRmlsbChfbWludXRlcywgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUGVyc2lhbihfeik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnVuaXgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gODozMCBQTVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdMVCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZm9ybWF0KCdIOm0gYScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyAwOS8wNC8xOTg2XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmZvcm1hdCgnWVlZWS9NTS9ERCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyA5LzQvMTk4NlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5mb3JtYXQoJ1lZWVkvTS9EJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlcHRlbWJlciA0dGggMTk4NlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdMTCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZm9ybWF0KCdNTU1NIEREIFlZWVknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gU2VwIDQgMTk4NlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdsbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZm9ybWF0KCdNTU0gREQgWVlZWScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL1NlcHRlbWJlciA0dGggMTk4NiA4OjMwIFBNXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0xMTCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZm9ybWF0KCdNTU1NIFlZWVkgREQgICBIOm0gIGEnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gU2VwIDQgMTk4NiA4OjMwIFBNXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xsbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZm9ybWF0KCdNTU0gWVlZWSBERCAgIEg6bSAgYScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL1RodXJzZGF5LCBTZXB0ZW1iZXIgNHRoIDE5ODYgODozMCBQTVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdMTExMJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5mb3JtYXQoJ2RkZGQgRCBNTU1NIFlZWVkgIEg6bSAgYScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUaHUsIFNlcCA0IDE5ODYgODozMCBQTVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdsbGxsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5mb3JtYXQoJ2RkZCBEIE1NTSBZWVlZICBIOm0gIGEnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cbiAgICAgICAgICAgIGlmIChpbnB1dFN0cmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dFN0cmluZy5yZXBsYWNlKGZvcm1hdHRpbmdUb2tlbnMsIHJlcGxhY2VGdW5jdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBfaW5wdXRTdHJpbmcgPSAnWVlZWS1NTS1ERCBISDptbTpzcyBhJztcbiAgICAgICAgICAgICAgICByZXR1cm4gX2lucHV0U3RyaW5nLnJlcGxhY2UoZm9ybWF0dGluZ1Rva2VucywgcmVwbGFjZUZ1bmN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ga2V5XG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJucyB7UGVyc2lhbkRhdGV9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdhZGQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHVuaXQgPSBub3JtYWxpemVEdXJhdGlvbihrZXksIHZhbHVlKS51bml0LFxuICAgICAgICAgICAgICAgIGFyciA9IHRoaXMudG9BcnJheSgpO1xuICAgICAgICAgICAgdmFsdWUgPSBub3JtYWxpemVEdXJhdGlvbihrZXksIHZhbHVlKS52YWx1ZTtcbiAgICAgICAgICAgIGlmICh1bml0ID09PSAneWVhcicpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplZERhdGUgPSBhcnJbMl0sXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoRGF5cyA9IHRoaXMuZGF5c0luTW9udGgoYXJyWzBdICsgdmFsdWUsIGFyclsxXSk7XG4gICAgICAgICAgICAgICAgaWYgKGFyclsyXSA+IG1vbnRoRGF5cykge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkRGF0ZSA9IG1vbnRoRGF5cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBEYXRlID0gbmV3IFBlcnNpYW5EYXRlQ2xhc3MoW2FyclswXSArIHZhbHVlLCBhcnJbMV0sIG5vcm1hbGl6ZWREYXRlLCBhcnJbM10sIGFycls0XSwgYXJyWzVdLCBhcnJbNl0sIGFycls3XV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZW1wRGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bml0ID09PSAnbW9udGgnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBZZWFyID0gTWF0aC5mbG9vcih2YWx1ZSAvIDEyKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVtYWluaW5nTW9udGggPSB2YWx1ZSAtIHRlbXBZZWFyICogMTIsXG4gICAgICAgICAgICAgICAgICAgIGNhbGNlZE1vbnRoID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoYXJyWzFdICsgcmVtYWluaW5nTW9udGggPiAxMikge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wWWVhciArPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYWxjZWRNb250aCA9IGFyclsxXSArIHJlbWFpbmluZ01vbnRoIC0gMTI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsY2VkTW9udGggPSBhcnJbMV0gKyByZW1haW5pbmdNb250aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6YWVkRGF0ZSA9IGFyclsyXSxcbiAgICAgICAgICAgICAgICAgICAgdGVtcERhdGVBcnJheSA9IG5ldyBQZXJzaWFuRGF0ZUNsYXNzKFthcnJbMF0gKyB0ZW1wWWVhciwgY2FsY2VkTW9udGgsIDEsIGFyclszXSwgYXJyWzRdLCBhcnJbNV0sIGFycls2XSwgYXJyWzddXSkudG9BcnJheSgpLFxuICAgICAgICAgICAgICAgICAgICBfbW9udGhEYXlzID0gdGhpcy5kYXlzSW5Nb250aChhcnJbMF0gKyB0ZW1wWWVhciwgY2FsY2VkTW9udGgpO1xuICAgICAgICAgICAgICAgIGlmIChhcnJbMl0gPiBfbW9udGhEYXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6YWVkRGF0ZSA9IF9tb250aERheXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUGVyc2lhbkRhdGVDbGFzcyhbdGVtcERhdGVBcnJheVswXSwgdGVtcERhdGVBcnJheVsxXSwgbm9ybWFsaXphZWREYXRlLCB0ZW1wRGF0ZUFycmF5WzNdLCB0ZW1wRGF0ZUFycmF5WzRdLCB0ZW1wRGF0ZUFycmF5WzVdLCB0ZW1wRGF0ZUFycmF5WzZdLCB0ZW1wRGF0ZUFycmF5WzddXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5pdCA9PT0gJ2RheScpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FsY2VkRGF5ID0gbmV3IFBlcnNpYW5EYXRlQ2xhc3ModGhpcy52YWx1ZU9mKCkpLmhvdXIoMTIpLFxuICAgICAgICAgICAgICAgICAgICBuZXdNaWxsaXNlY29uZCA9IGNhbGNlZERheS52YWx1ZU9mKCkgKyB2YWx1ZSAqIDg2NDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBuZXdEYXRlID0gbmV3IFBlcnNpYW5EYXRlQ2xhc3MobmV3TWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdEYXRlLmhvdXIoYXJyWzNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bml0ID09PSAnd2VlaycpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2NhbGNlZERheSA9IG5ldyBQZXJzaWFuRGF0ZUNsYXNzKHRoaXMudmFsdWVPZigpKS5ob3VyKDEyKSxcbiAgICAgICAgICAgICAgICAgICAgX25ld01pbGxpc2Vjb25kID0gX2NhbGNlZERheS52YWx1ZU9mKCkgKyA3ICogdmFsdWUgKiA4NjQwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgX25ld0RhdGUgPSBuZXcgUGVyc2lhbkRhdGVDbGFzcyhfbmV3TWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfbmV3RGF0ZS5ob3VyKGFyclszXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5pdCA9PT0gJ2hvdXInKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9uZXdNaWxsaXNlY29uZDIgPSB0aGlzLnZhbHVlT2YoKSArIHZhbHVlICogMzYwMDAwMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bml4KF9uZXdNaWxsaXNlY29uZDIgLyAxMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bml0ID09PSAnbWludXRlJykge1xuICAgICAgICAgICAgICAgIHZhciBfbmV3TWlsbGlzZWNvbmQzID0gdGhpcy52YWx1ZU9mKCkgKyB2YWx1ZSAqIDYwMDAwO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaXgoX25ld01pbGxpc2Vjb25kMyAvIDEwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuaXQgPT09ICdzZWNvbmQnKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9uZXdNaWxsaXNlY29uZDQgPSB0aGlzLnZhbHVlT2YoKSArIHZhbHVlICogMTAwMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bml4KF9uZXdNaWxsaXNlY29uZDQgLyAxMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bml0ID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9uZXdNaWxsaXNlY29uZDUgPSB0aGlzLnZhbHVlT2YoKSArIHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaXgoX25ld01pbGxpc2Vjb25kNSAvIDEwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFN5bmNlZENsYXNzKHRoaXMudmFsdWVPZigpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ga2V5XG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJucyB7UGVyc2lhbkRhdGV9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzdWJ0cmFjdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJ0cmFjdChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoa2V5LCB2YWx1ZSAqIC0xKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGVjayBpZiBhIGRhdGUgaXMgc2FtZSBhcyBiXG4gICAgICAgICAqIEBwYXJhbSBkYXRlQVxuICAgICAgICAgKiBAcGFyYW0gZGF0ZUJcbiAgICAgICAgICogQHNpbmNlIDEuMC4wXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2lzU2FtZURheScsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGRhdGVCXG4gICAgICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAgICAgKiBAcmV0dXJuIHtQZXJzaWFuRGF0ZUNsYXNzfCp8Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1NhbWVEYXkoZGF0ZUIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzICYmIGRhdGVCICYmIHRoaXMuZGF0ZSgpID09IGRhdGVCLmRhdGUoKSAmJiB0aGlzLnllYXIoKSA9PSBkYXRlQi55ZWFyKCkgJiYgdGhpcy5tb250aCgpID09IGRhdGVCLm1vbnRoKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgY2hlY2sgaWYgYSBtb250aCBpcyBzYW1lIGFzIGJcbiAgICAgICAgICogQHBhcmFtIHtEYXRlfSBkYXRlQVxuICAgICAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGVCXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpc1NhbWVNb250aCcsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgY2hlY2sgdHdvIGZvciBtb250aCBzaW1pbGFyaXR5XG4gICAgICAgICAqIEBwYXJhbSBkYXRlQVxuICAgICAgICAgKiBAcGFyYW0gZGF0ZUJcbiAgICAgICAgICogQHNpbmNlIDEuMC4wXG4gICAgICAgICAqIEByZXR1cm4geyp8Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1NhbWVNb250aChkYXRlQikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMgJiYgZGF0ZUIgJiYgdGhpcy55ZWFyKCkgPT0gdGhpcy55ZWFyKCkgJiYgdGhpcy5tb250aCgpID09IGRhdGVCLm1vbnRoKCk7XG4gICAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgICAga2V5OiAncmFuZ2VOYW1lJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJhbmdlTmFtZSgpIHtcbiAgICAgICAgICAgIHZhciBwID0gUGVyc2lhbkRhdGVDbGFzcyxcbiAgICAgICAgICAgICAgICB0ID0gcC5jYWxlbmRhclR5cGU7XG4gICAgICAgICAgICBpZiAocC5sb2NhbFR5cGUgPT09ICdmYScpIHtcbiAgICAgICAgICAgICAgICBpZiAodCA9PT0gJ3BlcnNpYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYS5wZXJzaWFuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYS5ncmVnb3JpYW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodCA9PT0gJ3BlcnNpYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbi5wZXJzaWFuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbi5ncmVnb3JpYW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0xlYXBZZWFyTW9kZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0xlYXBZZWFyTW9kZShpbnB1dCkge1xuICAgICAgICAgICAgdmFyIGQgPSBQZXJzaWFuRGF0ZUNsYXNzO1xuICAgICAgICAgICAgZC5sZWFwWWVhck1vZGUgPSBpbnB1dDtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0NhbGVuZGFyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvQ2FsZW5kYXIoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBkID0gUGVyc2lhbkRhdGVDbGFzcztcbiAgICAgICAgICAgIGQuY2FsZW5kYXJUeXBlID0gaW5wdXQ7XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgICAgICogQHJldHVybiB7UGVyc2lhbkRhdGVDbGFzc31cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvTG9jYWxlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvTG9jYWxlKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgZCA9IFBlcnNpYW5EYXRlQ2xhc3M7XG4gICAgICAgICAgICBkLmxvY2FsVHlwZSA9IGlucHV0O1xuICAgICAgICAgICAgaWYgKGQubG9jYWxUeXBlICE9PSAnZmEnKSB7XG4gICAgICAgICAgICAgICAgZC5mb3JtYXRQZXJzaWFuID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGQuZm9ybWF0UGVyc2lhbiA9ICdfZGVmYXVsdCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXNQZXJzaWFuRGF0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1BlcnNpYW5EYXRlKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIFBlcnNpYW5EYXRlQ2xhc3M7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2R1cmF0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGR1cmF0aW9uKGlucHV0LCBrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRHVyYXRpb24oaW5wdXQsIGtleSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2lzRHVyYXRpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNEdXJhdGlvbihvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBEdXJhdGlvbjtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndW5peCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB1bml4KHRpbWVzdGFtcCkge1xuICAgICAgICAgICAgaWYgKHRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUGVyc2lhbkRhdGVDbGFzcyh0aW1lc3RhbXAgKiAxMDAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQZXJzaWFuRGF0ZUNsYXNzKCkudW5peCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRGaXJzdFdlZWtEYXlPZk1vbnRoJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZpcnN0V2Vla0RheU9mTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGVyc2lhbkRhdGVDbGFzcyhbeWVhciwgbW9udGgsIDFdKS5kYXkoKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndXRjJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHV0YyhpbnB1dCkge1xuICAgICAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQZXJzaWFuRGF0ZUNsYXNzKGlucHV0KS51dGMoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQZXJzaWFuRGF0ZUNsYXNzKCkudXRjKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2lzU2FtZURheScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1NhbWVEYXkoZGF0ZUEsIGRhdGVCKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZUEgJiYgZGF0ZUIgJiYgZGF0ZUEuZGF0ZSgpID09IGRhdGVCLmRhdGUoKSAmJiBkYXRlQS55ZWFyKCkgPT0gZGF0ZUIueWVhcigpICYmIGRhdGVBLm1vbnRoKCkgPT0gZGF0ZUIubW9udGgoKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXNTYW1lTW9udGgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNTYW1lTW9udGgoZGF0ZUEsIGRhdGVCKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZUEgJiYgZGF0ZUIgJiYgZGF0ZUEueWVhcigpID09IGRhdGVCLnllYXIoKSAmJiBkYXRlQS5tb250aCgpID09IGRhdGVCLm1vbnRoKCk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUGVyc2lhbkRhdGVDbGFzcztcbn0oKTtcblxuLyoqXG4gKiBAdHlwZSB7UGVyc2lhbkRhdGVDbGFzc31cbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUGVyc2lhbkRhdGVDbGFzcztcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8vIFN0YXJ0IGFsZ29yaXRobSBjbGFzc1xudmFyIEFTVFJPID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBTdGF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBBbGdvcml0aG1zID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFsZ29yaXRobXMocGFyZW50KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBbGdvcml0aG1zKTtcblxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5BU1RSTyA9IG5ldyBBU1RSTygpO1xuICAgICAgICB0aGlzLlN0YXRlID0gbmV3IFN0YXRlKCk7XG4gICAgICAgIC8qICBZb3UgbWF5IG5vdGljZSB0aGF0IGEgdmFyaWV0eSBvZiBhcnJheSB2YXJpYWJsZXMgbG9naWNhbGx5IGxvY2FsXG4gICAgICAgICB0byBmdW5jdGlvbnMgYXJlIGRlY2xhcmVkIGdsb2JhbGx5IGhlcmUuICBJbiBKYXZhU2NyaXB0LCBjb25zdHJ1Y3Rpb25cbiAgICAgICAgIG9mIGFuIGFycmF5IHZhcmlhYmxlIGZyb20gc291cmNlIGNvZGUgb2NjdXJzIGFzIHRoZSBjb2RlIGlzXG4gICAgICAgICBpbnRlcnByZXRlZC4gIE1ha2luZyB0aGVzZSB2YXJpYWJsZXMgcHNldWRvLWdsb2JhbHMgcGVybWl0cyB1c1xuICAgICAgICAgdG8gYXZvaWQgb3ZlcmhlYWQgY29uc3RydWN0aW5nIGFuZCBkaXNwb3Npbmcgb2YgdGhlbSBpbiBlYWNoXG4gICAgICAgICBjYWxsIG9uIHRoZSBmdW5jdGlvbiBpbiB3aGljaCB3aGV5IGFyZSB1c2VkLiAgKi9cbiAgICAgICAgLy8gVE9ETyB0aGlzIGJsb2NrIGRpZG50IHVzZWQgaW4gbWFpbiBhZ29yaXRobVxuICAgICAgICB0aGlzLkowMDAwID0gMTcyMTQyNC41OyAvLyBKdWxpYW4gZGF0ZSBvZiBHcmVnb3JpYW4gZXBvY2g6IDAwMDAtMDEtMDFcbiAgICAgICAgdGhpcy5KMTk3MCA9IDI0NDA1ODcuNTsgLy8gSnVsaWFuIGRhdGUgYXQgVW5peCBlcG9jaDogMTk3MC0wMS0wMVxuICAgICAgICB0aGlzLkpNSkQgPSAyNDAwMDAwLjU7IC8vIEVwb2NoIG9mIE1vZGlmaWVkIEp1bGlhbiBEYXRlIHN5c3RlbVxuICAgICAgICB0aGlzLk5vcm1MZWFwID0gW2ZhbHNlIC8qXCJOb3JtYWwgeWVhclwiKi8sIHRydWUgLypcIkxlYXAgeWVhclwiKi9dO1xuICAgICAgICAvLyBUT0RPIEVORFxuICAgICAgICB0aGlzLkdSRUdPUklBTl9FUE9DSCA9IDE3MjE0MjUuNTtcbiAgICAgICAgdGhpcy5QRVJTSUFOX0VQT0NIID0gMTk0ODMyMC41O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXNjIExFQVBfR1JFR09SSUFOICAtLSAgSXMgYSBnaXZlbiB5ZWFyIGluIHRoZSBHcmVnb3JpYW4gY2FsZW5kYXIgYSBsZWFwIHllYXIgP1xuICAgICAqIEBwYXJhbSB5ZWFyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKEFsZ29yaXRobXMsIFt7XG4gICAgICAgIGtleTogJ2xlYXBfZ3JlZ29yaWFuJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxlYXBfZ3JlZ29yaWFuKHllYXIpIHtcbiAgICAgICAgICAgIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiAhKHllYXIgJSAxMDAgPT09IDAgJiYgeWVhciAlIDQwMCAhPT0gMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgRGV0ZXJtaW5lIEp1bGlhbiBkYXkgbnVtYmVyIGZyb20gR3JlZ29yaWFuIGNhbGVuZGFyIGRhdGVcbiAgICAgICAgICogQHBhcmFtIHsqfSB5ZWFyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gbW9udGhcbiAgICAgICAgICogQHBhcmFtIHsqfSBkYXlcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dyZWdvcmlhbl90b19qZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBncmVnb3JpYW5fdG9famQoeWVhciwgbW9udGgsIGRheSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuR1JFR09SSUFOX0VQT0NIIC0gMSArIDM2NSAqICh5ZWFyIC0gMSkgKyBNYXRoLmZsb29yKCh5ZWFyIC0gMSkgLyA0KSArIC1NYXRoLmZsb29yKCh5ZWFyIC0gMSkgLyAxMDApICsgTWF0aC5mbG9vcigoeWVhciAtIDEpIC8gNDAwKSArIE1hdGguZmxvb3IoKDM2NyAqIG1vbnRoIC0gMzYyKSAvIDEyICsgKG1vbnRoIDw9IDIgPyAwIDogdGhpcy5sZWFwX2dyZWdvcmlhbih5ZWFyKSA/IC0xIDogLTIpICsgZGF5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyBDYWxjdWxhdGUgR3JlZ29yaWFuIGNhbGVuZGFyIGRhdGUgZnJvbSBKdWxpYW4gZGF5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gamRcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2pkX3RvX2dyZWdvcmlhbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBqZF90b19ncmVnb3JpYW4oamQpIHtcbiAgICAgICAgICAgIHZhciB3amQgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgZGVwb2NoID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIHF1YWRyaWNlbnQgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgZHFjID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGNlbnQgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgZGNlbnQgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgcXVhZCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBkcXVhZCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICB5aW5kZXggPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgeWVhciA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICB5ZWFyZGF5ID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGxlYXBhZGogPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgbW9udGggPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgZGF5ID0gdm9pZCAwO1xuXG4gICAgICAgICAgICB3amQgPSBNYXRoLmZsb29yKGpkIC0gMC41KSArIDAuNTtcbiAgICAgICAgICAgIGRlcG9jaCA9IHdqZCAtIHRoaXMuR1JFR09SSUFOX0VQT0NIO1xuICAgICAgICAgICAgcXVhZHJpY2VudCA9IE1hdGguZmxvb3IoZGVwb2NoIC8gMTQ2MDk3KTtcbiAgICAgICAgICAgIGRxYyA9IHRoaXMuQVNUUk8ubW9kKGRlcG9jaCwgMTQ2MDk3KTtcbiAgICAgICAgICAgIGNlbnQgPSBNYXRoLmZsb29yKGRxYyAvIDM2NTI0KTtcbiAgICAgICAgICAgIGRjZW50ID0gdGhpcy5BU1RSTy5tb2QoZHFjLCAzNjUyNCk7XG4gICAgICAgICAgICBxdWFkID0gTWF0aC5mbG9vcihkY2VudCAvIDE0NjEpO1xuICAgICAgICAgICAgZHF1YWQgPSB0aGlzLkFTVFJPLm1vZChkY2VudCwgMTQ2MSk7XG4gICAgICAgICAgICB5aW5kZXggPSBNYXRoLmZsb29yKGRxdWFkIC8gMzY1KTtcbiAgICAgICAgICAgIHllYXIgPSBxdWFkcmljZW50ICogNDAwICsgY2VudCAqIDEwMCArIHF1YWQgKiA0ICsgeWluZGV4O1xuICAgICAgICAgICAgaWYgKCEoY2VudCA9PT0gNCB8fCB5aW5kZXggPT09IDQpKSB7XG4gICAgICAgICAgICAgICAgeWVhcisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWVhcmRheSA9IHdqZCAtIHRoaXMuZ3JlZ29yaWFuX3RvX2pkKHllYXIsIDEsIDEpO1xuICAgICAgICAgICAgbGVhcGFkaiA9IHdqZCA8IHRoaXMuZ3JlZ29yaWFuX3RvX2pkKHllYXIsIDMsIDEpID8gMCA6IHRoaXMubGVhcF9ncmVnb3JpYW4oeWVhcikgPyAxIDogMjtcbiAgICAgICAgICAgIG1vbnRoID0gTWF0aC5mbG9vcigoKHllYXJkYXkgKyBsZWFwYWRqKSAqIDEyICsgMzczKSAvIDM2Nyk7XG4gICAgICAgICAgICBkYXkgPSB3amQgLSB0aGlzLmdyZWdvcmlhbl90b19qZCh5ZWFyLCBtb250aCwgMSkgKyAxO1xuXG4gICAgICAgICAgICByZXR1cm4gW3llYXIsIG1vbnRoLCBkYXldO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Kn0geWVhclxuICAgICAgICAgKi9cbiAgICAgICAgLy8gICAgbGVhcF9qdWxpYW4gKHllYXIpIHtcbiAgICAgICAgLy8gICAgICAgIHJldHVybiB0aGlzLkFTVFJPLm1vZCh5ZWFyLCA0KSA9PT0gKCh5ZWFyID4gMCkgPyAwIDogMyk7XG4gICAgICAgIC8vICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyBDYWxjdWxhdGUgSnVsaWFuIGNhbGVuZGFyIGRhdGUgZnJvbSBKdWxpYW4gZGF5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdGRcbiAgICAgICAgICovXG4gICAgICAgIC8vICAgIGpkX3RvX2p1bGlhbiAodGQpIHtcbiAgICAgICAgLy8gICAgICAgIGxldCB6LCBhLCBiLCBjLCBkLCBlLCB5ZWFyLCBtb250aCwgZGF5O1xuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgICAgdGQgKz0gMC41O1xuICAgICAgICAvLyAgICAgICAgeiA9IE1hdGguZmxvb3IodGQpO1xuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgICAgYSA9IHo7XG4gICAgICAgIC8vICAgICAgICBiID0gYSArIDE1MjQ7XG4gICAgICAgIC8vICAgICAgICBjID0gTWF0aC5mbG9vcigoYiAtIDEyMi4xKSAvIDM2NS4yNSk7XG4gICAgICAgIC8vICAgICAgICBkID0gTWF0aC5mbG9vcigzNjUuMjUgKiBjKTtcbiAgICAgICAgLy8gICAgICAgIGUgPSBNYXRoLmZsb29yKChiIC0gZCkgLyAzMC42MDAxKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgICAgIG1vbnRoID0gTWF0aC5mbG9vcigoZSA8IDE0KSA/IChlIC0gMSkgOiAoZSAtIDEzKSk7XG4gICAgICAgIC8vICAgICAgICB5ZWFyID0gTWF0aC5mbG9vcigobW9udGggPiAyKSA/IChjIC0gNDcxNikgOiAoYyAtIDQ3MTUpKTtcbiAgICAgICAgLy8gICAgICAgIGRheSA9IGIgLSBkIC0gTWF0aC5mbG9vcigzMC42MDAxICogZSk7XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICAgICAvKiAgSWYgeWVhciBpcyBsZXNzIHRoYW4gMSwgc3VidHJhY3Qgb25lIHRvIGNvbnZlcnQgZnJvbVxuICAgICAgICAvLyAgICAgICAgIGEgemVybyBiYXNlZCBkYXRlIHN5c3RlbSB0byB0aGUgY29tbW9uIGVyYSBzeXN0ZW0gaW5cbiAgICAgICAgLy8gICAgICAgICB3aGljaCB0aGUgeWVhciAtMSAoMSBCLkMuRSkgaXMgZm9sbG93ZWQgYnkgeWVhciAxICgxIEMuRS4pLiAgKi9cbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgICAgIGlmICh5ZWFyIDwgMSkge1xuICAgICAgICAvLyAgICAgICAgICAgIHllYXItLTtcbiAgICAgICAgLy8gICAgICAgIH1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgICAgIHJldHVybiBbeWVhciwgbW9udGgsIGRheV07XG4gICAgICAgIC8vICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyBURUhSQU5fRVFVSU5PWCAgLS0gIERldGVybWluZSBKdWxpYW4gZGF5IGFuZCBmcmFjdGlvbiBvZiB0aGVcbiAgICAgICAgIE1hcmNoIGVxdWlub3ggYXQgdGhlIFRlaHJhbiBtZXJpZGlhbiBpblxuICAgICAgICAgYSBnaXZlbiBHcmVnb3JpYW4geWVhci5cbiAgICAgICAgICogQHBhcmFtIHsqfSB5ZWFyXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0ZWhyYW5fZXF1aW5veCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0ZWhyYW5fZXF1aW5veCh5ZWFyKSB7XG4gICAgICAgICAgICB2YXIgZXF1SkVEID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGVxdUpEID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGVxdUFQUCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBlcXVUZWhyYW4gPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgZHRUZWhyYW4gPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIC8vICBNYXJjaCBlcXVpbm94IGluIGR5bmFtaWNhbCB0aW1lXG4gICAgICAgICAgICBlcXVKRUQgPSB0aGlzLkFTVFJPLmVxdWlub3goeWVhciwgMCk7XG5cbiAgICAgICAgICAgIC8vICBDb3JyZWN0IGZvciBkZWx0YSBUIHRvIG9idGFpbiBVbml2ZXJzYWwgdGltZVxuICAgICAgICAgICAgZXF1SkQgPSBlcXVKRUQgLSB0aGlzLkFTVFJPLmRlbHRhdCh5ZWFyKSAvICgyNCAqIDYwICogNjApO1xuXG4gICAgICAgICAgICAvLyAgQXBwbHkgdGhlIGVxdWF0aW9uIG9mIHRpbWUgdG8geWllbGQgdGhlIGFwcGFyZW50IHRpbWUgYXQgR3JlZW53aWNoXG4gICAgICAgICAgICBlcXVBUFAgPSBlcXVKRCArIHRoaXMuQVNUUk8uZXF1YXRpb25PZlRpbWUoZXF1SkVEKTtcblxuICAgICAgICAgICAgLyogIEZpbmFsbHksIHdlIG11c3QgY29ycmVjdCBmb3IgdGhlIGNvbnN0YW50IGRpZmZlcmVuY2UgYmV0d2VlblxuICAgICAgICAgICAgIHRoZSBHcmVlbndpY2ggbWVyaWRpYW4gYW5kdGhlIHRpbWUgem9uZSBzdGFuZGFyZCBmb3JcbiAgICAgICAgICAgICBJcmFuIFN0YW5kYXJkIHRpbWUsIDUywrAzMCcgdG8gdGhlIEVhc3QuICAqL1xuXG4gICAgICAgICAgICBkdFRlaHJhbiA9ICg1MiArIDMwIC8gNjAuMCArIDAgLyAoNjAuMCAqIDYwLjApKSAvIDM2MDtcbiAgICAgICAgICAgIGVxdVRlaHJhbiA9IGVxdUFQUCArIGR0VGVocmFuO1xuXG4gICAgICAgICAgICByZXR1cm4gZXF1VGVocmFuO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjIFRFSFJBTl9FUVVJTk9YX0pEICAtLSAgQ2FsY3VsYXRlIEp1bGlhbiBkYXkgZHVyaW5nIHdoaWNoIHRoZVxuICAgICAgICAgTWFyY2ggZXF1aW5veCwgcmVja29uZWQgZnJvbSB0aGUgVGVocmFuXG4gICAgICAgICBtZXJpZGlhbiwgb2NjdXJyZWQgZm9yIGEgZ2l2ZW4gR3JlZ29yaWFuXG4gICAgICAgICB5ZWFyLlxuICAgICAgICAgKiBAcGFyYW0geyp9IHllYXJcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RlaHJhbl9lcXVpbm94X2pkJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRlaHJhbl9lcXVpbm94X2pkKHllYXIpIHtcbiAgICAgICAgICAgIHZhciBlcCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBlcGcgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGVwID0gdGhpcy50ZWhyYW5fZXF1aW5veCh5ZWFyKTtcbiAgICAgICAgICAgIGVwZyA9IE1hdGguZmxvb3IoZXApO1xuXG4gICAgICAgICAgICByZXR1cm4gZXBnO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjICBQRVJTSUFOQV9ZRUFSICAtLSAgRGV0ZXJtaW5lIHRoZSB5ZWFyIGluIHRoZSBQZXJzaWFuXG4gICAgICAgICBhc3Ryb25vbWljYWwgY2FsZW5kYXIgaW4gd2hpY2ggYVxuICAgICAgICAgZ2l2ZW4gSnVsaWFuIGRheSBmYWxscy4gIFJldHVybnMgYW5cbiAgICAgICAgIGFycmF5IG9mIHR3byBlbGVtZW50czpcbiAgICAgICAgICBbMF0gIFBlcnNpYW4geWVhclxuICAgICAgICAgWzFdICBKdWxpYW4gZGF5IG51bWJlciBjb250YWluaW5nXG4gICAgICAgICBlcXVpbm94IGZvciB0aGlzIHllYXIuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gamRcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3BlcnNpYW5hX3llYXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGVyc2lhbmFfeWVhcihqZCkge1xuICAgICAgICAgICAgdmFyIGd1ZXNzID0gdGhpcy5qZF90b19ncmVnb3JpYW4oamQpWzBdIC0gMixcbiAgICAgICAgICAgICAgICBsYXN0ZXEgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgbmV4dGVxID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGFkciA9IHZvaWQgMDtcblxuICAgICAgICAgICAgbGFzdGVxID0gdGhpcy50ZWhyYW5fZXF1aW5veF9qZChndWVzcyk7XG4gICAgICAgICAgICB3aGlsZSAobGFzdGVxID4gamQpIHtcbiAgICAgICAgICAgICAgICBndWVzcy0tO1xuICAgICAgICAgICAgICAgIGxhc3RlcSA9IHRoaXMudGVocmFuX2VxdWlub3hfamQoZ3Vlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dGVxID0gbGFzdGVxIC0gMTtcbiAgICAgICAgICAgIHdoaWxlICghKGxhc3RlcSA8PSBqZCAmJiBqZCA8IG5leHRlcSkpIHtcbiAgICAgICAgICAgICAgICBsYXN0ZXEgPSBuZXh0ZXE7XG4gICAgICAgICAgICAgICAgZ3Vlc3MrKztcbiAgICAgICAgICAgICAgICBuZXh0ZXEgPSB0aGlzLnRlaHJhbl9lcXVpbm94X2pkKGd1ZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkciA9IE1hdGgucm91bmQoKGxhc3RlcSAtIHRoaXMuUEVSU0lBTl9FUE9DSCkgLyB0aGlzLkFTVFJPLlRyb3BpY2FsWWVhcikgKyAxO1xuXG4gICAgICAgICAgICByZXR1cm4gW2FkciwgbGFzdGVxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyBDYWxjdWxhdGUgZGF0ZSBpbiB0aGUgUGVyc2lhbiBhc3Ryb25vbWljYWxcbiAgICAgICAgIGNhbGVuZGFyIGZyb20gSnVsaWFuIGRheS5cbiAgICAgICAgICogQHBhcmFtIHsqfSBqZFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnamRfdG9fcGVyc2lhbmEnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gamRfdG9fcGVyc2lhbmEoamQpIHtcbiAgICAgICAgICAgIHZhciB5ZWFyID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIG1vbnRoID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGRheSA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBhZHIgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgZXF1aW5veCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICB5ZGF5ID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBqZCA9IE1hdGguZmxvb3IoamQpICsgMC41O1xuICAgICAgICAgICAgYWRyID0gdGhpcy5wZXJzaWFuYV95ZWFyKGpkKTtcbiAgICAgICAgICAgIHllYXIgPSBhZHJbMF07XG4gICAgICAgICAgICBlcXVpbm94ID0gYWRyWzFdO1xuICAgICAgICAgICAgZGF5ID0gTWF0aC5mbG9vcigoamQgLSBlcXVpbm94KSAvIDMwKSArIDE7XG5cbiAgICAgICAgICAgIHlkYXkgPSBNYXRoLmZsb29yKGpkKSAtIHRoaXMucGVyc2lhbmFfdG9famQoeWVhciwgMSwgMSkgKyAxO1xuICAgICAgICAgICAgbW9udGggPSB5ZGF5IDw9IDE4NiA/IE1hdGguY2VpbCh5ZGF5IC8gMzEpIDogTWF0aC5jZWlsKCh5ZGF5IC0gNikgLyAzMCk7XG4gICAgICAgICAgICBkYXkgPSBNYXRoLmZsb29yKGpkKSAtIHRoaXMucGVyc2lhbmFfdG9famQoeWVhciwgbW9udGgsIDEpICsgMTtcblxuICAgICAgICAgICAgcmV0dXJuIFt5ZWFyLCBtb250aCwgZGF5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyBPYnRhaW4gSnVsaWFuIGRheSBmcm9tIGEgZ2l2ZW4gUGVyc2lhblxuICAgICAgICAgYXN0cm9ub21pY2FsIGNhbGVuZGFyIGRhdGUuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0geWVhclxuICAgICAgICAgKiBAcGFyYW0geyp9IG1vbnRoXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gZGF5XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdwZXJzaWFuYV90b19qZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwZXJzaWFuYV90b19qZCh5ZWFyLCBtb250aCwgZGF5KSB7XG4gICAgICAgICAgICB2YXIgYWRyID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGVxdWlub3ggPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgZ3Vlc3MgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgamQgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGd1ZXNzID0gdGhpcy5QRVJTSUFOX0VQT0NIIC0gMSArIHRoaXMuQVNUUk8uVHJvcGljYWxZZWFyICogKHllYXIgLSAxIC0gMSk7XG4gICAgICAgICAgICBhZHIgPSBbeWVhciAtIDEsIDBdO1xuXG4gICAgICAgICAgICB3aGlsZSAoYWRyWzBdIDwgeWVhcikge1xuICAgICAgICAgICAgICAgIGFkciA9IHRoaXMucGVyc2lhbmFfeWVhcihndWVzcyk7XG4gICAgICAgICAgICAgICAgZ3Vlc3MgPSBhZHJbMV0gKyAodGhpcy5BU1RSTy5Ucm9waWNhbFllYXIgKyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVxdWlub3ggPSBhZHJbMV07XG5cbiAgICAgICAgICAgIGpkID0gZXF1aW5veCArIChtb250aCA8PSA3ID8gKG1vbnRoIC0gMSkgKiAzMSA6IChtb250aCAtIDEpICogMzAgKyA2KSArIChkYXkgLSAxKTtcbiAgICAgICAgICAgIHJldHVybiBqZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyBJcyBhIGdpdmVuIHllYXIgYSBsZWFwIHllYXIgaW4gdGhlIFBlcnNpYW4gYXN0cm9ub21pY2FsIGNhbGVuZGFyID9cbiAgICAgICAgICogQHBhcmFtIHsqfSB5ZWFyXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdsZWFwX3BlcnNpYW5hJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxlYXBfcGVyc2lhbmEoeWVhcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lhbmFfdG9famQoeWVhciArIDEsIDEsIDEpIC0gdGhpcy5wZXJzaWFuYV90b19qZCh5ZWFyLCAxLCAxKSA+IDM2NTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyBJcyBhIGdpdmVuIHllYXIgYSBsZWFwIHllYXIgaW4gdGhlIFBlcnNpYW4gY2FsZW5kYXIgP1xuICAgICAgICAgKiBhbHNvIG5hc2EgdXNlIHRoaXMgYWxnb3JpdGhtIGh0dHBzOi8vZWNsaXBzZS5nc2ZjLm5hc2EuZ292L1NLWUNBTC9hbGdvcml0aG0uanMgc2VhcmNoIGZvciAnZ2V0TGFzdERheU9mUGVyc2lhbk1vbnRoJyBhbmQgeW91IGNhbiBmaW5kIGl0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0geWVhclxuICAgICAgICAgKlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbGVhcF9wZXJzaWFuJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxlYXBfcGVyc2lhbih5ZWFyKSB7XG4gICAgICAgICAgICByZXR1cm4gKCh5ZWFyIC0gKHllYXIgPiAwID8gNDc0IDogNDczKSkgJSAyODIwICsgNDc0ICsgMzgpICogNjgyICUgMjgxNiA8IDY4MjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyBEZXRlcm1pbmUgSnVsaWFuIGRheSBmcm9tIFBlcnNpYW4gZGF0ZVxuICAgICAgICAgKiBAcGFyYW0geyp9IHllYXJcbiAgICAgICAgICogQHBhcmFtIHsqfSBtb250aFxuICAgICAgICAgKiBAcGFyYW0geyp9IGRheVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncGVyc2lhbl90b19qZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwZXJzaWFuX3RvX2pkKHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgICAgICAgICAgIHZhciBlcGJhc2UgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgZXB5ZWFyID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBlcGJhc2UgPSB5ZWFyIC0gKHllYXIgPj0gMCA/IDQ3NCA6IDQ3Myk7XG4gICAgICAgICAgICBlcHllYXIgPSA0NzQgKyB0aGlzLkFTVFJPLm1vZChlcGJhc2UsIDI4MjApO1xuXG4gICAgICAgICAgICByZXR1cm4gZGF5ICsgKG1vbnRoIDw9IDcgPyAobW9udGggLSAxKSAqIDMxIDogKG1vbnRoIC0gMSkgKiAzMCArIDYpICsgTWF0aC5mbG9vcigoZXB5ZWFyICogNjgyIC0gMTEwKSAvIDI4MTYpICsgKGVweWVhciAtIDEpICogMzY1ICsgTWF0aC5mbG9vcihlcGJhc2UgLyAyODIwKSAqIDEwMjk5ODMgKyAodGhpcy5QRVJTSUFOX0VQT0NIIC0gMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgQ2FsY3VsYXRlIFBlcnNpYW4gZGF0ZSBmcm9tIEp1bGlhbiBkYXlcbiAgICAgICAgICogQHBhcmFtIHsqfSBqZFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnamRfdG9fcGVyc2lhbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBqZF90b19wZXJzaWFuKGpkKSB7XG4gICAgICAgICAgICB2YXIgeWVhciA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBtb250aCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBkYXkgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgZGVwb2NoID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGN5Y2xlID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGN5ZWFyID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIHljeWNsZSA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBhdXgxID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGF1eDIgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgeWRheSA9IHZvaWQgMDtcblxuICAgICAgICAgICAgamQgPSBNYXRoLmZsb29yKGpkKSArIDAuNTtcblxuICAgICAgICAgICAgZGVwb2NoID0gamQgLSB0aGlzLnBlcnNpYW5fdG9famQoNDc1LCAxLCAxKTtcbiAgICAgICAgICAgIGN5Y2xlID0gTWF0aC5mbG9vcihkZXBvY2ggLyAxMDI5OTgzKTtcbiAgICAgICAgICAgIGN5ZWFyID0gdGhpcy5BU1RSTy5tb2QoZGVwb2NoLCAxMDI5OTgzKTtcbiAgICAgICAgICAgIGlmIChjeWVhciA9PT0gMTAyOTk4Mikge1xuICAgICAgICAgICAgICAgIHljeWNsZSA9IDI4MjA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGF1eDEgPSBNYXRoLmZsb29yKGN5ZWFyIC8gMzY2KTtcbiAgICAgICAgICAgICAgICBhdXgyID0gdGhpcy5BU1RSTy5tb2QoY3llYXIsIDM2Nik7XG4gICAgICAgICAgICAgICAgeWN5Y2xlID0gTWF0aC5mbG9vcigoMjEzNCAqIGF1eDEgKyAyODE2ICogYXV4MiArIDI4MTUpIC8gMTAyODUyMikgKyBhdXgxICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHllYXIgPSB5Y3ljbGUgKyAyODIwICogY3ljbGUgKyA0NzQ7XG4gICAgICAgICAgICBpZiAoeWVhciA8PSAwKSB7XG4gICAgICAgICAgICAgICAgeWVhci0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWRheSA9IGpkIC0gdGhpcy5wZXJzaWFuX3RvX2pkKHllYXIsIDEsIDEpICsgMTtcbiAgICAgICAgICAgIG1vbnRoID0geWRheSA8PSAxODYgPyBNYXRoLmNlaWwoeWRheSAvIDMxKSA6IE1hdGguY2VpbCgoeWRheSAtIDYpIC8gMzApO1xuICAgICAgICAgICAgZGF5ID0gamQgLSB0aGlzLnBlcnNpYW5fdG9famQoeWVhciwgbW9udGgsIDEpICsgMTtcbiAgICAgICAgICAgIHJldHVybiBbeWVhciwgbW9udGgsIGRheV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHsqfSB3ZWVrZGF5XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnV2Vla0RheVRvUGVyc2lhbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnV2Vla0RheVRvUGVyc2lhbih3ZWVrZGF5KSB7XG4gICAgICAgICAgICBpZiAod2Vla2RheSArIDIgPT09IDgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod2Vla2RheSArIDIgPT09IDcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkgKyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjIHVwZGF0ZUZyb21HcmVnb3JpYW4gIC0tICBVcGRhdGUgYWxsIGNhbGVuZGFycyBmcm9tIEdyZWdvcmlhbi5cbiAgICAgICAgIFwiV2h5IG5vdCBKdWxpYW4gZGF0ZT9cIiB5b3UgYXNrLiAgQmVjYXVzZVxuICAgICAgICAgc3RhcnRpbmcgZnJvbSBHcmVnb3JpYW4gZ3VhcmFudGVlcyB3ZSdyZVxuICAgICAgICAgYWxyZWFkeSBzbmFwcGVkIHRvIGFuIGludGVncmFsIHNlY29uZCwgc29cbiAgICAgICAgIHdlIGRvbid0IGdldCByb3VuZG9mZiBlcnJvcnMgaW4gb3RoZXJcbiAgICAgICAgIGNhbGVuZGFycy5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3VwZGF0ZUZyb21HcmVnb3JpYW4nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRnJvbUdyZWdvcmlhbigpIHtcbiAgICAgICAgICAgIHZhciBqID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIHllYXIgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgbW9uID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIG1kYXkgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgaG91ciA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBtaW4gPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgc2VjID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgdXRpbWUgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgcGVyc2NhbCA9IHZvaWQgMDtcblxuICAgICAgICAgICAgeWVhciA9IHRoaXMuU3RhdGUuZ3JlZ29yaWFuLnllYXI7XG4gICAgICAgICAgICBtb24gPSB0aGlzLlN0YXRlLmdyZWdvcmlhbi5tb250aDtcbiAgICAgICAgICAgIG1kYXkgPSB0aGlzLlN0YXRlLmdyZWdvcmlhbi5kYXk7XG4gICAgICAgICAgICBob3VyID0gMDsgLy90aGlzLlN0YXRlLmdyZWdvcmlhbi5ob3VyO1xuICAgICAgICAgICAgbWluID0gMDsgLy90aGlzLlN0YXRlLmdyZWdvcmlhbi5taW51dGU7XG4gICAgICAgICAgICBzZWMgPSAwOyAvL3RoaXMuU3RhdGUuZ3JlZ29yaWFuLnNlY29uZDtcblxuICAgICAgICAgICAgdGhpcy5TdGF0ZS5nRGF0ZSA9IG5ldyBEYXRlKHllYXIsIG1vbiwgbWRheSwgdGhpcy5TdGF0ZS5ncmVnb3JpYW4uaG91ciwgdGhpcy5TdGF0ZS5ncmVnb3JpYW4ubWludXRlLCB0aGlzLlN0YXRlLmdyZWdvcmlhbi5zZWNvbmQsIHRoaXMuU3RhdGUuZ3JlZ29yaWFuLm1pbGxpc2Vjb25kKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Ll91dGNNb2RlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuU3RhdGUuem9uZSA9IHRoaXMuU3RhdGUuZ0RhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkZWQgZm9yIHRoaXMgYWxnb3JpdGhtcyBjYW50IHBhcnNlIDIwMTYsMTMsMzIgc3VjY2Vzc2Z1bGx5XG4gICAgICAgICAgICB0aGlzLlN0YXRlLmdyZWdvcmlhbi55ZWFyID0gdGhpcy5TdGF0ZS5nRGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgdGhpcy5TdGF0ZS5ncmVnb3JpYW4ubW9udGggPSB0aGlzLlN0YXRlLmdEYXRlLmdldE1vbnRoKCk7XG4gICAgICAgICAgICB0aGlzLlN0YXRlLmdyZWdvcmlhbi5kYXkgPSB0aGlzLlN0YXRlLmdEYXRlLmdldERhdGUoKTtcblxuICAgICAgICAgICAgLy8gIFVwZGF0ZSBKdWxpYW4gZGF5XG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIGogPSB0aGlzLmdyZWdvcmlhbl90b19qZCh5ZWFyLCBtb24gKyAxLCBtZGF5KSArIE1hdGguZmxvb3Ioc2VjICsgNjAgKiAobWluICsgNjAgKiBob3VyKSArIDAuNSkgLyA4NjQwMC4wO1xuXG4gICAgICAgICAgICB0aGlzLlN0YXRlLmp1bGlhbmRheSA9IGo7XG4gICAgICAgICAgICB0aGlzLlN0YXRlLm1vZGlmaWVkanVsaWFuZGF5ID0gaiAtIHRoaXMuSk1KRDtcblxuICAgICAgICAgICAgLy8gIFVwZGF0ZSBkYXkgb2Ygd2VlayBpbiBHcmVnb3JpYW4gYm94XG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIHdlZWtkYXkgPSB0aGlzLkFTVFJPLmp3ZGF5KGopO1xuICAgICAgICAgICAgLy8gTW92ZSB0byAxIGluZGV4ZWQgbnVtYmVyXG4gICAgICAgICAgICB0aGlzLlN0YXRlLmdyZWdvcmlhbi53ZWVrZGF5ID0gd2Vla2RheSArIDE7XG5cbiAgICAgICAgICAgIC8vICBVcGRhdGUgbGVhcCB5ZWFyIHN0YXR1cyBpbiBHcmVnb3JpYW4gYm94XG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIHRoaXMuU3RhdGUuZ3JlZ29yaWFuLmxlYXAgPSB0aGlzLk5vcm1MZWFwW3RoaXMubGVhcF9ncmVnb3JpYW4oeWVhcikgPyAxIDogMF07XG5cbiAgICAgICAgICAgIC8vICBVcGRhdGUgSnVsaWFuIENhbGVuZGFyXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vICAgICAgICBqdWxjYWwgPSB0aGlzLmpkX3RvX2p1bGlhbihqKTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgICAgICAgdGhpcy5TdGF0ZS5qdWxpYW5jYWxlbmRhci55ZWFyID0ganVsY2FsWzBdO1xuICAgICAgICAgICAgLy8gICAgICAgIHRoaXMuU3RhdGUuanVsaWFuY2FsZW5kYXIubW9udGggPSBqdWxjYWxbMV0gLSAxO1xuICAgICAgICAgICAgLy8gICAgICAgIHRoaXMuU3RhdGUuanVsaWFuY2FsZW5kYXIuZGF5ID0ganVsY2FsWzJdO1xuICAgICAgICAgICAgLy8gICAgICAgIHRoaXMuU3RhdGUuanVsaWFuY2FsZW5kYXIubGVhcCA9IHRoaXMuTm9ybUxlYXBbdGhpcy5sZWFwX2p1bGlhbihqdWxjYWxbMF0pID8gMSA6IDBdO1xuICAgICAgICAgICAgd2Vla2RheSA9IHRoaXMuQVNUUk8uandkYXkoaik7XG4gICAgICAgICAgICAvLyAgICAgICAgdGhpcy5TdGF0ZS5qdWxpYW5jYWxlbmRhci53ZWVrZGF5ID0gd2Vla2RheTtcblxuICAgICAgICAgICAgLy8gIFVwZGF0ZSBQZXJzaWFuIENhbGVuZGFyXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudC5jYWxlbmRhclR5cGUgPT0gJ3BlcnNpYW4nICYmIHRoaXMucGFyZW50LmxlYXBZZWFyTW9kZSA9PSAnYWxnb3JpdGhtaWMnKSB7XG4gICAgICAgICAgICAgICAgcGVyc2NhbCA9IHRoaXMuamRfdG9fcGVyc2lhbihqKTtcbiAgICAgICAgICAgICAgICB0aGlzLlN0YXRlLnBlcnNpYW4ueWVhciA9IHBlcnNjYWxbMF07XG4gICAgICAgICAgICAgICAgdGhpcy5TdGF0ZS5wZXJzaWFuLm1vbnRoID0gcGVyc2NhbFsxXSAtIDE7XG4gICAgICAgICAgICAgICAgdGhpcy5TdGF0ZS5wZXJzaWFuLmRheSA9IHBlcnNjYWxbMl07XG4gICAgICAgICAgICAgICAgdGhpcy5TdGF0ZS5wZXJzaWFuLndlZWtkYXkgPSB0aGlzLmdXZWVrRGF5VG9QZXJzaWFuKHdlZWtkYXkpO1xuICAgICAgICAgICAgICAgIHRoaXMuU3RhdGUucGVyc2lhbi5sZWFwID0gdGhpcy5Ob3JtTGVhcFt0aGlzLmxlYXBfcGVyc2lhbihwZXJzY2FsWzBdKSA/IDEgOiAwXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gIFVwZGF0ZSBQZXJzaWFuIEFzdHJvbm9taWNhbCBDYWxlbmRhclxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQuY2FsZW5kYXJUeXBlID09ICdwZXJzaWFuJyAmJiB0aGlzLnBhcmVudC5sZWFwWWVhck1vZGUgPT0gJ2FzdHJvbm9taWNhbCcpIHtcbiAgICAgICAgICAgICAgICBwZXJzY2FsID0gdGhpcy5qZF90b19wZXJzaWFuYShqKTtcbiAgICAgICAgICAgICAgICB0aGlzLlN0YXRlLnBlcnNpYW5Bc3Ryby55ZWFyID0gcGVyc2NhbFswXTtcbiAgICAgICAgICAgICAgICB0aGlzLlN0YXRlLnBlcnNpYW5Bc3Ryby5tb250aCA9IHBlcnNjYWxbMV0gLSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuU3RhdGUucGVyc2lhbkFzdHJvLmRheSA9IHBlcnNjYWxbMl07XG4gICAgICAgICAgICAgICAgdGhpcy5TdGF0ZS5wZXJzaWFuQXN0cm8ud2Vla2RheSA9IHRoaXMuZ1dlZWtEYXlUb1BlcnNpYW4od2Vla2RheSk7XG4gICAgICAgICAgICAgICAgdGhpcy5TdGF0ZS5wZXJzaWFuQXN0cm8ubGVhcCA9IHRoaXMuTm9ybUxlYXBbdGhpcy5sZWFwX3BlcnNpYW5hKHBlcnNjYWxbMF0pID8gMSA6IDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gIFVwZGF0ZSBHcmVnb3JpYW4gc2VyaWFsIG51bWJlclxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBpZiAodGhpcy5TdGF0ZS5ncmVnc2VyaWFsLmRheSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuU3RhdGUuZ3JlZ3NlcmlhbC5kYXkgPSBqIC0gdGhpcy5KMDAwMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gIFVwZGF0ZSBVbml4IHRpbWUoKVxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICB1dGltZSA9IChqIC0gdGhpcy5KMTk3MCkgKiAoNjAgKiA2MCAqIDI0ICogMTAwMCk7XG5cbiAgICAgICAgICAgIHRoaXMuU3RhdGUudW5peHRpbWUgPSBNYXRoLnJvdW5kKHV0aW1lIC8gMTAwMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgUGVyZm9ybSBjYWxjdWxhdGlvbiBzdGFydGluZyB3aXRoIGEgR3JlZ29yaWFuIGRhdGVcbiAgICAgICAgICogQHBhcmFtIHsqfSBkYXRlQXJyYXlcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NhbGNHcmVnb3JpYW4nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY0dyZWdvcmlhbihkYXRlQXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChkYXRlQXJyYXlbMF0gfHwgZGF0ZUFycmF5WzBdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5TdGF0ZS5ncmVnb3JpYW4ueWVhciA9IGRhdGVBcnJheVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRlQXJyYXlbMV0gfHwgZGF0ZUFycmF5WzFdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5TdGF0ZS5ncmVnb3JpYW4ubW9udGggPSBkYXRlQXJyYXlbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUFycmF5WzJdIHx8IGRhdGVBcnJheVsyXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuU3RhdGUuZ3JlZ29yaWFuLmRheSA9IGRhdGVBcnJheVsyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRlQXJyYXlbM10gfHwgZGF0ZUFycmF5WzNdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5TdGF0ZS5ncmVnb3JpYW4uaG91ciA9IGRhdGVBcnJheVszXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRlQXJyYXlbNF0gfHwgZGF0ZUFycmF5WzRdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5TdGF0ZS5ncmVnb3JpYW4ubWludXRlID0gZGF0ZUFycmF5WzRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGVBcnJheVs1XSB8fCBkYXRlQXJyYXlbNV0gPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLlN0YXRlLmdyZWdvcmlhbi5zZWNvbmQgPSBkYXRlQXJyYXlbNV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUFycmF5WzZdIHx8IGRhdGVBcnJheVs2XSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuU3RhdGUuZ3JlZ29yaWFuLm1pbGxpc2Vjb25kID0gZGF0ZUFycmF5WzZdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVGcm9tR3JlZ29yaWFuKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgUGVyZm9ybSBjYWxjdWxhdGlvbiBzdGFydGluZyB3aXRoIGEgSnVsaWFuIGRhdGVcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NhbGNKdWxpYW4nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY0p1bGlhbigpIHtcbiAgICAgICAgICAgIHZhciBqID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGRhdGUgPSB2b2lkIDA7XG4gICAgICAgICAgICBqID0gdGhpcy5TdGF0ZS5qdWxpYW5kYXk7XG4gICAgICAgICAgICBkYXRlID0gdGhpcy5qZF90b19ncmVnb3JpYW4oaik7XG4gICAgICAgICAgICB0aGlzLlN0YXRlLmdyZWdvcmlhbi55ZWFyID0gZGF0ZVswXTtcbiAgICAgICAgICAgIHRoaXMuU3RhdGUuZ3JlZ29yaWFuLm1vbnRoID0gZGF0ZVsxXSAtIDE7XG4gICAgICAgICAgICB0aGlzLlN0YXRlLmdyZWdvcmlhbi5kYXkgPSBkYXRlWzJdO1xuICAgICAgICAgICAgLy8gICAgICAgIHRoaXMuU3RhdGUuZ3JlZ29yaWFuLmhvdXIgPSB0aGlzLnBhZCh0aW1lWzBdLCAyLCBcIiBcIik7XG4gICAgICAgICAgICAvLyAgICAgICAgdGhpcy5TdGF0ZS5ncmVnb3JpYW4ubWludXRlID0gdGhpcy5wYWQodGltZVsxXSwgMiwgXCIwXCIpO1xuICAgICAgICAgICAgLy8gICAgICAgIHRoaXMuU3RhdGUuZ3JlZ29yaWFuLnNlY29uZCA9IHRoaXMucGFkKHRpbWVbMl0sIDIsIFwiMFwiKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRnJvbUdyZWdvcmlhbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjIFNldCBKdWxpYW4gZGF0ZSBhbmQgdXBkYXRlIGFsbCBjYWxlbmRhcnNcbiAgICAgICAgICogQHBhcmFtIHsqfSBqXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZXRKdWxpYW4nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SnVsaWFuKGopIHtcbiAgICAgICAgICAgIHRoaXMuU3RhdGUuanVsaWFuZGF5ID0gajtcbiAgICAgICAgICAgIHRoaXMuY2FsY0p1bGlhbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjICBVcGRhdGUgZnJvbSBQZXJzaWFuIGNhbGVuZGFyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gZGF0ZUFycmF5XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjYWxjUGVyc2lhbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjUGVyc2lhbihkYXRlQXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChkYXRlQXJyYXlbMF0gfHwgZGF0ZUFycmF5WzBdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5TdGF0ZS5wZXJzaWFuLnllYXIgPSBkYXRlQXJyYXlbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUFycmF5WzFdIHx8IGRhdGVBcnJheVsxXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuU3RhdGUucGVyc2lhbi5tb250aCA9IGRhdGVBcnJheVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRlQXJyYXlbMl0gfHwgZGF0ZUFycmF5WzJdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5TdGF0ZS5wZXJzaWFuLmRheSA9IGRhdGVBcnJheVsyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRlQXJyYXlbM10gfHwgZGF0ZUFycmF5WzNdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5TdGF0ZS5ncmVnb3JpYW4uaG91ciA9IGRhdGVBcnJheVszXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRlQXJyYXlbNF0gfHwgZGF0ZUFycmF5WzRdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5TdGF0ZS5ncmVnb3JpYW4ubWludXRlID0gZGF0ZUFycmF5WzRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGVBcnJheVs1XSB8fCBkYXRlQXJyYXlbNV0gPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLlN0YXRlLmdyZWdvcmlhbi5zZWNvbmQgPSBkYXRlQXJyYXlbNV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUFycmF5WzZdIHx8IGRhdGVBcnJheVs2XSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuU3RhdGUuZ3JlZ29yaWFuLm1pbGxpc2Vjb25kID0gZGF0ZUFycmF5WzZdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNldEp1bGlhbih0aGlzLnBlcnNpYW5fdG9famQodGhpcy5TdGF0ZS5wZXJzaWFuLnllYXIsIHRoaXMuU3RhdGUucGVyc2lhbi5tb250aCwgdGhpcy5TdGF0ZS5wZXJzaWFuLmRheSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjIFVwZGF0ZSBmcm9tIFBlcnNpYW4gYXN0cm9ub21pY2FsIGNhbGVuZGFyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gZGF0ZUFycmF5XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjYWxjUGVyc2lhbmEnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY1BlcnNpYW5hKGRhdGVBcnJheSkge1xuICAgICAgICAgICAgaWYgKGRhdGVBcnJheVswXSB8fCBkYXRlQXJyYXlbMF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLlN0YXRlLnBlcnNpYW5Bc3Ryby55ZWFyID0gZGF0ZUFycmF5WzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGVBcnJheVsxXSB8fCBkYXRlQXJyYXlbMV0gPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLlN0YXRlLnBlcnNpYW5Bc3Ryby5tb250aCA9IGRhdGVBcnJheVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRlQXJyYXlbMl0gfHwgZGF0ZUFycmF5WzJdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5TdGF0ZS5wZXJzaWFuQXN0cm8uZGF5ID0gZGF0ZUFycmF5WzJdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0ZUFycmF5WzNdIHx8IGRhdGVBcnJheVszXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuU3RhdGUuZ3JlZ29yaWFuLmhvdXIgPSBkYXRlQXJyYXlbM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUFycmF5WzRdIHx8IGRhdGVBcnJheVs0XSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuU3RhdGUuZ3JlZ29yaWFuLm1pbnV0ZSA9IGRhdGVBcnJheVs0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRlQXJyYXlbNV0gfHwgZGF0ZUFycmF5WzVdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5TdGF0ZS5ncmVnb3JpYW4uc2Vjb25kID0gZGF0ZUFycmF5WzVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGVBcnJheVs2XSB8fCBkYXRlQXJyYXlbNl0gPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLlN0YXRlLmdyZWdvcmlhbi5taWxsaXNlY29uZCA9IGRhdGVBcnJheVs2XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0SnVsaWFuKHRoaXMucGVyc2lhbmFfdG9famQodGhpcy5TdGF0ZS5wZXJzaWFuQXN0cm8ueWVhciwgdGhpcy5TdGF0ZS5wZXJzaWFuQXN0cm8ubW9udGgsIHRoaXMuU3RhdGUucGVyc2lhbkFzdHJvLmRheSArIDAuNSkpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEFsZ29yaXRobXM7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQWxnb3JpdGhtcztcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qXG4gSmF2YVNjcmlwdCBmdW5jdGlvbnMgZm9yIHBvc2l0aW9uYWwgYXN0cm9ub215XG4gYnkgSm9obiBXYWxrZXIgIC0tICBTZXB0ZW1iZXIsIE1JTVxuIGh0dHA6Ly93d3cuZm91cm1pbGFiLmNoL1xuIFRoaXMgcHJvZ3JhbSBpcyBpbiB0aGUgcHVibGljIGRvbWFpbi5cbiAqL1xuXG52YXIgQVNUUk8gPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQVNUUk8oKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBU1RSTyk7XG5cbiAgICAgICAgLy8gIEZyZXF1ZW50bHktdXNlZCBjb25zdGFudHNcbiAgICAgICAgdGhpcy5KMjAwMCA9IDI0NTE1NDUuMDsgLy8gSnVsaWFuIGRheSBvZiBKMjAwMCBlcG9jaFxuICAgICAgICB0aGlzLkp1bGlhbkNlbnR1cnkgPSAzNjUyNS4wOyAvLyBEYXlzIGluIEp1bGlhbiBjZW50dXJ5XG4gICAgICAgIHRoaXMuSnVsaWFuTWlsbGVubml1bSA9IHRoaXMuSnVsaWFuQ2VudHVyeSAqIDEwOyAvLyBEYXlzIGluIEp1bGlhbiBtaWxsZW5uaXVtXG4gICAgICAgIC8vICAgICAgICB0aGlzLkFzdHJvbm9taWNhbFVuaXQgPSAxNDk1OTc4NzAuMDsgICAgICAgICAgIC8vIEFzdHJvbm9taWNhbCB1bml0IGluIGtpbG9tZXRyZXNcbiAgICAgICAgdGhpcy5Ucm9waWNhbFllYXIgPSAzNjUuMjQyMTk4Nzg7IC8vIE1lYW4gc29sYXIgdHJvcGljYWwgeWVhclxuXG4gICAgICAgIC8qICBPQkxJUUVRICAtLSAgQ2FsY3VsYXRlIHRoZSBvYmxpcXVpdHkgb2YgdGhlIGVjbGlwdGljIGZvciBhIGdpdmVuXG4gICAgICAgICBKdWxpYW4gZGF0ZS4gIFRoaXMgdXNlcyBMYXNrYXIncyB0ZW50aC1kZWdyZWVcbiAgICAgICAgIHBvbHlub21pYWwgZml0IChKLiBMYXNrYXIsIEFzdHJvbm9teSBhbmRcbiAgICAgICAgIEFzdHJvcGh5c2ljcywgVm9sLiAxNTcsIHBhZ2UgNjggWzE5ODZdKSB3aGljaCBpc1xuICAgICAgICAgYWNjdXJhdGUgdG8gd2l0aGluIDAuMDEgYXJjIHNlY29uZCBiZXR3ZWVuIEFEIDEwMDBcbiAgICAgICAgIGFuZCBBRCAzMDAwLCBhbmQgd2l0aGluIGEgZmV3IHNlY29uZHMgb2YgYXJjIGZvclxuICAgICAgICAgKy8tMTAwMDAgeWVhcnMgYXJvdW5kIEFEIDIwMDAuICBJZiB3ZSdyZSBvdXRzaWRlIHRoZVxuICAgICAgICAgcmFuZ2UgaW4gd2hpY2ggdGhpcyBmaXQgaXMgdmFsaWQgKGRlZXAgdGltZSkgd2VcbiAgICAgICAgIHNpbXBseSByZXR1cm4gdGhlIEoyMDAwIHZhbHVlIG9mIHRoZSBvYmxpcXVpdHksIHdoaWNoXG4gICAgICAgICBoYXBwZW5zIHRvIGJlIGFsbW9zdCBwcmVjaXNlbHkgdGhlIG1lYW4uICAqL1xuICAgICAgICB0aGlzLm90ZXJtcyA9IFstNDY4MC45MywgLTEuNTUsIDE5OTkuMjUsIC01MS4zOCwgLTI0OS42NywgLTM5LjA1LCA3LjEyLCAyNy44NywgNS43OSwgMi40NV07XG4gICAgICAgIC8qIFBlcmlvZGljIHRlcm1zIGZvciBudXRhdGlvbiBpbiBsb25naXVkZSAoZGVsdGEgXFxQc2kpIGFuZFxuICAgICAgICAgb2JsaXF1aXR5IChkZWx0YSBcXEVwc2lsb24pIGFzIGdpdmVuIGluIHRhYmxlIDIxLkEgb2ZcbiAgICAgICAgIE1lZXVzLCBcIkFzdHJvbm9taWNhbCBBbGdvcml0aG1zXCIsIGZpcnN0IGVkaXRpb24uICovXG4gICAgICAgIHRoaXMubnV0QXJnTXVsdCA9IFswLCAwLCAwLCAwLCAxLCAtMiwgMCwgMCwgMiwgMiwgMCwgMCwgMCwgMiwgMiwgMCwgMCwgMCwgMCwgMiwgMCwgMSwgMCwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgLTIsIDEsIDAsIDIsIDIsIDAsIDAsIDAsIDIsIDEsIDAsIDAsIDEsIDIsIDIsIC0yLCAtMSwgMCwgMiwgMiwgLTIsIDAsIDEsIDAsIDAsIC0yLCAwLCAwLCAyLCAxLCAwLCAwLCAtMSwgMiwgMiwgMiwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMCwgMSwgMiwgMCwgLTEsIDIsIDIsIDAsIDAsIC0xLCAwLCAxLCAwLCAwLCAxLCAyLCAxLCAtMiwgMCwgMiwgMCwgMCwgMCwgMCwgLTIsIDIsIDEsIDIsIDAsIDAsIDIsIDIsIDAsIDAsIDIsIDIsIDIsIDAsIDAsIDIsIDAsIDAsIC0yLCAwLCAxLCAyLCAyLCAwLCAwLCAwLCAyLCAwLCAtMiwgMCwgMCwgMiwgMCwgMCwgMCwgLTEsIDIsIDEsIDAsIDIsIDAsIDAsIDAsIDIsIDAsIC0xLCAwLCAxLCAtMiwgMiwgMCwgMiwgMiwgMCwgMSwgMCwgMCwgMSwgLTIsIDAsIDEsIDAsIDEsIDAsIC0xLCAwLCAwLCAxLCAwLCAwLCAyLCAtMiwgMCwgMiwgMCwgLTEsIDIsIDEsIDIsIDAsIDEsIDIsIDIsIDAsIDEsIDAsIDIsIDIsIC0yLCAxLCAxLCAwLCAwLCAwLCAtMSwgMCwgMiwgMiwgMiwgMCwgMCwgMiwgMSwgMiwgMCwgMSwgMCwgMCwgLTIsIDAsIDIsIDIsIDIsIC0yLCAwLCAxLCAyLCAxLCAyLCAwLCAtMiwgMCwgMSwgMiwgMCwgMCwgMCwgMSwgMCwgLTEsIDEsIDAsIDAsIC0yLCAtMSwgMCwgMiwgMSwgLTIsIDAsIDAsIDAsIDEsIDAsIDAsIDIsIDIsIDEsIC0yLCAwLCAyLCAwLCAxLCAtMiwgMSwgMCwgMiwgMSwgMCwgMCwgMSwgLTIsIDAsIC0xLCAwLCAxLCAwLCAwLCAtMiwgMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMiwgMCwgLTEsIC0xLCAxLCAwLCAwLCAwLCAxLCAxLCAwLCAwLCAwLCAtMSwgMSwgMiwgMiwgMiwgLTEsIC0xLCAyLCAyLCAwLCAwLCAtMiwgMiwgMiwgMCwgMCwgMywgMiwgMiwgMiwgLTEsIDAsIDIsIDJdO1xuXG4gICAgICAgIHRoaXMubnV0QXJnQ29lZmYgPSBbLTE3MTk5NiwgLTE3NDIsIDkyMDk1LCA4OSwgLyogIDAsICAwLCAgMCwgIDAsICAxICovXG4gICAgICAgIC0xMzE4NywgLTE2LCA1NzM2LCAtMzEsIC8qIC0yLCAgMCwgIDAsICAyLCAgMiAqL1xuICAgICAgICAtMjI3NCwgLTIsIDk3NywgLTUsIC8qICAwLCAgMCwgIDAsICAyLCAgMiAqL1xuICAgICAgICAyMDYyLCAyLCAtODk1LCA1LCAvKiAgMCwgIDAsICAwLCAgMCwgIDIgKi9cbiAgICAgICAgMTQyNiwgLTM0LCA1NCwgLTEsIC8qICAwLCAgMSwgIDAsICAwLCAgMCAqL1xuICAgICAgICA3MTIsIDEsIC03LCAwLCAvKiAgMCwgIDAsICAxLCAgMCwgIDAgKi9cbiAgICAgICAgLTUxNywgMTIsIDIyNCwgLTYsIC8qIC0yLCAgMSwgIDAsICAyLCAgMiAqL1xuICAgICAgICAtMzg2LCAtNCwgMjAwLCAwLCAvKiAgMCwgIDAsICAwLCAgMiwgIDEgKi9cbiAgICAgICAgLTMwMSwgMCwgMTI5LCAtMSwgLyogIDAsICAwLCAgMSwgIDIsICAyICovXG4gICAgICAgIDIxNywgLTUsIC05NSwgMywgLyogLTIsIC0xLCAgMCwgIDIsICAyICovXG4gICAgICAgIC0xNTgsIDAsIDAsIDAsIC8qIC0yLCAgMCwgIDEsICAwLCAgMCAqL1xuICAgICAgICAxMjksIDEsIC03MCwgMCwgLyogLTIsICAwLCAgMCwgIDIsICAxICovXG4gICAgICAgIDEyMywgMCwgLTUzLCAwLCAvKiAgMCwgIDAsIC0xLCAgMiwgIDIgKi9cbiAgICAgICAgNjMsIDAsIDAsIDAsIC8qICAyLCAgMCwgIDAsICAwLCAgMCAqL1xuICAgICAgICA2MywgMSwgLTMzLCAwLCAvKiAgMCwgIDAsICAxLCAgMCwgIDEgKi9cbiAgICAgICAgLTU5LCAwLCAyNiwgMCwgLyogIDIsICAwLCAtMSwgIDIsICAyICovXG4gICAgICAgIC01OCwgLTEsIDMyLCAwLCAvKiAgMCwgIDAsIC0xLCAgMCwgIDEgKi9cbiAgICAgICAgLTUxLCAwLCAyNywgMCwgLyogIDAsICAwLCAgMSwgIDIsICAxICovXG4gICAgICAgIDQ4LCAwLCAwLCAwLCAvKiAtMiwgIDAsICAyLCAgMCwgIDAgKi9cbiAgICAgICAgNDYsIDAsIC0yNCwgMCwgLyogIDAsICAwLCAtMiwgIDIsICAxICovXG4gICAgICAgIC0zOCwgMCwgMTYsIDAsIC8qICAyLCAgMCwgIDAsICAyLCAgMiAqL1xuICAgICAgICAtMzEsIDAsIDEzLCAwLCAvKiAgMCwgIDAsICAyLCAgMiwgIDIgKi9cbiAgICAgICAgMjksIDAsIDAsIDAsIC8qICAwLCAgMCwgIDIsICAwLCAgMCAqL1xuICAgICAgICAyOSwgMCwgLTEyLCAwLCAvKiAtMiwgIDAsICAxLCAgMiwgIDIgKi9cbiAgICAgICAgMjYsIDAsIDAsIDAsIC8qICAwLCAgMCwgIDAsICAyLCAgMCAqL1xuICAgICAgICAtMjIsIDAsIDAsIDAsIC8qIC0yLCAgMCwgIDAsICAyLCAgMCAqL1xuICAgICAgICAyMSwgMCwgLTEwLCAwLCAvKiAgMCwgIDAsIC0xLCAgMiwgIDEgKi9cbiAgICAgICAgMTcsIC0xLCAwLCAwLCAvKiAgMCwgIDIsICAwLCAgMCwgIDAgKi9cbiAgICAgICAgMTYsIDAsIC04LCAwLCAvKiAgMiwgIDAsIC0xLCAgMCwgIDEgKi9cbiAgICAgICAgLTE2LCAxLCA3LCAwLCAvKiAtMiwgIDIsICAwLCAgMiwgIDIgKi9cbiAgICAgICAgLTE1LCAwLCA5LCAwLCAvKiAgMCwgIDEsICAwLCAgMCwgIDEgKi9cbiAgICAgICAgLTEzLCAwLCA3LCAwLCAvKiAtMiwgIDAsICAxLCAgMCwgIDEgKi9cbiAgICAgICAgLTEyLCAwLCA2LCAwLCAvKiAgMCwgLTEsICAwLCAgMCwgIDEgKi9cbiAgICAgICAgMTEsIDAsIDAsIDAsIC8qICAwLCAgMCwgIDIsIC0yLCAgMCAqL1xuICAgICAgICAtMTAsIDAsIDUsIDAsIC8qICAyLCAgMCwgLTEsICAyLCAgMSAqL1xuICAgICAgICAtOCwgMCwgMywgMCwgLyogIDIsICAwLCAgMSwgIDIsICAyICovXG4gICAgICAgIDcsIDAsIC0zLCAwLCAvKiAgMCwgIDEsICAwLCAgMiwgIDIgKi9cbiAgICAgICAgLTcsIDAsIDAsIDAsIC8qIC0yLCAgMSwgIDEsICAwLCAgMCAqL1xuICAgICAgICAtNywgMCwgMywgMCwgLyogIDAsIC0xLCAgMCwgIDIsICAyICovXG4gICAgICAgIC03LCAwLCAzLCAwLCAvKiAgMiwgIDAsICAwLCAgMiwgIDEgKi9cbiAgICAgICAgNiwgMCwgMCwgMCwgLyogIDIsICAwLCAgMSwgIDAsICAwICovXG4gICAgICAgIDYsIDAsIC0zLCAwLCAvKiAtMiwgIDAsICAyLCAgMiwgIDIgKi9cbiAgICAgICAgNiwgMCwgLTMsIDAsIC8qIC0yLCAgMCwgIDEsICAyLCAgMSAqL1xuICAgICAgICAtNiwgMCwgMywgMCwgLyogIDIsICAwLCAtMiwgIDAsICAxICovXG4gICAgICAgIC02LCAwLCAzLCAwLCAvKiAgMiwgIDAsICAwLCAgMCwgIDEgKi9cbiAgICAgICAgNSwgMCwgMCwgMCwgLyogIDAsIC0xLCAgMSwgIDAsICAwICovXG4gICAgICAgIC01LCAwLCAzLCAwLCAvKiAtMiwgLTEsICAwLCAgMiwgIDEgKi9cbiAgICAgICAgLTUsIDAsIDMsIDAsIC8qIC0yLCAgMCwgIDAsICAwLCAgMSAqL1xuICAgICAgICAtNSwgMCwgMywgMCwgLyogIDAsICAwLCAgMiwgIDIsICAxICovXG4gICAgICAgIDQsIDAsIDAsIDAsIC8qIC0yLCAgMCwgIDIsICAwLCAgMSAqL1xuICAgICAgICA0LCAwLCAwLCAwLCAvKiAtMiwgIDEsICAwLCAgMiwgIDEgKi9cbiAgICAgICAgNCwgMCwgMCwgMCwgLyogIDAsICAwLCAgMSwgLTIsICAwICovXG4gICAgICAgIC00LCAwLCAwLCAwLCAvKiAtMSwgIDAsICAxLCAgMCwgIDAgKi9cbiAgICAgICAgLTQsIDAsIDAsIDAsIC8qIC0yLCAgMSwgIDAsICAwLCAgMCAqL1xuICAgICAgICAtNCwgMCwgMCwgMCwgLyogIDEsICAwLCAgMCwgIDAsICAwICovXG4gICAgICAgIDMsIDAsIDAsIDAsIC8qICAwLCAgMCwgIDEsICAyLCAgMCAqL1xuICAgICAgICAtMywgMCwgMCwgMCwgLyogLTEsIC0xLCAgMSwgIDAsICAwICovXG4gICAgICAgIC0zLCAwLCAwLCAwLCAvKiAgMCwgIDEsICAxLCAgMCwgIDAgKi9cbiAgICAgICAgLTMsIDAsIDAsIDAsIC8qICAwLCAtMSwgIDEsICAyLCAgMiAqL1xuICAgICAgICAtMywgMCwgMCwgMCwgLyogIDIsIC0xLCAtMSwgIDIsICAyICovXG4gICAgICAgIC0zLCAwLCAwLCAwLCAvKiAgMCwgIDAsIC0yLCAgMiwgIDIgKi9cbiAgICAgICAgLTMsIDAsIDAsIDAsIC8qICAwLCAgMCwgIDMsICAyLCAgMiAqL1xuICAgICAgICAtMywgMCwgMCwgMCAvKiAgMiwgLTEsICAwLCAgMiwgIDIgKi9cbiAgICAgICAgXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgVGFibGUgb2Ygb2JzZXJ2ZWQgRGVsdGEgVCB2YWx1ZXMgYXQgdGhlIGJlZ2lubmluZyBvZiBldmVuIG51bWJlcmVkIHllYXJzIGZyb20gMTYyMCB0aHJvdWdoIDIwMDIuXG4gICAgICAgICAqIEB0eXBlIEFycmF5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlbHRhVHRhYiA9IFsxMjEsIDExMiwgMTAzLCA5NSwgODgsIDgyLCA3NywgNzIsIDY4LCA2MywgNjAsIDU2LCA1MywgNTEsIDQ4LCA0NiwgNDQsIDQyLCA0MCwgMzgsIDM1LCAzMywgMzEsIDI5LCAyNiwgMjQsIDIyLCAyMCwgMTgsIDE2LCAxNCwgMTIsIDExLCAxMCwgOSwgOCwgNywgNywgNywgNywgNywgNywgOCwgOCwgOSwgOSwgOSwgOSwgOSwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMSwgMTEsIDExLCAxMSwgMTEsIDEyLCAxMiwgMTIsIDEyLCAxMywgMTMsIDEzLCAxNCwgMTQsIDE0LCAxNCwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE1LCAxNSwgMTQsIDEzLCAxMy4xLCAxMi41LCAxMi4yLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMS45LCAxMS42LCAxMSwgMTAuMiwgOS4yLCA4LjIsIDcuMSwgNi4yLCA1LjYsIDUuNCwgNS4zLCA1LjQsIDUuNiwgNS45LCA2LjIsIDYuNSwgNi44LCA3LjEsIDcuMywgNy41LCA3LjYsIDcuNywgNy4zLCA2LjIsIDUuMiwgMi43LCAxLjQsIC0xLjIsIC0yLjgsIC0zLjgsIC00LjgsIC01LjUsIC01LjMsIC01LjYsIC01LjcsIC01LjksIC02LCAtNi4zLCAtNi41LCAtNi4yLCAtNC43LCAtMi44LCAtMC4xLCAyLjYsIDUuMywgNy43LCAxMC40LCAxMy4zLCAxNiwgMTguMiwgMjAuMiwgMjEuMSwgMjIuNCwgMjMuNSwgMjMuOCwgMjQuMywgMjQsIDIzLjksIDIzLjksIDIzLjcsIDI0LCAyNC4zLCAyNS4zLCAyNi4yLCAyNy4zLCAyOC4yLCAyOS4xLCAzMCwgMzAuNywgMzEuNCwgMzIuMiwgMzMuMSwgMzQsIDM1LCAzNi41LCAzOC4zLCA0MC4yLCA0Mi4yLCA0NC41LCA0Ni41LCA0OC41LCA1MC41LCA1Mi4yLCA1My44LCA1NC45LCA1NS44LCA1Ni45LCA1OC4zLCA2MCwgNjEuNiwgNjMsIDY1LCA2Ni42XTtcblxuICAgICAgICAvKiAgRVFVSU5PWCAgLS0gIERldGVybWluZSB0aGUgSnVsaWFuIEVwaGVtZXJpcyBEYXkgb2YgYW5cbiAgICAgICAgIGVxdWlub3ggb3Igc29sc3RpY2UuICBUaGUgXCJ3aGljaFwiIGFyZ3VtZW50XG4gICAgICAgICBzZWxlY3RzIHRoZSBpdGVtIHRvIGJlIGNvbXB1dGVkOlxuICAgICAgICAgIDAgICBNYXJjaCBlcXVpbm94XG4gICAgICAgICAxICAgSnVuZSBzb2xzdGljZVxuICAgICAgICAgMiAgIFNlcHRlbWJlciBlcXVpbm94XG4gICAgICAgICAzICAgRGVjZW1iZXIgc29sc3RpY2VcbiAgICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgUGVyaW9kaWMgdGVybXMgdG8gb2J0YWluIHRydWUgdGltZVxuICAgICAgICAgKiBAdHlwZSBBcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5FcXVpbm94cFRlcm1zID0gWzQ4NSwgMzI0Ljk2LCAxOTM0LjEzNiwgMjAzLCAzMzcuMjMsIDMyOTY0LjQ2NywgMTk5LCAzNDIuMDgsIDIwLjE4NiwgMTgyLCAyNy44NSwgNDQ1MjY3LjExMiwgMTU2LCA3My4xNCwgNDUwMzYuODg2LCAxMzYsIDE3MS41MiwgMjI1MTguNDQzLCA3NywgMjIyLjU0LCA2NTkyOC45MzQsIDc0LCAyOTYuNzIsIDMwMzQuOTA2LCA3MCwgMjQzLjU4LCA5MDM3LjUxMywgNTgsIDExOS44MSwgMzM3MTguMTQ3LCA1MiwgMjk3LjE3LCAxNTAuNjc4LCA1MCwgMjEuMDIsIDIyODEuMjI2LCA0NSwgMjQ3LjU0LCAyOTkyOS41NjIsIDQ0LCAzMjUuMTUsIDMxNTU1Ljk1NiwgMjksIDYwLjkzLCA0NDQzLjQxNywgMTgsIDE1NS4xMiwgNjc1NTUuMzI4LCAxNywgMjg4Ljc5LCA0NTYyLjQ1MiwgMTYsIDE5OC4wNCwgNjI4OTQuMDI5LCAxNCwgMTk5Ljc2LCAzMTQzNi45MjEsIDEyLCA5NS4zOSwgMTQ1NzcuODQ4LCAxMiwgMjg3LjExLCAzMTkzMS43NTYsIDEyLCAzMjAuODEsIDM0Nzc3LjI1OSwgOSwgMjI3LjczLCAxMjIyLjExNCwgOCwgMTUuNDUsIDE2ODU5LjA3NF07XG5cbiAgICAgICAgdGhpcy5KREUwdGFiMTAwMCA9IFtuZXcgQXJyYXkoMTcyMTEzOS4yOTE4OSwgMzY1MjQyLjEzNzQwLCAwLjA2MTM0LCAwLjAwMTExLCAtMC4wMDA3MSksIG5ldyBBcnJheSgxNzIxMjMzLjI1NDAxLCAzNjUyNDEuNzI1NjIsIC0wLjA1MzIzLCAwLjAwOTA3LCAwLjAwMDI1KSwgbmV3IEFycmF5KDE3MjEzMjUuNzA0NTUsIDM2NTI0Mi40OTU1OCwgLTAuMTE2NzcsIC0wLjAwMjk3LCAwLjAwMDc0KSwgbmV3IEFycmF5KDE3MjE0MTQuMzk5ODcsIDM2NTI0Mi44ODI1NywgLTAuMDA3NjksIC0wLjAwOTMzLCAtMC4wMDAwNildO1xuXG4gICAgICAgIHRoaXMuSkRFMHRhYjIwMDAgPSBbbmV3IEFycmF5KDI0NTE2MjMuODA5ODQsIDM2NTI0Mi4zNzQwNCwgMC4wNTE2OSwgLTAuMDA0MTEsIC0wLjAwMDU3KSwgbmV3IEFycmF5KDI0NTE3MTYuNTY3NjcsIDM2NTI0MS42MjYwMywgMC4wMDMyNSwgMC4wMDg4OCwgLTAuMDAwMzApLCBuZXcgQXJyYXkoMjQ1MTgxMC4yMTcxNSwgMzY1MjQyLjAxNzY3LCAtMC4xMTU3NSwgMC4wMDMzNywgMC4wMDA3OCksIG5ldyBBcnJheSgyNDUxOTAwLjA1OTUyLCAzNjUyNDIuNzQwNDksIC0wLjA2MjIzLCAtMC4wMDgyMywgMC4wMDAzMildO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIERlZ3JlZXMgdG8gcmFkaWFucy5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhBU1RSTywgW3tcbiAgICAgICAga2V5OiBcImR0clwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZHRyKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkICogTWF0aC5QSSAvIDE4MC4wO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjIFJhZGlhbnMgdG8gZGVncmVlcy5cbiAgICAgICAgICogQHBhcmFtIHJcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInJ0ZFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcnRkKHIpIHtcbiAgICAgICAgICAgIHJldHVybiByICogMTgwLjAgLyBNYXRoLlBJO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjIFJhbmdlIHJlZHVjZSBhbmdsZSBpbiBkZWdyZWVzLlxuICAgICAgICAgKiBAcGFyYW0gYVxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZml4YW5nbGVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpeGFuZ2xlKGEpIHtcbiAgICAgICAgICAgIHJldHVybiBhIC0gMzYwLjAgKiBNYXRoLmZsb29yKGEgLyAzNjAuMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgUmFuZ2UgcmVkdWNlIGFuZ2xlIGluIHJhZGlhbnMuXG4gICAgICAgICAqIEBwYXJhbSBhXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJmaXhhbmdyXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaXhhbmdyKGEpIHtcbiAgICAgICAgICAgIHJldHVybiBhIC0gMiAqIE1hdGguUEkgKiBNYXRoLmZsb29yKGEgLyAoMiAqIE1hdGguUEkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyAgU2luZSBvZiBhbiBhbmdsZSBpbiBkZWdyZWVzXG4gICAgICAgICAqIEBwYXJhbSBkXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJkc2luXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkc2luKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNpbih0aGlzLmR0cihkKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgQ29zaW5lIG9mIGFuIGFuZ2xlIGluIGRlZ3JlZXNcbiAgICAgICAgICogQHBhcmFtIGRcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImRjb3NcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRjb3MoZCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY29zKHRoaXMuZHRyKGQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyBNb2R1bHVzIGZ1bmN0aW9uIHdoaWNoIHdvcmtzIGZvciBub24taW50ZWdlcnMuXG4gICAgICAgICAqIEBwYXJhbSBhXG4gICAgICAgICAqIEBwYXJhbSBiXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJtb2RcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1vZChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYSAtIGIgKiBNYXRoLmZsb29yKGEgLyBiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0galxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiandkYXlcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGp3ZGF5KGopIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZChNYXRoLmZsb29yKGogKyAxLjUpLCA3KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gamRcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfCp9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwib2JsaXFlcVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb2JsaXFlcShqZCkge1xuICAgICAgICAgICAgdmFyIGVwcywgdSwgdiwgaTtcbiAgICAgICAgICAgIHYgPSB1ID0gKGpkIC0gdGhpcy5KMjAwMCkgLyAodGhpcy5KdWxpYW5DZW50dXJ5ICogMTAwKTtcbiAgICAgICAgICAgIGVwcyA9IDIzICsgMjYgLyA2MC4wICsgMjEuNDQ4IC8gMzYwMC4wO1xuXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModSkgPCAxLjApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBlcHMgKz0gdGhpcy5vdGVybXNbaV0gLyAzNjAwLjAgKiB2O1xuICAgICAgICAgICAgICAgICAgICB2ICo9IHU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVwcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyAgQ2FsY3VsYXRlIHRoZSBudXRhdGlvbiBpbiBsb25naXR1ZGUsIGRlbHRhUHNpLCBhbmRcbiAgICAgICAgIG9ibGlxdWl0eSwgZGVsdGFFcHNpbG9uIGZvciBhIGdpdmVuIEp1bGlhbiBkYXRlXG4gICAgICAgICBqZC4gIFJlc3VsdHMgYXJlIHJldHVybmVkIGFzIGEgdHdvIGVsZW1lbnQgQXJyYXlcbiAgICAgICAgIGdpdmluZyAoZGVsdGFQc2ksIGRlbHRhRXBzaWxvbikgaW4gZGVncmVlcy5cbiAgICAgICAgICogQHBhcmFtIGpkXG4gICAgICAgICAqIEByZXR1cm4gT2JqZWN0XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwibnV0YXRpb25cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG51dGF0aW9uKGpkKSB7XG4gICAgICAgICAgICB2YXIgZGVsdGFQc2ksXG4gICAgICAgICAgICAgICAgZGVsdGFFcHNpbG9uLFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgaixcbiAgICAgICAgICAgICAgICB0ID0gKGpkIC0gMjQ1MTU0NS4wKSAvIDM2NTI1LjAsXG4gICAgICAgICAgICAgICAgdDIsXG4gICAgICAgICAgICAgICAgdDMsXG4gICAgICAgICAgICAgICAgdG8xMCxcbiAgICAgICAgICAgICAgICB0YSA9IFtdLFxuICAgICAgICAgICAgICAgIGRwID0gMCxcbiAgICAgICAgICAgICAgICBkZSA9IDAsXG4gICAgICAgICAgICAgICAgYW5nO1xuXG4gICAgICAgICAgICB0MyA9IHQgKiAodDIgPSB0ICogdCk7XG5cbiAgICAgICAgICAgIC8qIENhbGN1bGF0ZSBhbmdsZXMuICBUaGUgY29ycmVzcG9uZGVuY2UgYmV0d2VlbiB0aGUgZWxlbWVudHNcbiAgICAgICAgICAgICBvZiBvdXIgYXJyYXkgYW5kIHRoZSB0ZXJtcyBjaXRlZCBpbiBNZWV1cyBhcmU6XG4gICAgICAgICAgICAgIHRhWzBdID0gRCAgdGFbMF0gPSBNICB0YVsyXSA9IE0nICB0YVszXSA9IEYgIHRhWzRdID0gXFxPbWVnYVxuICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB0YVswXSA9IHRoaXMuZHRyKDI5Ny44NTAzNjMgKyA0NDUyNjcuMTExNDggKiB0IC0gMC4wMDE5MTQyICogdDIgKyB0MyAvIDE4OTQ3NC4wKTtcbiAgICAgICAgICAgIHRhWzFdID0gdGhpcy5kdHIoMzU3LjUyNzcyICsgMzU5OTkuMDUwMzQgKiB0IC0gMC4wMDAxNjAzICogdDIgLSB0MyAvIDMwMDAwMC4wKTtcbiAgICAgICAgICAgIHRhWzJdID0gdGhpcy5kdHIoMTM0Ljk2Mjk4ICsgNDc3MTk4Ljg2NzM5OCAqIHQgKyAwLjAwODY5NzIgKiB0MiArIHQzIC8gNTYyNTAuMCk7XG4gICAgICAgICAgICB0YVszXSA9IHRoaXMuZHRyKDkzLjI3MTkxICsgNDgzMjAyLjAxNzUzOCAqIHQgLSAwLjAwMzY4MjUgKiB0MiArIHQzIC8gMzI3MjcwKTtcbiAgICAgICAgICAgIHRhWzRdID0gdGhpcy5kdHIoMTI1LjA0NDUyIC0gMTkzNC4xMzYyNjEgKiB0ICsgMC4wMDIwNzA4ICogdDIgKyB0MyAvIDQ1MDAwMC4wKTtcblxuICAgICAgICAgICAgLyogUmFuZ2UgcmVkdWNlIHRoZSBhbmdsZXMgaW4gY2FzZSB0aGUgc2luZSBhbmQgY29zaW5lIGZ1bmN0aW9uc1xuICAgICAgICAgICAgIGRvbid0IGRvIGl0IGFzIGFjY3VyYXRlbHkgb3IgcXVpY2tseS4gKi9cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgICAgIHRhW2ldID0gdGhpcy5maXhhbmdyKHRhW2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG8xMCA9IHQgLyAxMC4wO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDYzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhbmcgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCA1OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubnV0QXJnTXVsdFtpICogNSArIGpdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmcgKz0gdGhpcy5udXRBcmdNdWx0W2kgKiA1ICsgal0gKiB0YVtqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkcCArPSAodGhpcy5udXRBcmdDb2VmZltpICogNCArIDBdICsgdGhpcy5udXRBcmdDb2VmZltpICogNCArIDFdICogdG8xMCkgKiBNYXRoLnNpbihhbmcpO1xuICAgICAgICAgICAgICAgIGRlICs9ICh0aGlzLm51dEFyZ0NvZWZmW2kgKiA0ICsgMl0gKyB0aGlzLm51dEFyZ0NvZWZmW2kgKiA0ICsgM10gKiB0bzEwKSAqIE1hdGguY29zKGFuZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qIFJldHVybiB0aGUgcmVzdWx0LCBjb252ZXJ0aW5nIGZyb20gdGVuIHRob3VzYW5kdGhzIG9mIGFyY1xuICAgICAgICAgICAgIHNlY29uZHMgdG8gcmFkaWFucyBpbiB0aGUgcHJvY2Vzcy4gKi9cblxuICAgICAgICAgICAgZGVsdGFQc2kgPSBkcCAvICgzNjAwLjAgKiAxMDAwMC4wKTtcbiAgICAgICAgICAgIGRlbHRhRXBzaWxvbiA9IGRlIC8gKDM2MDAuMCAqIDEwMDAwLjApO1xuXG4gICAgICAgICAgICByZXR1cm4gW2RlbHRhUHNpLCBkZWx0YUVwc2lsb25dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjICBEZXRlcm1pbmUgdGhlIGRpZmZlcmVuY2UsIGluIHNlY29uZHMsIGJldHdlZW5cbiAgICAgICAgIER5bmFtaWNhbCB0aW1lIGFuZCBVbml2ZXJzYWwgdGltZS5cbiAgICAgICAgICogQHBhcmFtIHllYXJcbiAgICAgICAgICogQHJldHVybiB7Kn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJkZWx0YXRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlbHRhdCh5ZWFyKSB7XG4gICAgICAgICAgICB2YXIgZHQsIGYsIGksIHQ7XG5cbiAgICAgICAgICAgIGlmICh5ZWFyID49IDE2MjAgJiYgeWVhciA8PSAyMDAwKSB7XG4gICAgICAgICAgICAgICAgaSA9IE1hdGguZmxvb3IoKHllYXIgLSAxNjIwKSAvIDIpO1xuICAgICAgICAgICAgICAgIGYgPSAoeWVhciAtIDE2MjApIC8gMiAtIGk7XG4gICAgICAgICAgICAgICAgLyogRnJhY3Rpb25hbCBwYXJ0IG9mIHllYXIgKi9cbiAgICAgICAgICAgICAgICBkdCA9IHRoaXMuZGVsdGFUdGFiW2ldICsgKHRoaXMuZGVsdGFUdGFiW2kgKyAxXSAtIHRoaXMuZGVsdGFUdGFiW2ldKSAqIGY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHQgPSAoeWVhciAtIDIwMDApIC8gMTAwO1xuICAgICAgICAgICAgICAgIGlmICh5ZWFyIDwgOTQ4KSB7XG4gICAgICAgICAgICAgICAgICAgIGR0ID0gMjE3NyArIDQ5NyAqIHQgKyA0NC4xICogdCAqIHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZHQgPSAxMDIgKyAxMDIgKiB0ICsgMjUuMyAqIHQgKiB0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoeWVhciA+IDIwMDAgJiYgeWVhciA8IDIxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR0ICs9IDAuMzcgKiAoeWVhciAtIDIxMDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGR0O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB5ZWFyXG4gICAgICAgICAqIEBwYXJhbSB3aGljaFxuICAgICAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImVxdWlub3hcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWlub3goeWVhciwgd2hpY2gpIHtcbiAgICAgICAgICAgIHZhciBkZWx0YUwgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgaSA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBqID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIEpERTAgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgSkRFID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIEpERTB0YWIgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgUyA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBUID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIFcgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgWSA9IHZvaWQgMDtcbiAgICAgICAgICAgIC8qICBJbml0aWFsaXNlIHRlcm1zIGZvciBtZWFuIGVxdWlub3ggYW5kIHNvbHN0aWNlcy4gIFdlXG4gICAgICAgICAgICAgaGF2ZSB0d28gc2V0czogb25lIGZvciB5ZWFycyBwcmlvciB0byAxMDAwIGFuZCBhIHNlY29uZFxuICAgICAgICAgICAgIGZvciBzdWJzZXF1ZW50IHllYXJzLiAgKi9cblxuICAgICAgICAgICAgaWYgKHllYXIgPCAxMDAwKSB7XG4gICAgICAgICAgICAgICAgSkRFMHRhYiA9IHRoaXMuSkRFMHRhYjEwMDA7XG4gICAgICAgICAgICAgICAgWSA9IHllYXIgLyAxMDAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBKREUwdGFiID0gdGhpcy5KREUwdGFiMjAwMDtcbiAgICAgICAgICAgICAgICBZID0gKHllYXIgLSAyMDAwKSAvIDEwMDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEpERTAgPSBKREUwdGFiW3doaWNoXVswXSArIEpERTB0YWJbd2hpY2hdWzFdICogWSArIEpERTB0YWJbd2hpY2hdWzJdICogWSAqIFkgKyBKREUwdGFiW3doaWNoXVszXSAqIFkgKiBZICogWSArIEpERTB0YWJbd2hpY2hdWzRdICogWSAqIFkgKiBZICogWTtcbiAgICAgICAgICAgIFQgPSAoSkRFMCAtIDI0NTE1NDUuMCkgLyAzNjUyNTtcbiAgICAgICAgICAgIFcgPSAzNTk5OS4zNzMgKiBUIC0gMi40NztcbiAgICAgICAgICAgIGRlbHRhTCA9IDEgKyAwLjAzMzQgKiB0aGlzLmRjb3MoVykgKyAwLjAwMDcgKiB0aGlzLmRjb3MoMiAqIFcpO1xuICAgICAgICAgICAgUyA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSBqID0gMDsgaSA8IDI0OyBpKyspIHtcbiAgICAgICAgICAgICAgICBTICs9IHRoaXMuRXF1aW5veHBUZXJtc1tqXSAqIHRoaXMuZGNvcyh0aGlzLkVxdWlub3hwVGVybXNbaiArIDFdICsgdGhpcy5FcXVpbm94cFRlcm1zW2ogKyAyXSAqIFQpO1xuICAgICAgICAgICAgICAgIGogKz0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEpERSA9IEpERTAgKyBTICogMC4wMDAwMSAvIGRlbHRhTDtcbiAgICAgICAgICAgIHJldHVybiBKREU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgIFBvc2l0aW9uIG9mIHRoZSBTdW4uICBQbGVhc2Ugc2VlIHRoZSBjb21tZW50c1xuICAgICAgICAgb24gdGhlIHJldHVybiBzdGF0ZW1lbnQgYXQgdGhlIGVuZCBvZiB0aGlzIGZ1bmN0aW9uXG4gICAgICAgICB3aGljaCBkZXNjcmliZSB0aGUgYXJyYXkgaXQgcmV0dXJucy4gIFdlIHJldHVyblxuICAgICAgICAgaW50ZXJtZWRpYXRlIHZhbHVlcyBiZWNhdXNlIHRoZXkgYXJlIHVzZWZ1bCBpbiBhXG4gICAgICAgICB2YXJpZXR5IG9mIG90aGVyIGNvbnRleHRzLlxuICAgICAgICAgKiBAcGFyYW0gamRcbiAgICAgICAgICogQHJldHVybiBPYmplY3RcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJzdW5wb3NcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN1bnBvcyhqZCkge1xuICAgICAgICAgICAgdmFyIFQgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgVDIgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgTDAgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgTSA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBlID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIEMgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgc3VuTG9uZyA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBzdW5Bbm9tYWx5ID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIHN1blIgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgT21lZ2EgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgTGFtYmRhID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGVwc2lsb24gPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgZXBzaWxvbjAgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgQWxwaGEgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgRGVsdGEgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgQWxwaGFBcHAgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgRGVsdGFBcHAgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIFQgPSAoamQgLSB0aGlzLkoyMDAwKSAvIHRoaXMuSnVsaWFuQ2VudHVyeTtcbiAgICAgICAgICAgIFQyID0gVCAqIFQ7XG4gICAgICAgICAgICBMMCA9IDI4MC40NjY0NiArIDM2MDAwLjc2OTgzICogVCArIDAuMDAwMzAzMiAqIFQyO1xuICAgICAgICAgICAgTDAgPSB0aGlzLmZpeGFuZ2xlKEwwKTtcbiAgICAgICAgICAgIE0gPSAzNTcuNTI5MTEgKyAzNTk5OS4wNTAyOSAqIFQgKyAtMC4wMDAxNTM3ICogVDI7XG4gICAgICAgICAgICBNID0gdGhpcy5maXhhbmdsZShNKTtcbiAgICAgICAgICAgIGUgPSAwLjAxNjcwODYzNCArIC0wLjAwMDA0MjAzNyAqIFQgKyAtMC4wMDAwMDAxMjY3ICogVDI7XG4gICAgICAgICAgICBDID0gKDEuOTE0NjAyICsgLTAuMDA0ODE3ICogVCArIC0wLjAwMDAxNCAqIFQyKSAqIHRoaXMuZHNpbihNKSArICgwLjAxOTk5MyAtIDAuMDAwMTAxICogVCkgKiB0aGlzLmRzaW4oMiAqIE0pICsgMC4wMDAyODkgKiB0aGlzLmRzaW4oMyAqIE0pO1xuICAgICAgICAgICAgc3VuTG9uZyA9IEwwICsgQztcbiAgICAgICAgICAgIHN1bkFub21hbHkgPSBNICsgQztcbiAgICAgICAgICAgIHN1blIgPSAxLjAwMDAwMTAxOCAqICgxIC0gZSAqIGUpIC8gKDEgKyBlICogdGhpcy5kY29zKHN1bkFub21hbHkpKTtcbiAgICAgICAgICAgIE9tZWdhID0gMTI1LjA0IC0gMTkzNC4xMzYgKiBUO1xuICAgICAgICAgICAgTGFtYmRhID0gc3VuTG9uZyArIC0wLjAwNTY5ICsgLTAuMDA0NzggKiB0aGlzLmRzaW4oT21lZ2EpO1xuICAgICAgICAgICAgZXBzaWxvbjAgPSB0aGlzLm9ibGlxZXEoamQpO1xuICAgICAgICAgICAgZXBzaWxvbiA9IGVwc2lsb24wICsgMC4wMDI1NiAqIHRoaXMuZGNvcyhPbWVnYSk7XG4gICAgICAgICAgICBBbHBoYSA9IHRoaXMucnRkKE1hdGguYXRhbjIodGhpcy5kY29zKGVwc2lsb24wKSAqIHRoaXMuZHNpbihzdW5Mb25nKSwgdGhpcy5kY29zKHN1bkxvbmcpKSk7XG4gICAgICAgICAgICBBbHBoYSA9IHRoaXMuZml4YW5nbGUoQWxwaGEpO1xuICAgICAgICAgICAgRGVsdGEgPSB0aGlzLnJ0ZChNYXRoLmFzaW4odGhpcy5kc2luKGVwc2lsb24wKSAqIHRoaXMuZHNpbihzdW5Mb25nKSkpO1xuICAgICAgICAgICAgQWxwaGFBcHAgPSB0aGlzLnJ0ZChNYXRoLmF0YW4yKHRoaXMuZGNvcyhlcHNpbG9uKSAqIHRoaXMuZHNpbihMYW1iZGEpLCB0aGlzLmRjb3MoTGFtYmRhKSkpO1xuICAgICAgICAgICAgQWxwaGFBcHAgPSB0aGlzLmZpeGFuZ2xlKEFscGhhQXBwKTtcbiAgICAgICAgICAgIERlbHRhQXBwID0gdGhpcy5ydGQoTWF0aC5hc2luKHRoaXMuZHNpbihlcHNpbG9uKSAqIHRoaXMuZHNpbihMYW1iZGEpKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBbLy8gIEFuZ3VsYXIgcXVhbnRpdGllcyBhcmUgZXhwcmVzc2VkIGluIGRlY2ltYWwgZGVncmVlc1xuICAgICAgICAgICAgTDAsIC8vICBbMF0gR2VvbWV0cmljIG1lYW4gbG9uZ2l0dWRlIG9mIHRoZSBTdW5cbiAgICAgICAgICAgIE0sIC8vICBbMV0gTWVhbiBhbm9tYWx5IG9mIHRoZSBTdW5cbiAgICAgICAgICAgIGUsIC8vICBbMl0gRWNjZW50cmljaXR5IG9mIHRoZSBFYXJ0aCdzIG9yYml0XG4gICAgICAgICAgICBDLCAvLyAgWzNdIFN1bidzIGVxdWF0aW9uIG9mIHRoZSBDZW50cmVcbiAgICAgICAgICAgIHN1bkxvbmcsIC8vICBbNF0gU3VuJ3MgdHJ1ZSBsb25naXR1ZGVcbiAgICAgICAgICAgIHN1bkFub21hbHksIC8vICBbNV0gU3VuJ3MgdHJ1ZSBhbm9tYWx5XG4gICAgICAgICAgICBzdW5SLCAvLyAgWzZdIFN1bidzIHJhZGl1cyB2ZWN0b3IgaW4gQVVcbiAgICAgICAgICAgIExhbWJkYSwgLy8gIFs3XSBTdW4ncyBhcHBhcmVudCBsb25naXR1ZGUgYXQgdHJ1ZSBlcXVpbm94IG9mIHRoZSBkYXRlXG4gICAgICAgICAgICBBbHBoYSwgLy8gIFs4XSBTdW4ncyB0cnVlIHJpZ2h0IGFzY2Vuc2lvblxuICAgICAgICAgICAgRGVsdGEsIC8vICBbOV0gU3VuJ3MgdHJ1ZSBkZWNsaW5hdGlvblxuICAgICAgICAgICAgQWxwaGFBcHAsIC8vIFsxMF0gU3VuJ3MgYXBwYXJlbnQgcmlnaHQgYXNjZW5zaW9uXG4gICAgICAgICAgICBEZWx0YUFwcCAvLyBbMTFdIFN1bidzIGFwcGFyZW50IGRlY2xpbmF0aW9uXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjIENvbXB1dGUgZXF1YXRpb24gb2YgdGltZSBmb3IgYSBnaXZlbiBtb21lbnQuIFJldHVybnMgdGhlIGVxdWF0aW9uIG9mIHRpbWUgYXMgYSBmcmFjdGlvbiBvZiBhIGRheS5cbiAgICAgICAgICogQHBhcmFtIGpkXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcnwqfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImVxdWF0aW9uT2ZUaW1lXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlcXVhdGlvbk9mVGltZShqZCkge1xuICAgICAgICAgICAgdmFyIGFscGhhID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGRlbHRhUHNpID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIEUgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgZXBzaWxvbiA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBMMCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICB0YXUgPSB2b2lkIDA7XG4gICAgICAgICAgICB0YXUgPSAoamQgLSB0aGlzLkoyMDAwKSAvIHRoaXMuSnVsaWFuTWlsbGVubml1bTtcbiAgICAgICAgICAgIEwwID0gMjgwLjQ2NjQ1NjcgKyAzNjAwMDcuNjk4Mjc3OSAqIHRhdSArIDAuMDMwMzIwMjggKiB0YXUgKiB0YXUgKyB0YXUgKiB0YXUgKiB0YXUgLyA0OTkzMSArIC0odGF1ICogdGF1ICogdGF1ICogdGF1IC8gMTUzMDApICsgLSh0YXUgKiB0YXUgKiB0YXUgKiB0YXUgKiB0YXUgLyAyMDAwMDAwKTtcbiAgICAgICAgICAgIEwwID0gdGhpcy5maXhhbmdsZShMMCk7XG4gICAgICAgICAgICBhbHBoYSA9IHRoaXMuc3VucG9zKGpkKVsxMF07XG4gICAgICAgICAgICBkZWx0YVBzaSA9IHRoaXMubnV0YXRpb24oamQpWzBdO1xuICAgICAgICAgICAgZXBzaWxvbiA9IHRoaXMub2JsaXFlcShqZCkgKyB0aGlzLm51dGF0aW9uKGpkKVsxXTtcbiAgICAgICAgICAgIEUgPSBMMCArIC0wLjAwNTcxODMgKyAtYWxwaGEgKyBkZWx0YVBzaSAqIHRoaXMuZGNvcyhlcHNpbG9uKTtcbiAgICAgICAgICAgIEUgPSBFIC0gMjAuMCAqIE1hdGguZmxvb3IoRSAvIDIwLjApO1xuICAgICAgICAgICAgRSA9IEUgLyAoMjQgKiA2MCk7XG4gICAgICAgICAgICByZXR1cm4gRTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBBU1RSTztcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBU1RSTztcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKiBAbW9kdWxlIGNvbnN0YW50c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGR1cmF0aW9uVW5pdDoge1xuICAgICAgICB5ZWFyOiBbJ3knLCAneWVhcnMnLCAneWVhciddLFxuICAgICAgICBtb250aDogWydNJywgJ21vbnRocycsICdtb250aCddLFxuICAgICAgICBkYXk6IFsnZCcsICdkYXlzJywgJ2RheSddLFxuICAgICAgICBob3VyOiBbJ2gnLCAnaG91cnMnLCAnaG91ciddLFxuICAgICAgICBtaW51dGU6IFsnbScsICdtaW51dGVzJywgJ21pbnV0ZSddLFxuICAgICAgICBzZWNvbmQ6IFsncycsICdzZWNvbmQnLCAnc2Vjb25kcyddLFxuICAgICAgICBtaWxsaXNlY29uZDogWydtcycsICdtaWxsaXNlY29uZHMnLCAnbWlsbGlzZWNvbmQnXSxcbiAgICAgICAgd2VlazogWydXJywgJ3cnLCAnd2Vla3MnLCAnd2VlayddXG4gICAgfVxufTtcblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBIZWxwZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBub3JtYWxpemVEdXJhdGlvbiA9IG5ldyBIZWxwZXJzKCkubm9ybWFsaXplRHVyYXRpb247XG52YXIgYWJzUm91bmQgPSBuZXcgSGVscGVycygpLmFic1JvdW5kO1xudmFyIGFic0Zsb29yID0gbmV3IEhlbHBlcnMoKS5hYnNGbG9vcjtcbi8qKlxuICogRHVyYXRpb24gb2JqZWN0IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gZHVyYXRpb25cbiAqIEBjbGFzcyBEdXJhdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxudmFyIER1cmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIER1cmF0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIER1cmF0aW9uKTtcblxuICAgICAgICB2YXIgZHVyYXRpb24gPSB7fSxcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9kYXRhID0ge30sXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSAwLFxuICAgICAgICAgICAgbm9ybWFsaXplZFVuaXQgPSBub3JtYWxpemVEdXJhdGlvbihrZXksIHZhbHVlKSxcbiAgICAgICAgICAgIHVuaXQgPSBub3JtYWxpemVkVW5pdC51bml0O1xuICAgICAgICBkdXJhdGlvblt1bml0XSA9IG5vcm1hbGl6ZWRVbml0LnZhbHVlO1xuICAgICAgICBtaWxsaXNlY29uZHMgPSBkdXJhdGlvbi5taWxsaXNlY29uZHMgfHwgZHVyYXRpb24ubWlsbGlzZWNvbmQgfHwgZHVyYXRpb24ubXMgfHwgMDtcblxuICAgICAgICB2YXIgeWVhcnMgPSBkdXJhdGlvbi55ZWFycyB8fCBkdXJhdGlvbi55ZWFyIHx8IGR1cmF0aW9uLnkgfHwgMCxcbiAgICAgICAgICAgIG1vbnRocyA9IGR1cmF0aW9uLm1vbnRocyB8fCBkdXJhdGlvbi5tb250aCB8fCBkdXJhdGlvbi5NIHx8IDAsXG4gICAgICAgICAgICB3ZWVrcyA9IGR1cmF0aW9uLndlZWtzIHx8IGR1cmF0aW9uLncgfHwgZHVyYXRpb24ud2VlayB8fCAwLFxuICAgICAgICAgICAgZGF5cyA9IGR1cmF0aW9uLmRheXMgfHwgZHVyYXRpb24uZCB8fCBkdXJhdGlvbi5kYXkgfHwgMCxcbiAgICAgICAgICAgIGhvdXJzID0gZHVyYXRpb24uaG91cnMgfHwgZHVyYXRpb24uaG91ciB8fCBkdXJhdGlvbi5oIHx8IDAsXG4gICAgICAgICAgICBtaW51dGVzID0gZHVyYXRpb24ubWludXRlcyB8fCBkdXJhdGlvbi5taW51dGUgfHwgZHVyYXRpb24ubSB8fCAwLFxuICAgICAgICAgICAgc2Vjb25kcyA9IGR1cmF0aW9uLnNlY29uZHMgfHwgZHVyYXRpb24uc2Vjb25kIHx8IGR1cmF0aW9uLnMgfHwgMDtcbiAgICAgICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzICsgc2Vjb25kcyAqIDFlMyArIG1pbnV0ZXMgKiA2ZTQgKyBob3VycyAqIDM2ZTU7XG4gICAgICAgIC8vIEJlY2F1c2Ugb2YgZGF0ZUFkZFJlbW92ZSB0cmVhdHMgMjQgaG91cnMgYXMgZGlmZmVyZW50IGZyb20gYVxuICAgICAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XG4gICAgICAgIHRoaXMuX2RheXMgPSBkYXlzICsgd2Vla3MgKiA3O1xuICAgICAgICAvLyBJdCBpcyBpbXBvc3NpYmxlIHRyYW5zbGF0ZSBtb250aHMgaW50byBkYXlzIHdpdGhvdXQga25vd2luZ1xuICAgICAgICAvLyB3aGljaCBtb250aHMgeW91IGFyZSBhcmUgdGFsa2luZyBhYm91dCwgc28gd2UgaGF2ZSB0byBzdG9yZVxuICAgICAgICAvLyBpdCBzZXBhcmF0ZWx5LlxuICAgICAgICB0aGlzLl9tb250aHMgPSBtb250aHMgKyB5ZWFycyAqIDEyO1xuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgYnViYmxlcyB1cCB2YWx1ZXMsIHNlZSB0aGUgdGVzdHMgZm9yXG4gICAgICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuICAgICAgICBzZWNvbmRzICs9IGFic0Zsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgICAgICBkYXRhLnNlY29uZHMgPSBzZWNvbmRzICUgNjA7XG4gICAgICAgIG1pbnV0ZXMgKz0gYWJzUm91bmQoc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgZGF0YS5taW51dGVzID0gbWludXRlcyAlIDYwO1xuICAgICAgICBob3VycyArPSBhYnNSb3VuZChtaW51dGVzIC8gNjApO1xuICAgICAgICBkYXRhLmhvdXJzID0gaG91cnMgJSAyNDtcbiAgICAgICAgZGF5cyArPSBhYnNSb3VuZChob3VycyAvIDI0KTtcbiAgICAgICAgZGF5cyArPSB3ZWVrcyAqIDc7XG4gICAgICAgIGRhdGEuZGF5cyA9IGRheXMgJSAzMDtcbiAgICAgICAgbW9udGhzICs9IGFic1JvdW5kKGRheXMgLyAzMCk7XG4gICAgICAgIGRhdGEubW9udGhzID0gbW9udGhzICUgMTI7XG4gICAgICAgIHllYXJzICs9IGFic1JvdW5kKG1vbnRocyAvIDEyKTtcbiAgICAgICAgZGF0YS55ZWFycyA9IHllYXJzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoRHVyYXRpb24sIFt7XG4gICAgICAgIGtleTogJ3ZhbHVlT2YnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWVPZigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9taWxsaXNlY29uZHMgKyB0aGlzLl9kYXlzICogODY0ZTUgKyB0aGlzLl9tb250aHMgKiAyNTkyZTY7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRHVyYXRpb247XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gRHVyYXRpb247XG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIENvbnN0YW50c1xuICogQG1vZHVsZSBjb25zdGFudHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBncmVnb3JpYW46IHtcbiAgICAgICAgbW9udGhzOiBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXSxcbiAgICAgICAgbW9udGhzU2hvcnQ6IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXSxcbiAgICAgICAgd2Vla2RheXM6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXSxcbiAgICAgICAgd2Vla2RheXNTaG9ydDogWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXSxcbiAgICAgICAgd2Vla2RheXNNaW46IFsnU3UnLCAnTW8nLCAnVHUnLCAnV2UnLCAnVGgnLCAnRnInLCAnU2EnXVxuICAgIH0sXG4gICAgcGVyc2lhbjoge1xuICAgICAgICBtb250aHM6IFsnRmFydmFyZGluJywgJ09yZGliZWhlc2h0JywgJ0tob3JkYWQnLCAnVGlyJywgJ01vcmRhZCcsICdTaGFocml2YXInLCAnTWVocicsICdBYmFuJywgJ0F6YXInLCAnRGV5JywgJ0JhaG1hbicsICdFc2ZhbmQnXSxcbiAgICAgICAgbW9udGhzU2hvcnQ6IFsnRmFyJywgJ09yZCcsICdLaG8nLCAnVGlyJywgJ01vcicsICdTaGEnLCAnTWVoJywgJ0FiYScsICdBemEnLCAnRGV5JywgJ0JhaCcsICdFc2YnXSxcbiAgICAgICAgd2Vla2RheXM6IFsnU2F0dXJkYXknLCAnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknXSxcbiAgICAgICAgd2Vla2RheXNTaG9ydDogWydTYXQnLCAnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknXSxcbiAgICAgICAgd2Vla2RheXNNaW46IFsnU2EnLCAnU3UnLCAnTW8nLCAnVHUnLCAnV2UnLCAnVGgnLCAnRnInXSxcbiAgICAgICAgcGVyc2lhbkRheXNOYW1lOiBbJ1VybWF6ZCcsICdCYWhtYW4nLCAnT3JkaWJlaGVzaHQnLCAnU2hhaHJpdmFyJywgJ1NlcGFuZGFybWF6JywgJ0todXJkYWQnLCAnQW1vcmRhZCcsICdEZXktYmUtYXphcicsICdBemFyJywgJ0FiYW4nLCAnS2hvcnNoaWQnLCAnTWFoJywgJ1RpcicsICdHdXNoJywgJ0RleS1iZS1tZWhyJywgJ01laHInLCAnU29ydXNoJywgJ1Jhc2huJywgJ0ZhcnZhcmRpbicsICdCYWhyYW0nLCAnUmFtJywgJ0JhZCcsICdEZXktYmUtZGluJywgJ0RpbicsICdPcmQnLCAnQXNodGFkJywgJ0FzbWFuJywgJ1phbXlhZCcsICdNYW50cmUtc2VwYW5kJywgJ0FuYXJhbScsICdaaWFkaSddXG4gICAgfVxufTtcblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKiBAbW9kdWxlIGNvbnN0YW50c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdyZWdvcmlhbjoge1xuICAgICAgICBtb250aHM6ICfamNin2YbZiNuM2Ydf2YHZiNix24zZh1/Zhdin2LHYs1/YotmI2LHbjNmEX9mF2Ydf2pjZiNim2YZf2pjZiNim24zZh1/Yp9mI2Kpf2LPZvtiq2KfZhdio2LFf2Kfaqdiq2KjYsV/ZhtmI2KfZhdio2LFf2K/Ys9in2YXYqNixJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydDogJ9qY2KfZhtmI24zZh1/ZgdmI2LHbjNmHX9mF2KfYsdizX9ii2YjYsduM2YRf2YXZh1/amNmI2KbZhl/amNmI2KbbjNmHX9in2YjYql/Ys9m+2KrYp9mF2KjYsV/Yp9qp2KrYqNixX9mG2YjYp9mF2KjYsV/Yr9iz2KfZhdio2LEnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzOiAnXFx1MDZDQ1xcdTA2QTlcXHUyMDBDXFx1MDYzNFxcdTA2NDZcXHUwNjI4XFx1MDY0N19cXHUwNjJGXFx1MDY0OFxcdTA2MzRcXHUwNjQ2XFx1MDYyOFxcdTA2NDdfXFx1MDYzM1xcdTA2NDdcXHUyMDBDXFx1MDYzNFxcdTA2NDZcXHUwNjI4XFx1MDY0N19cXHUwNjg2XFx1MDY0N1xcdTA2MjdcXHUwNjMxXFx1MDYzNFxcdTA2NDZcXHUwNjI4XFx1MDY0N19cXHUwNjdFXFx1MDY0NlxcdTA2MkNcXHUyMDBDXFx1MDYzNFxcdTA2NDZcXHUwNjI4XFx1MDY0N19cXHUwNjJDXFx1MDY0NVxcdTA2MzlcXHUwNjQ3X1xcdTA2MzRcXHUwNjQ2XFx1MDYyOFxcdTA2NDcnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQ6ICdcXHUwNkNDXFx1MDZBOVxcdTIwMENcXHUwNjM0XFx1MDY0NlxcdTA2MjhcXHUwNjQ3X1xcdTA2MkZcXHUwNjQ4XFx1MDYzNFxcdTA2NDZcXHUwNjI4XFx1MDY0N19cXHUwNjMzXFx1MDY0N1xcdTIwMENcXHUwNjM0XFx1MDY0NlxcdTA2MjhcXHUwNjQ3X1xcdTA2ODZcXHUwNjQ3XFx1MDYyN1xcdTA2MzFcXHUwNjM0XFx1MDY0NlxcdTA2MjhcXHUwNjQ3X1xcdTA2N0VcXHUwNjQ2XFx1MDYyQ1xcdTIwMENcXHUwNjM0XFx1MDY0NlxcdTA2MjhcXHUwNjQ3X1xcdTA2MkNcXHUwNjQ1XFx1MDYzOVxcdTA2NDdfXFx1MDYzNFxcdTA2NDZcXHUwNjI4XFx1MDY0Nycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW46ICfbjF/Yr1/Ys1/ahl/Zvl/YrF/YtCcuc3BsaXQoJ18nKVxuICAgIH0sXG4gICAgcGVyc2lhbjoge1xuICAgICAgICBtb250aHM6IFsn2YHYsdmI2LHYr9uM2YYnLCAn2KfYsdiv24zYqNmH2LTYqicsICfYrtix2K/Yp9ivJywgJ9iq24zYsScsICfZhdix2K/Yp9ivJywgJ9i02YfYsduM2YjYsScsICfZhdmH2LEnLCAn2KLYqNin2YYnLCAn2KLYsNixJywgJ9iv24wnLCAn2KjZh9mF2YYnLCAn2KfYs9mB2YbYryddLFxuICAgICAgICBtb250aHNTaG9ydDogWyfZgdix2YgnLCAn2KfYsdivJywgJ9iu2LHYrycsICfYqtuM2LEnLCAn2YXYsdivJywgJ9i02YfYsScsICfZhdmH2LEnLCAn2KLYqNinJywgJ9ii2LDYsScsICfYr9uMJywgJ9io2YfZhScsICfYp9iz2YEnXSxcbiAgICAgICAgd2Vla2RheXM6IFsn2LTZhtio2YcnLCAn24zaqdi02YbYqNmHJywgJ9iv2YjYtNmG2KjZhycsICfYs9mHINi02YbYqNmHJywgJ9qG2YfYp9ixINi02YbYqNmHJywgJ1xcdTA2N0VcXHUwNjQ2XFx1MDYyQ1xcdTIwMENcXHUwNjM0XFx1MDY0NlxcdTA2MjhcXHUwNjQ3JywgJ9is2YXYudmHJ10sXG4gICAgICAgIHdlZWtkYXlzU2hvcnQ6IFsn2LQnLCAn24wnLCAn2K8nLCAn2LMnLCAn2oYnLCAn2b4nLCAn2KwnXSxcbiAgICAgICAgd2Vla2RheXNNaW46IFsn2LQnLCAn24wnLCAn2K8nLCAn2LMnLCAn2oYnLCAn2b4nLCAn2KwnXSxcbiAgICAgICAgcGVyc2lhbkRheXNOYW1lOiBbJ9in2YjYsdmF2LLYrycsICfYqNmH2YXZhicsICfYp9mI2LHYr9uM2KjZh9i02KonLCAn2LTZh9ix24zZiNixJywgJ9iz2b7Zhtiv2KfYsdmF2LAnLCAn2K7ZiNix2K/Yp9ivJywgJ9in2YXYsdiv2KfYrycsICfYr9uMINio2Ycg2KLYsNiyJywgJ9ii2LDYsicsICfYotio2KfZhicsICfYrtmI2LHYtNuM2K8nLCAn2YXYp9mHJywgJ9iq24zYsScsICfar9mI2LQnLCAn2K/bjCDYqNmHINmF2YfYsScsICfZhdmH2LEnLCAn2LPYsdmI2LQnLCAn2LHYtNmGJywgJ9mB2LHZiNix2K/bjNmGJywgJ9io2YfYsdin2YUnLCAn2LHYp9mFJywgJ9io2KfYrycsICfYr9uMINio2Ycg2K/bjNmGJywgJ9iv24zZhicsICfYp9ix2K8nLCAn2KfYtNiq2KfYrycsICfYotiz2YXYp9mGJywgJ9iy2KfZhduM2KfYrycsICfZhdin2YbYqtix2Ycg2LPZvtmG2K8nLCAn2KfZhtin2LHYp9mFJywgJ9iy24zYp9iv24wnXVxuICAgIH1cbn07XG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgUGVyc2lhbkRhdGVDbGFzcyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5QZXJzaWFuRGF0ZUNsYXNzLmNhbGVuZGFyVHlwZSA9ICdwZXJzaWFuJztcblBlcnNpYW5EYXRlQ2xhc3MubGVhcFllYXJNb2RlID0gJ2FzdHJvbm9taWNhbCc7XG5QZXJzaWFuRGF0ZUNsYXNzLmxvY2FsVHlwZSA9ICdmYSc7XG5tb2R1bGUuZXhwb3J0cyA9IFBlcnNpYW5EYXRlQ2xhc3M7XG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQ29udGFpbmVyID0gZnVuY3Rpb24gQ29udGFpbmVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb250YWluZXIpO1xuXG4gICAgdGhpcy5pc0ludmFsaWREYXRlID0gbnVsbDtcblxuICAgIHRoaXMuZ0RhdGUgPSBudWxsO1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1vZGlmaWVkanVsaWFuZGF5ID0gMDtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmp1bGlhbmRheSA9IDA7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEB0eXBlIHt7ZGF5OiBudW1iZXJ9fVxuICAgICAqL1xuICAgIHRoaXMuZ3JlZ3NlcmlhbCA9IHtcbiAgICAgICAgZGF5OiAwXG4gICAgfTtcblxuICAgIHRoaXMuem9uZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEB0eXBlIHt7eWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCBkYXk6IG51bWJlciwgaG91cjogbnVtYmVyLCBtaW51dGU6IG51bWJlciwgc2Vjb25kOiBudW1iZXIsIG1pbGxpc2Vjb25kOiBudW1iZXIsIHdlZWtkYXk6IG51bWJlciwgdW5peDogbnVtYmVyLCBsZWFwOiBudW1iZXJ9fVxuICAgICAqL1xuICAgIHRoaXMuZ3JlZ29yaWFuID0ge1xuICAgICAgICB5ZWFyOiAwLFxuICAgICAgICBtb250aDogMCxcbiAgICAgICAgZGF5OiAwLFxuICAgICAgICBob3VyOiAwLFxuICAgICAgICBtaW51dGU6IDAsXG4gICAgICAgIHNlY29uZDogMCxcbiAgICAgICAgbWlsbGlzZWNvbmQ6IDAsXG4gICAgICAgIHdlZWtkYXk6IDAsXG4gICAgICAgIHVuaXg6IDAsXG4gICAgICAgIGxlYXA6IDBcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAdHlwZSB7e3llYXI6IG51bWJlciwgbW9udGg6IG51bWJlciwgZGF5OiBudW1iZXIsIGxlYXA6IG51bWJlciwgd2Vla2RheTogbnVtYmVyfX1cbiAgICAgKi9cbiAgICB0aGlzLmp1bGlhbmNhbGVuZGFyID0ge1xuICAgICAgICB5ZWFyOiAwLFxuICAgICAgICBtb250aDogMCxcbiAgICAgICAgZGF5OiAwLFxuICAgICAgICBsZWFwOiAwLFxuICAgICAgICB3ZWVrZGF5OiAwXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHR5cGUge3t5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIsIGRheTogbnVtYmVyLCBsZWFwOiBudW1iZXIsIHdlZWtkYXk6IG51bWJlcn19XG4gICAgICovXG4gICAgdGhpcy5pc2xhbWljID0ge1xuICAgICAgICB5ZWFyOiAwLFxuICAgICAgICBtb250aDogMCxcbiAgICAgICAgZGF5OiAwLFxuICAgICAgICBsZWFwOiAwLFxuICAgICAgICB3ZWVrZGF5OiAwXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHR5cGUge3t5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIsIGRheTogbnVtYmVyLCBsZWFwOiBudW1iZXIsIHdlZWtkYXk6IG51bWJlcn19XG4gICAgICovXG4gICAgdGhpcy5wZXJzaWFuQWxnbyA9IHRoaXMucGVyc2lhbiA9IHtcbiAgICAgICAgeWVhcjogMCxcbiAgICAgICAgbW9udGg6IDAsXG4gICAgICAgIGRheTogMCxcbiAgICAgICAgbGVhcDogMCxcbiAgICAgICAgd2Vla2RheTogMFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEB0eXBlIHt7eWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCBkYXk6IG51bWJlciwgbGVhcDogbnVtYmVyLCB3ZWVrZGF5OiBudW1iZXJ9fVxuICAgICAqL1xuICAgIHRoaXMucGVyc2lhbkFzdHJvID0ge1xuICAgICAgICB5ZWFyOiAwLFxuICAgICAgICBtb250aDogMCxcbiAgICAgICAgZGF5OiAwLFxuICAgICAgICBsZWFwOiAwLFxuICAgICAgICB3ZWVrZGF5OiAwXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHR5cGUge3t5ZWFyOiBudW1iZXIsIHdlZWs6IG51bWJlciwgZGF5OiBudW1iZXJ9fVxuICAgICAqL1xuICAgIHRoaXMuaXNvd2VlayA9IHtcbiAgICAgICAgeWVhcjogMCxcbiAgICAgICAgd2VlazogMCxcbiAgICAgICAgZGF5OiAwXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHR5cGUge3t5ZWFyOiBudW1iZXIsIGRheTogbnVtYmVyfX1cbiAgICAgKi9cbiAgICB0aGlzLmlzb2RheSA9IHtcbiAgICAgICAgeWVhcjogMCxcbiAgICAgICAgZGF5OiAwXG4gICAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbmVyO1xuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzQXJyYXk6IGZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc051bWJlcjogZnVuY3Rpb24gaXNOdW1iZXIoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcic7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0RhdGU6IGZ1bmN0aW9uIGlzRGF0ZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBEYXRlO1xuICAgIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gaW5wdXRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICB2YWxpZGF0ZUlucHV0QXJyYXk6IGZ1bmN0aW9uIHZhbGlkYXRlSW5wdXRBcnJheShpbnB1dCkge1xuICAgIHZhciBvdXQgPSB0cnVlO1xuICAgIC8vIENoZWNrIG1vbnRoXG4gICAgaWYgKGlucHV0WzFdIDwgMSB8fCBpbnB1dFsxXSA+IDEyKSB7XG4gICAgICBvdXQgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgZGF0ZVxuICAgIGlmIChpbnB1dFsyXSA8IDEgfHwgaW5wdXRbMV0gPiAzMSkge1xuICAgICAgb3V0ID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIENoZWNrIGhvdXIgXG4gICAgaWYgKGlucHV0WzNdIDwgMCB8fCBpbnB1dFszXSA+IDI0KSB7XG4gICAgICBvdXQgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgbWludXRlIFxuICAgIGlmIChpbnB1dFs0XSA8IDAgfHwgaW5wdXRbNF0gPiA2MCkge1xuICAgICAgb3V0ID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIENoZWNrIHNlY29uZCBcbiAgICBpZiAoaW5wdXRbNV0gPCAwIHx8IGlucHV0WzVdID4gNjApIHtcbiAgICAgIG91dCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG59O1xuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/persian-date/dist/persian-date.js\n");

/***/ }),

/***/ "./node_modules/persian-datepicker/dist/js/persian-datepicker.js":
/*!***********************************************************************!*\
  !*** ./node_modules/persian-datepicker/dist/js/persian-datepicker.js ***!
  \***********************************************************************/
/***/ (function(module) {

eval("/*\n** persian-datepicker - v1.2.0\n** Reza Babakhani <babakhani.reza@gmail.com>\n** http://babakhani.github.io/PersianWebToolkit/docs/datepicker\n** Under MIT license \n*/ \n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_727__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_727__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_727__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_727__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__nested_webpack_require_727__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_727__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_727__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_727__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_727__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_727__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_727__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_727__(__nested_webpack_require_727__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Helper = {\n\n    // leading edge, instead of the trailing.\n    debounce: function debounce(func, wait, immediate) {\n        var timeout;\n        return function () {\n            var context = this,\n                args = arguments;\n            var later = function later() {\n                timeout = null;\n                if (!immediate) func.apply(context, args);\n            };\n            var callNow = immediate && !timeout;\n            clearTimeout(timeout);\n            timeout = setTimeout(later, wait);\n            if (callNow) func.apply(context, args);\n        };\n    },\n\n\n    /**\n     * @desc normal log\n     * @param input\n     * @example log('whoooooha')\n     */\n    log: function log(input) {\n        /*eslint-disable no-console */\n        console.log(input);\n        /*eslint-enable no-console */\n    },\n\n\n    /* eslint-disable no-useless-escape */\n    isMobile: function () {\n        var check = false;\n        (function (a) {\n            if (/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(a.substr(0, 4))) check = true;\n        })(navigator.userAgent || navigator.vendor || window.opera);\n        return check;\n    }(),\n    /* eslint-enable no-useless-escape */\n\n    /**\n     * @desc show debug messages if window.persianDatepickerDebug set as true\n     * @param elem\n     * @param input\n     * @example window.persianDatepickerDebug = true;\n     * debug('element','message');\n     */\n    debug: function debug(elem, input) {\n        /*eslint-disable no-console */\n        if (window.persianDatepickerDebug) {\n            if (elem.constructor.name) {\n                console.log('Debug: ' + elem.constructor.name + ' : ' + input);\n            } else {\n                console.log('Debug: ' + input);\n            }\n        }\n        /*eslint-enable no-console */\n    },\n    delay: function delay(callback, ms) {\n        clearTimeout(window.datepickerTimer);\n        window.datepickerTimer = setTimeout(callback, ms);\n    }\n};\n\nmodule.exports = Helper;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * @type {string}\n */\nvar Template = \"\\n<div id=\\\"plotId\\\" class=\\\"datepicker-plot-area {{cssClass}}\\\">\\n    {{#navigator.enabled}}\\n        <div data-navigator class=\\\"datepicker-navigator\\\">\\n            <div class=\\\"pwt-btn pwt-btn-next\\\">{{navigator.text.btnNextText}}</div>\\n            <div class=\\\"pwt-btn pwt-btn-switch\\\">{{navigator.switch.text}}</div>\\n            <div class=\\\"pwt-btn pwt-btn-prev\\\">{{navigator.text.btnPrevText}}</div>\\n        </div>\\n    {{/navigator.enabled}}\\n    <div class=\\\"datepicker-grid-view\\\" >\\n    {{#days.enabled}}\\n        {{#days.viewMode}}\\n        <div class=\\\"datepicker-day-view\\\" >    \\n            <div class=\\\"month-grid-box\\\">\\n                <div class=\\\"header\\\">\\n                    <div class=\\\"title\\\"></div>\\n                    <div class=\\\"header-row\\\">\\n                        {{#weekdays.list}}\\n                            <div class=\\\"header-row-cell\\\">{{.}}</div>\\n                        {{/weekdays.list}}\\n                    </div>\\n                </div>    \\n                <table cellspacing=\\\"0\\\" class=\\\"table-days\\\">\\n                    <tbody>\\n                        {{#days.list}}\\n                           \\n                            <tr>\\n                                {{#.}}\\n                                    {{#enabled}}\\n                                        <td data-date=\\\"{{dataDate}}\\\" data-unix=\\\"{{dataUnix}}\\\" >\\n                                            <span  class=\\\"{{#otherMonth}}other-month{{/otherMonth}}\\\">{{title}}</span>\\n                                            {{#altCalendarShowHint}}\\n                                            <i  class=\\\"alter-calendar-day\\\">{{alterCalTitle}}</i>\\n                                            {{/altCalendarShowHint}}\\n                                        </td>\\n                                    {{/enabled}}\\n                                    {{^enabled}}\\n                                        <td data-date=\\\"{{dataDate}}\\\" data-unix=\\\"{{dataUnix}}\\\" class=\\\"disabled\\\">\\n                                            <span class=\\\"{{#otherMonth}}other-month{{/otherMonth}}\\\">{{title}}</span>\\n                                            {{#altCalendarShowHint}}\\n                                            <i  class=\\\"alter-calendar-day\\\">{{alterCalTitle}}</i>\\n                                            {{/altCalendarShowHint}}\\n                                        </td>\\n                                    {{/enabled}}\\n                                    \\n                                {{/.}}\\n                            </tr>\\n                        {{/days.list}}\\n                    </tbody>\\n                </table>\\n            </div>\\n        </div>\\n        {{/days.viewMode}}\\n    {{/days.enabled}}\\n    \\n    {{#month.enabled}}\\n        {{#month.viewMode}}\\n            <div class=\\\"datepicker-month-view\\\">\\n                {{#month.list}}\\n                    {{#enabled}}               \\n                        <div data-year=\\\"{{year}}\\\" data-month=\\\"{{dataMonth}}\\\" class=\\\"month-item {{#selected}}selected{{/selected}}\\\">{{title}}</small></div>\\n                    {{/enabled}}\\n                    {{^enabled}}               \\n                        <div data-year=\\\"{{year}}\\\"data-month=\\\"{{dataMonth}}\\\" class=\\\"month-item month-item-disable {{#selected}}selected{{/selected}}\\\">{{title}}</small></div>\\n                    {{/enabled}}\\n                {{/month.list}}\\n            </div>\\n        {{/month.viewMode}}\\n    {{/month.enabled}}\\n    \\n    {{#year.enabled }}\\n        {{#year.viewMode }}\\n            <div class=\\\"datepicker-year-view\\\" >\\n                {{#year.list}}\\n                    {{#enabled}}\\n                        <div data-year=\\\"{{dataYear}}\\\" class=\\\"year-item {{#selected}}selected{{/selected}}\\\">{{title}}</div>\\n                    {{/enabled}}\\n                    {{^enabled}}\\n                        <div data-year=\\\"{{dataYear}}\\\" class=\\\"year-item year-item-disable {{#selected}}selected{{/selected}}\\\">{{title}}</div>\\n                    {{/enabled}}                    \\n                {{/year.list}}\\n            </div>\\n        {{/year.viewMode }}\\n    {{/year.enabled }}\\n    \\n    </div>\\n    {{#time}}\\n    {{#enabled}}\\n    <div class=\\\"datepicker-time-view\\\">\\n        {{#hour.enabled}}\\n            <div class=\\\"hour time-segment\\\" data-time-key=\\\"hour\\\">\\n                <div class=\\\"up-btn\\\" data-time-key=\\\"hour\\\">\\u25B2</div>\\n                <input disabled value=\\\"{{hour.title}}\\\" type=\\\"text\\\" placeholder=\\\"hour\\\" class=\\\"hour-input\\\">\\n                <div class=\\\"down-btn\\\" data-time-key=\\\"hour\\\">\\u25BC</div>                    \\n            </div>       \\n            <div class=\\\"divider\\\">\\n                <span>:</span>\\n            </div>\\n        {{/hour.enabled}}\\n        {{#minute.enabled}}\\n            <div class=\\\"minute time-segment\\\" data-time-key=\\\"minute\\\" >\\n                <div class=\\\"up-btn\\\" data-time-key=\\\"minute\\\">\\u25B2</div>\\n                <input disabled value=\\\"{{minute.title}}\\\" type=\\\"text\\\" placeholder=\\\"minute\\\" class=\\\"minute-input\\\">\\n                <div class=\\\"down-btn\\\" data-time-key=\\\"minute\\\">\\u25BC</div>\\n            </div>        \\n            <div class=\\\"divider second-divider\\\">\\n                <span>:</span>\\n            </div>\\n        {{/minute.enabled}}\\n        {{#second.enabled}}\\n            <div class=\\\"second time-segment\\\" data-time-key=\\\"second\\\"  >\\n                <div class=\\\"up-btn\\\" data-time-key=\\\"second\\\" >\\u25B2</div>\\n                <input disabled value=\\\"{{second.title}}\\\"  type=\\\"text\\\" placeholder=\\\"second\\\" class=\\\"second-input\\\">\\n                <div class=\\\"down-btn\\\" data-time-key=\\\"second\\\" >\\u25BC</div>\\n            </div>\\n            <div class=\\\"divider meridian-divider\\\"></div>\\n            <div class=\\\"divider meridian-divider\\\"></div>\\n        {{/second.enabled}}\\n        {{#meridian.enabled}}\\n            <div class=\\\"meridian time-segment\\\" data-time-key=\\\"meridian\\\" >\\n                <div class=\\\"up-btn\\\" data-time-key=\\\"meridian\\\">\\u25B2</div>\\n                <input disabled value=\\\"{{meridian.title}}\\\" type=\\\"text\\\" class=\\\"meridian-input\\\">\\n                <div class=\\\"down-btn\\\" data-time-key=\\\"meridian\\\">\\u25BC</div>\\n            </div>\\n        {{/meridian.enabled}}\\n    </div>\\n    {{/enabled}}\\n    {{/time}}\\n    \\n    {{#toolbox}}\\n    {{#enabled}}\\n    <div class=\\\"toolbox\\\">\\n        {{#toolbox.submitButton.enabled}}\\n            <div class=\\\"pwt-btn-submit\\\">{{submitButtonText}}</div>\\n        {{/toolbox.submitButton.enabled}}        \\n        {{#toolbox.todayButton.enabled}}\\n            <div class=\\\"pwt-btn-today\\\">{{todayButtonText}}</div>\\n        {{/toolbox.todayButton.enabled}}        \\n        {{#toolbox.calendarSwitch.enabled}}\\n            <div class=\\\"pwt-btn-calendar\\\">{{calendarSwitchText}}</div>\\n        {{/toolbox.calendarSwitch.enabled}}\\n    </div>\\n    {{/enabled}}\\n    {{^enabled}}\\n        {{#onlyTimePicker}}\\n        <div class=\\\"toolbox\\\">\\n            <div class=\\\"pwt-btn-submit\\\">{{submitButtonText}}</div>\\n        </div>\\n        {{/onlyTimePicker}}\\n    {{/enabled}}\\n    {{/toolbox}}\\n</div>\\n\";\n\nmodule.exports = Template;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __nested_webpack_require_14525__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar State = __nested_webpack_require_14525__(11);\nvar Toolbox = __nested_webpack_require_14525__(12);\nvar View = __nested_webpack_require_14525__(13);\nvar Input = __nested_webpack_require_14525__(6);\nvar API = __nested_webpack_require_14525__(3);\nvar Navigator = __nested_webpack_require_14525__(7);\nvar Options = __nested_webpack_require_14525__(8);\nvar PersianDateWrapper = __nested_webpack_require_14525__(10);\n\n/**\n * Main datepicker object, manage every things\n */\n\nvar Model = function () {\n\n  /**\n   * @param inputElement\n   * @param options\n   * @private\n   */\n  function Model(inputElement, options) {\n    _classCallCheck(this, Model);\n\n    return this.components(inputElement, options);\n  }\n\n  _createClass(Model, [{\n    key: 'components',\n    value: function components(inputElement, options) {\n      /**\n       * @desc [initialUnix=null]\n       * @type {unix}\n       */\n      this.initialUnix = null;\n\n      /**\n       * @desc inputElement=inputElement\n       * @type {Object}\n       */\n      this.inputElement = inputElement;\n\n      /**\n       * @desc handle works about config\n       * @type {Options}\n       */\n      this.options = new Options(options, this);\n\n      /**\n       *\n       * @type {PersianDateWrapper}\n       */\n      this.PersianDate = new PersianDateWrapper(this);\n\n      /**\n       * @desc set and get selected and view and other state\n       * @type {State}\n       */\n      this.state = new State(this);\n\n      this.api = new API(this);\n\n      /**\n       * @desc handle works about input and alt field input element\n       * @type {Input}\n       */\n      this.input = new Input(this, inputElement);\n\n      /**\n       * @desc render datepicker view base on State\n       * @type {View}\n       */\n      this.view = new View(this);\n\n      /**\n       * @desc handle works about toolbox\n       * @type {Toolbox}\n       */\n      this.toolbox = new Toolbox(this);\n\n      /**\n       *\n       * @param unix\n       */\n      this.updateInput = function (unix) {\n        this.input.update(unix);\n      };\n\n      this.state.setViewDateTime('unix', this.input.getOnInitState());\n      this.state.setSelectedDateTime('unix', this.input.getOnInitState());\n      this.view.render();\n\n      /**\n       * @desc handle navigation and dateoicker element events\n       * @type {Navigator}\n       */\n      this.navigator = new Navigator(this);\n\n      return this.api;\n    }\n  }]);\n\n  return Model;\n}();\n\nmodule.exports = Model;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * This is the API documentation for persian-datepicker\n */\nvar API = function () {\n    function API(model) {\n        _classCallCheck(this, API);\n\n        this.model = model;\n    }\n\n    /**\n     * @description get current option object\n     * @example var pd = $('.selector').persianDatepicker();\n     * console.log(pd.options);\n     */\n\n\n    _createClass(API, [{\n        key: 'show',\n\n\n        /**\n         * @description make datepicker visible\n         * @example var pd = $('.selector').persianDatepicker();\n         * pd.show();\n         */\n        value: function show() {\n            this.model.view.show();\n            this.model.options.onShow(this.model);\n            return this.model;\n        }\n\n        /**\n         * @description return datepicker current state\n         * @since 1.0.0\n         * @example var pd = $('.selector').persianDatepicker();\n         * var state = pd.getState();\n         *\n         * console.log(state.selected);\n         * console.log(state.view);\n         * */\n\n    }, {\n        key: 'getState',\n        value: function getState() {\n            return this.model.state;\n        }\n\n        /**\n         * @description make datepicker invisible\n         * @example var pd = $('.selector').persianDatepicker();\n         * pd.show();\n         */\n\n    }, {\n        key: 'hide',\n        value: function hide() {\n            this.model.view.hide();\n            this.model.options.onHide(this.model);\n            return this.model;\n        }\n\n        /**\n         * @description toggle datepicker visibility state\n         * @example var pd = $('.selector').persianDatepicker();\n         * pd.toggle();\n         */\n\n    }, {\n        key: 'toggle',\n        value: function toggle() {\n            this.model.view.toggle();\n            this.model.options.onToggle(this.model);\n            return this.model;\n        }\n\n        /**\n         * @description destroy every thing clean dom and\n         * @example var pd = $('.selector').persianDatepicker();\n         * pd.destroy();\n         */\n\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            if (this.model) {\n                this.model.view.destroy();\n                this.model.options.onDestroy(this.model);\n                delete this.model;\n            }\n        }\n\n        /**\n         * @description set selected date of datepicker accept unix timestamp\n         * @param unix\n         * @example var pd = $('.selector').persianDatepicker();\n         * pd.setDate(1382276091100)\n         */\n\n    }, {\n        key: 'setDate',\n        value: function setDate(unix) {\n            this.model.state.setSelectedDateTime('unix', unix);\n            this.model.state.setViewDateTime('unix', unix);\n            this.model.state.setSelectedDateTime('unix', unix);\n            this.model.view.render(this.view);\n            this.model.options.onSet(unix);\n            return this.model;\n        }\n    }, {\n        key: 'options',\n        get: function get() {\n            return this.model.options;\n        }\n\n        /**\n         * @description set options live\n         * @example var pd = $('.selector').persianDatepicker();\n         * pd.options;\n         * //return current options\n         * pd.options = {};\n         * // set options and render datepicker with new options\n         */\n        ,\n        set: function set(inputOptions) {\n            var opt = $.extend(true, this.model.options, inputOptions);\n            this.model.view.destroy();\n            this.model.components(this.model.inputElement, opt);\n        }\n    }]);\n\n    return API;\n}();\n\nmodule.exports = API;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __nested_webpack_require_22080__) {\n\n\"use strict\";\n\n\nvar Helper = __nested_webpack_require_22080__(0);\n\n/**\n * @description persian-datepicker configuration document\n */\nvar Config = {\n\n  /**\n   * @description set default calendar mode of datepicker, available options: 'persian', 'gregorian'\n   * @default 'persian'\n   * @type string\n   * @since 1.0.0\n   */\n  'calendarType': 'persian',\n\n  /**\n   * @description calendar type and localization configuration\n   * @type object\n   * @since 1.0.0\n   * @example\n   * {\n   *     'persian': {\n   *         'locale': 'fa',\n   *         'showHint': false,\n   *         'leapYearMode': 'algorithmic' // \"astronomical\"\n   *     },\n   *\n   *     'gregorian': {\n   *         'locale': 'en',\n   *         'showHint': false\n   *     }\n   * }\n   *\n   *\n   *\n   */\n  'calendar': {\n\n    /**\n     * @description Persian calendar configuration\n     * @type object\n     * @since 1.0.0\n     */\n    'persian': {\n\n      /**\n       * @description set locale of Persian calendar available options: 'fa', 'en'\n       * @default 'fa'\n       * @type string\n       * @since 1.0.0\n       */\n      'locale': 'fa',\n\n      /**\n       * @description if set true, small date hint of this calendar will be shown on another calendar\n       * @type boolean\n       * @default false\n       * @since 1.0.0\n       */\n      'showHint': false,\n\n      /**\n       * @description Persian calendar leap year calculation mode, available options: 'algorithmic', 'astronomical'\n       * @type string\n       * @link http://babakhani.github.io/PersianWebToolkit/doc/persian-date/leapyear\n       * @default 'algorithmic'\n       * @since 1.0.0\n       */\n      'leapYearMode': 'algorithmic' // \"astronomical\"\n    },\n\n    /**\n     * @description Gregorian calendar configuration\n     * @type object\n     * @since 1.0.0\n     */\n    'gregorian': {\n\n      /**\n       * @description set locale of Gregorian calendar available options: 'fa', 'en'\n       * @default 'en'\n       * @type string\n       * @since 1.0.0\n       */\n      'locale': 'en',\n\n      /**\n       * @description if set true, small date hint of this calendar will be shown on another calendar\n       * @type boolean\n       * @default false\n       * @since 1.0.0\n       */\n      'showHint': false\n    }\n  },\n\n  /**\n   * @description if set true make enable responsive view on mobile devices\n   * @type boolean\n   * @since 1.0.0\n   * @default true\n   */\n  'responsive': true,\n\n  /**\n   * @description if true datepicker render inline\n   * @type boolean\n   * @default false\n   */\n  'inline': false,\n\n  /**\n   * @description If set true datepicker init with input value date, use data-date property when you want set inline datepicker initial value\n   * @type boolean\n   * @default true\n   */\n  'initialValue': true,\n\n  /**\n   * @description Initial value calendar type, accept: 'persian', 'gregorian'\n   * @type boolean\n   * @default true\n   */\n  'initialValueType': 'gregorian',\n\n  /**\n   * @description from v1.0.0 this options is deprecated, use calendar.persian.locale instead\n   * @deprecated\n   * @type boolean\n   * @default true\n   */\n  'persianDigit': true,\n\n  /**\n   * @description default view mode, Acceptable value : day,month,year\n   * @type {string}\n   * @default 'day'\n   */\n  'viewMode': 'day',\n\n  /**\n   * @description the date format, combination of d, dd, m, mm, yy, yyy.\n   * @link http://babakhani.github.io/PersianWebToolkit/doc/persian-date/#format\n   * @type {boolean}\n   * @default 'LLLL'\n   */\n  'format': 'LLLL',\n\n  /**\n   * @description format value of input\n   * @param unixDate\n   * @default function\n   * @example function (unixDate) {\n   *      var self = this;\n   *      var pdate = new persianDate(unixDate);\n   *      pdate.formatPersian = this.persianDigit;\n   *      return pdate.format(self.format);\n   *  }\n   */\n  'formatter': function formatter(unixDate) {\n    var self = this,\n        pdate = this.model.PersianDate.date(unixDate);\n    return pdate.format(self.format);\n  },\n\n  /**\n   * @description An input element that is to be updated with the selected date from the datepicker. Use the altFormat option to change the format of the date within this field. Leave as blank for no alternate field. acceptable value: : '#elementId','.element-class'\n   * @type {boolean}\n   * @default false\n   * @example\n   * altField: '#inputAltFirld'\n   *\n   * altField: '.input-alt-field'\n   */\n  'altField': false,\n\n  /**\n   * @description the date format, combination of d, dd, m, mm, yy, yyy.\n   * @link http://babakhani.github.io/PersianWebToolkit/doc/persian-date/#format\n   * @type {string}\n   * @default 'unix'\n   */\n  'altFormat': 'unix',\n\n  /**\n   * @description format value of 'altField' input\n   * @param unixDate\n   * @default function\n   * @example function (unixDate) {\n   *      var self = this;\n   *      var thisAltFormat = self.altFormat.toLowerCase();\n   *      if (thisAltFormat === 'gregorian' || thisAltFormat === 'g') {\n   *          return new Date(unixDate);\n   *      }\n   *      if (thisAltFormat === 'unix' || thisAltFormat === 'u') {\n   *          return unixDate;\n   *      }\n   *      else {\n   *          var pd = new persianDate(unixDate);\n   *          pd.formatPersian = this.persianDigit;\n   *          return pd.format(self.altFormat);\n   *      }\n   *  }\n   */\n  'altFieldFormatter': function altFieldFormatter(unixDate) {\n    var self = this,\n        thisAltFormat = self.altFormat.toLowerCase(),\n        pd = void 0;\n    if (thisAltFormat === 'gregorian' || thisAltFormat === 'g') {\n      return new Date(unixDate);\n    }\n    if (thisAltFormat === 'unix' || thisAltFormat === 'u') {\n      return unixDate;\n    } else {\n      pd = this.model.PersianDate.date(unixDate);\n      return pd.format(self.altFormat);\n    }\n  },\n\n  /**\n   * @description Set min date on datepicker, prevent user select date before given unix time\n   * @property minDate\n   * @type Date\n   * @default null\n   */\n  'minDate': null,\n\n  /**\n   * @description Set max date on datepicker, prevent user select date after given unix time\n   * @property maxDate\n   * @type Date\n   * @default null\n   */\n  'maxDate': null,\n\n  /**\n   * @description navigator config object\n   * @type {object}\n   * @default true\n   */\n  'navigator': {\n    /**\n     * @description make navigator enable or disable\n     * @type boolean\n     * @default true\n     */\n    'enabled': true,\n\n    /**\n     * @description navigate by scroll configuration\n     * @type object\n     * @description scroll navigation options\n     */\n    'scroll': {\n\n      /**\n       * @description if you want make disable scroll navigation set this option false\n       * @type boolean\n       * @default true\n       */\n      'enabled': true\n    },\n\n    /**\n     * @description navigator text config object\n     */\n    'text': {\n      /**\n       * @description text of next button\n       * @default '<'\n       */\n      'btnNextText': '<',\n\n      /**\n       * @description text of prev button\n       * @default: '>'\n       */\n      'btnPrevText': '>'\n    },\n\n    /**\n     * @description Called when navigator goes to next state\n     * @event\n     * @example function (navigator) {\n     *      //log('navigator next ');\n     *  }\n     */\n    'onNext': function onNext(datepickerObject) {\n      Helper.debug(datepickerObject, 'Event: onNext');\n    },\n\n    /**\n     * @description Called when navigator goes to previews state\n     * @event\n     * @example function (navigator) {\n     *      //log('navigator prev ');\n     *  }\n     */\n    'onPrev': function onPrev(datepickerObject) {\n      Helper.debug(datepickerObject, 'Event: onPrev');\n    },\n\n    /**\n     * @description Called when navigator switch\n     * @event\n     * @example function (datepickerObject) {\n            // console.log('navigator switch ');\n     *  }\n     */\n    'onSwitch': function onSwitch(datepickerObject) {\n      Helper.debug(datepickerObject, 'dayPicker Event: onSwitch');\n    }\n  },\n\n  /**\n   * @description toolbox config object\n   * @type {object}\n   * @default true\n   */\n  'toolbox': {\n\n    /**\n     * @description boolean option that make toolbar enable or disable\n     * @type boolean\n     * @default true\n     */\n    'enabled': true,\n\n    /**\n     * @description toolbox button text configuration\n     * @type object\n     * @deprecated from 1.0.0\n     */\n    'text': {\n\n      /**\n       * @description text of today button, deprecated from 1.0.0\n       * @type string\n       * @default 'امروز'\n       * @deprecated from 1.0.0\n       */\n      btnToday: 'امروز'\n\n    },\n\n    /**\n     * @description submit button configuration (only shown on mobile)\n     * @since 1.0.0\n     */\n    submitButton: {\n\n      /**\n       * @description make submit button enable or disable\n       * @type boolean\n       * @default false\n       * @since 1.0.0\n       */\n      enabled: Helper.isMobile,\n\n      /**\n       * @description submit button text\n       * @since 1.0.0\n       * @type object\n       */\n      text: {\n\n        /**\n         * @description show when current calendar is Persian\n         * @since 1.0.0\n         * @type object\n         * @default تایید\n         */\n        fa: 'تایید',\n\n        /**\n         * @description show when current calendar is Gregorian\n         * @since 1.0.0\n         * @type object\n         * @default submit\n         */\n        en: 'submit'\n      },\n\n      /**\n       * @description Called when submit button clicked\n       * @since 1.0.0\n       * @type function\n       * @event\n       */\n      onSubmit: function onSubmit(datepickerObject) {\n        Helper.debug(datepickerObject, 'dayPicker Event: onSubmit');\n      }\n    },\n\n    /**\n     * @description toolbox today button configuration\n     * @since 1.0.0\n     */\n    todayButton: {\n\n      /**\n       * @description make toolbox today button enable or disable\n       * @type boolean\n       * @since 1.0.0\n       */\n      enabled: true,\n\n      /**\n       * @description today button text\n       * @since 1.0.0\n       * @type object\n       */\n      text: {\n\n        /**\n         * @description show when current calendar is Persian\n         * @since 1.0.0\n         * @type object\n         * @default امروز\n         */\n        fa: 'امروز',\n\n        /**\n         * @description show when current calendar is Gregorian\n         * @since 1.0.0\n         * @type object\n         * @default today\n         */\n        en: 'today'\n      },\n\n      /**\n       * @description Called when today button clicked\n       * @since 1.0.0\n       * @type function\n       * @event\n       */\n      onToday: function onToday(datepickerObject) {\n        Helper.debug(datepickerObject, 'dayPicker Event: onToday');\n      }\n    },\n\n    /**\n     * @description toolbox calendar switch configuration\n     * @type object\n     * @since 1.0.0\n     */\n    calendarSwitch: {\n\n      /**\n       * @description make calendar switch enable or disable\n       * @type boolean\n       * @since 1.0.0\n       * @default true\n       */\n      enabled: true,\n\n      /**\n       * @description calendar switch text format string\n       * @link http://babakhani.github.io/PersianWebToolkit/doc/persian-date/#format\n       * @type string\n       * @since 1.0.0\n       * @default MMMM\n       */\n      format: 'MMMM',\n\n      /**\n       * @description Called when calendar switch clicked\n       * @since 1.0.0\n       * @type function\n       * @event\n       */\n      onSwitch: function onSwitch(datepickerObject) {\n        Helper.debug(datepickerObject, 'dayPicker Event: onSwitch');\n      }\n    },\n\n    /**\n     * @event\n     * @param toolbox\n     * @example function (toolbox) {\n     *      //log('toolbox today btn');\n     *  }\n     *  @deprecated 1.0.0\n     */\n    onToday: function onToday(datepickerObject) {\n      Helper.debug(datepickerObject, 'dayPicker Event: onToday');\n    }\n  },\n\n  /**\n   * @description if true all pickers hide and just show timepicker\n   * @default false\n   * @type boolean\n   */\n  'onlyTimePicker': false,\n\n  /**\n   * @description  if true date select just by click on day in month grid, and when user select month or year selected date doesnt change\n   * @property justSelectOnDate\n   * @type boolean\n   * @default: true\n   */\n  'onlySelectOnDate': true,\n\n  /**\n   * @description Validate date access before render\n   * @type function\n   */\n  'checkDate': function checkDate() {\n    return true;\n  },\n\n  /**\n   * @description Validate month access before render\n   * @type {function}\n   */\n  'checkMonth': function checkMonth() {\n    return true;\n  },\n\n  /**\n   * @description Validate year access before render\n   * @type {function}\n   */\n  'checkYear': function checkYear() {\n    return true;\n  },\n\n  /**\n   * @description timePicker configuration\n   * @type {object}\n   */\n  'timePicker': {\n\n    /**\n     * @description make timePicker enable or disable\n     * @type boolean\n     */\n    'enabled': false,\n\n    /**\n     * @description The amount that increases or decreases by pressing the button\n     * @type number\n     */\n    'step': 1,\n\n    /**\n     * @description hour selector configuration\n     * @type object\n     */\n    'hour': {\n\n      /**\n       * @description make hour selector enable or disable\n       * @type boolean\n       */\n      'enabled': true,\n\n      /**\n       * @description The amount that increases or decreases hour, by pressing the button. overwrite by timepicker.step\n       * @type boolean\n       */\n      'step': null\n    },\n\n    /**\n     * @description minute selector configuration\n     * @type object\n     */\n    'minute': {\n\n      /**\n       * @description make minute selector enable or disable\n       * @type boolean\n       */\n      'enabled': true,\n\n      /**\n       * @description The amount that increases or decreases minute, by pressing the button. overwrite by timepicker.step\n       * @description overwrite by parent step\n       * @type boolean\n       */\n      'step': null\n    },\n\n    /**\n     * @description second selector configuration\n     * @type object\n     */\n    'second': {\n\n      /**\n       * @description make second selector enable or disable\n       * @type boolean\n       */\n      'enabled': true,\n\n      /**\n       * @description The amount that increases or decreases second, by pressing the button. overwrite by timepicker.step\n       * @type boolean\n       */\n      'step': null\n    },\n\n    /**\n     * @description meridian selector configuration\n     * @type object\n     */\n    'meridian': {\n\n      /**\n       * @description if you set this as false, datepicker timepicker system moved to 24-hour system\n       * @type boolean\n       */\n      'enabled': false\n    }\n  },\n\n  /**\n   * @description dayPicker configuration\n   * @type {object}\n   */\n  'dayPicker': {\n\n    /**\n     * @description make daypicker enable or disable\n     * @type boolean\n     * @default true\n     */\n    'enabled': true,\n\n    /**\n     * @description daypicker title format string\n     * @type string\n     * @default 'YYYY MMMM'\n     * @link http://babakhani.github.io/PersianWebToolkit/doc/persian-date/#format\n     */\n    'titleFormat': 'YYYY MMMM',\n\n    /**\n     * @description daypicker title formatter function\n     * @param year\n     * @param month\n     * @return {*}\n     */\n    'titleFormatter': function titleFormatter(year, month) {\n      var titleDate = this.model.PersianDate.date([year, month]);\n      return titleDate.format(this.model.options.dayPicker.titleFormat);\n    },\n\n    /**\n     * @description fired when user select date\n     * @event\n     * @param selectedDayUnix\n     */\n    'onSelect': function onSelect(selectedDayUnix) {\n      Helper.debug(this, 'dayPicker Event: onSelect : ' + selectedDayUnix);\n    }\n\n  },\n\n  /**\n   * @description monthPicker configuration\n   * @type {object}\n   */\n  'monthPicker': {\n\n    /**\n     * @description make monthPicker enable or disable\n     * @type boolean\n     * @default true\n     */\n    'enabled': true,\n\n    /**\n     * @description monthPicker title format string\n     * @type string\n     * @default 'YYYY'\n     */\n    'titleFormat': 'YYYY',\n\n    /**\n     * @description monthPicker title formatter function\n     * @param unix\n     * @return {*}\n     */\n    'titleFormatter': function titleFormatter(unix) {\n      var titleDate = this.model.PersianDate.date(unix);\n      return titleDate.format(this.model.options.monthPicker.titleFormat);\n    },\n\n    /**\n     * @description fired when user select month\n     * @event\n     * @param monthIndex\n     */\n    'onSelect': function onSelect(monthIndex) {\n      Helper.debug(this, 'monthPicker Event: onSelect : ' + monthIndex);\n    }\n  },\n\n  /**\n   * @description yearPicker configuration\n   * @type {object}\n   */\n  'yearPicker': {\n\n    /**\n     * @description make yearPicker enable or disable\n     * @type boolean\n     * @default true\n     */\n    'enabled': true,\n\n    /**\n     * @description yearPicker title format string\n     * @type string\n     * @default 'YYYY'\n     */\n    'titleFormat': 'YYYY',\n\n    /**\n     * @description yearPicker title formatter function\n     * @param year\n     * @return {string}\n     */\n    'titleFormatter': function titleFormatter(year) {\n      var remaining = parseInt(year / 12, 10) * 12;\n      var startYear = this.model.PersianDate.date([remaining]);\n      var endYear = this.model.PersianDate.date([remaining + 11]);\n      return startYear.format(this.model.options.yearPicker.titleFormat) + '-' + endYear.format(this.model.options.yearPicker.titleFormat);\n    },\n\n    /**\n     * @description fired when user select year\n     * @event\n     * @param year\n     */\n    'onSelect': function onSelect(year) {\n      Helper.debug(this, 'yearPicker Event: onSelect : ' + year);\n    }\n  },\n\n  /**\n   * @description Called when date Select by user.\n   * @event\n   * @param unixDate\n   */\n  'onSelect': function onSelect(unixDate) {\n    Helper.debug(this, 'datepicker Event: onSelect : ' + unixDate);\n  },\n\n  /**\n   * @description Called when date Select by api.\n   * @event\n   * @param unixDate\n   */\n  'onSet': function onSet(unixDate) {\n    Helper.debug(this, 'datepicker Event: onSet : ' + unixDate);\n  },\n\n  /**\n   * @description position of datepicker relative to input element\n   * @type string | array\n   * @default 'auto'\n   * @example\n   *  'position': 'auto'\n   *'position': [10,10]\n   */\n  'position': 'auto',\n\n  /**\n   * @description A function that takes current datepicker instance. It is called just before the datepicker is displayed.\n   * @event\n   */\n  'onShow': function onShow(datepickerObject) {\n    Helper.debug(datepickerObject, 'Event: onShow ');\n  },\n\n  /**\n   * @description A function that takes current datepicker instance. It is called just before the datepicker Hide.\n   * @event\n   */\n  'onHide': function onHide(datepickerObject) {\n    Helper.debug(datepickerObject, 'Event: onHide ');\n  },\n\n  /**\n   * @description on toggle datepicker event\n   * @event\n   */\n  'onToggle': function onToggle(datepickerObject) {\n    Helper.debug(datepickerObject, 'Event: onToggle ');\n  },\n\n  /**\n   * @description on destroy datepicker event\n   * @event\n   */\n  'onDestroy': function onDestroy(datepickerObject) {\n    Helper.debug(datepickerObject, 'Event: onDestroy ');\n  },\n\n  /**\n   * @description If true datepicker close When select a date\n   * @type {boolean}\n   * @default false\n   */\n  'autoClose': false,\n\n  /**\n   * @description by default datepicker have a template string, and you can overwrite it simply by replace string in config.\n   * @type string\n   * @example\n   * <div id=\"plotId\" class=\"datepicker-plot-area datepicker-plot-area-inline-view\">\n   {{#navigator.enabled}}\n   <div class=\"navigator\">\n   <div class=\"datepicker-header\">\n   <div class=\"btn btn-next\">{{navigator.text.btnNextText}}</div>\n   <div class=\"btn btn-switch\">{{ navigator.switch.text }}</div>\n   <div class=\"btn btn-prev\">{{navigator.text.btnPrevText}}</div>\n   </div>\n   </div>\n   {{/navigator.enabled}}\n   <div class=\"datepicker-grid-view\" >\n   {{#days.enabled}}\n   {{#days.viewMode}}\n   <div class=\"datepicker-day-view\" >\n   <div class=\"month-grid-box\">\n   <div class=\"header\">\n   <div class=\"title\"></div>\n   <div class=\"header-row\">\n   <div class=\"header-row-cell\">ش</div>\n   <div class=\"header-row-cell\">ی</div>\n   <div class=\"header-row-cell\">د</div>\n   <div class=\"header-row-cell\">س</div>\n   <div class=\"header-row-cell\">چ</div>\n   <div class=\"header-row-cell\">پ</div>\n   <div class=\"header-row-cell\">ج</div>\n   </div>\n   </div>\n   <table cellspacing=\"0\" class=\"table-days\">\n   <tbody>\n   {{#days.list}}\n    <tr>\n   {{#.}}\n    {{#enabled}}\n   <td data-unix=\"{{dataUnix}}\" ><span  class=\"{{#otherMonth}}other-month{{/otherMonth}} {{#selected}}selected{{/selected}}\">{{title}}</span></td>\n   {{/enabled}}\n   {{^enabled}}\n   <td data-unix=\"{{dataUnix}}\" class=\"disabled\"><span class=\"{{#otherMonth}}other-month{{/otherMonth}}\">{{title}}</span></td>\n   {{/enabled}}\n    {{/.}}\n   </tr>\n   {{/days.list}}\n   </tbody>\n   </table>\n   </div>\n   </div>\n   {{/days.viewMode}}\n   {{/days.enabled}}\n    {{#month.enabled}}\n   {{#month.viewMode}}\n   <div class=\"datepicker-month-view\">\n   {{#month.list}}\n   {{#enabled}}\n   <div data-month=\"{{dataMonth}}\" class=\"month-item {{#selected}}selected{{/selected}}\">{{title}}</small></div>\n   {{/enabled}}\n   {{^enabled}}\n   <div data-month=\"{{dataMonth}}\" class=\"month-item month-item-disable {{#selected}}selected{{/selected}}\">{{title}}</small></div>\n   {{/enabled}}\n   {{/month.list}}\n   </div>\n   {{/month.viewMode}}\n   {{/month.enabled}}\n    {{#year.enabled }}\n   {{#year.viewMode }}\n   <div class=\"datepicker-year-view\" >\n   {{#year.list}}\n   {{#enabled}}\n   <div data-year=\"{{dataYear}}\" class=\"year-item {{#selected}}selected{{/selected}}\">{{title}}</div>\n   {{/enabled}}\n   {{^enabled}}\n   <div data-year=\"{{dataYear}}\" class=\"year-item year-item-disable {{#selected}}selected{{/selected}}\">{{title}}</div>\n   {{/enabled}}\n   {{/year.list}}\n   </div>\n   {{/year.viewMode }}\n   {{/year.enabled }}\n    </div>\n   {{#time}}\n   {{#enabled}}\n   <div class=\"datepicker-time-view\">\n   {{#hour.enabled}}\n   <div class=\"hour time-segment\" data-time-key=\"hour\">\n   <div class=\"up-btn\" data-time-key=\"hour\">▲</div>\n   <input value=\"{{hour.title}}\" type=\"text\" placeholder=\"hour\" class=\"hour-input\">\n   <div class=\"down-btn\" data-time-key=\"hour\">▼</div>\n   </div>\n   <div class=\"divider\">:</div>\n   {{/hour.enabled}}\n   {{#minute.enabled}}\n   <div class=\"minute time-segment\" data-time-key=\"minute\" >\n   <div class=\"up-btn\" data-time-key=\"minute\">▲</div>\n   <input value=\"{{minute.title}}\" type=\"text\" placeholder=\"minute\" class=\"minute-input\">\n   <div class=\"down-btn\" data-time-key=\"minute\">▼</div>\n   </div>\n   <div class=\"divider second-divider\">:</div>\n   {{/minute.enabled}}\n   {{#second.enabled}}\n   <div class=\"second time-segment\" data-time-key=\"second\"  >\n   <div class=\"up-btn\" data-time-key=\"second\" >▲</div>\n   <input value=\"{{second.title}}\"  type=\"text\" placeholder=\"second\" class=\"second-input\">\n   <div class=\"down-btn\" data-time-key=\"second\" >▼</div>\n   </div>\n   <div class=\"divider meridian-divider\"></div>\n   <div class=\"divider meridian-divider\"></div>\n   {{/second.enabled}}\n   {{#meridian.enabled}}\n   <div class=\"meridian time-segment\" data-time-key=\"meridian\" >\n   <div class=\"up-btn\" data-time-key=\"meridian\">▲</div>\n   <input value=\"{{meridian.title}}\" type=\"text\" class=\"meridian-input\">\n   <div class=\"down-btn\" data-time-key=\"meridian\">▼</div>\n   </div>\n   {{/meridian.enabled}}\n   </div>\n   {{/enabled}}\n   {{/time}}\n    {{#toolbox}}\n   {{#enabled}}\n   <div class=\"toolbox \">\n   <div class=\"btn-today\">{{text.btnToday}}</div>\n   </div>\n   {{/enabled}}\n   {{/toolbox}}\n   </div>\n   */\n  'template': null,\n\n  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  /////////// Under Implement ///////////////////////////////////////////////////////////////////////////////////////\n  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @description if true datepicker update self by user inputted date string, accept 'yyyy/mm/dd'\n   * @example '1396/10/2', ''\n   * @type {boolean}\n   * @default false\n   */\n  'observer': false,\n\n  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  /////////// Un  implemented ///////////////////////////////////////////////////////////////////////////////////////\n  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n  /**\n   * @description waite time for last user key-down event, accept millisecond\n   * @type {number}\n   * @default 800\n   */\n  'inputDelay': 800\n};\n\nmodule.exports = Config;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __nested_webpack_require_46733__) {\n\n\"use strict\";\n\n\nvar Model = __nested_webpack_require_46733__(2);\n\n/**\n * @author babakhani.reza@gmail.com\n * @description jquery plugin initializer\n */\n(function ($) {\n    /*eslint-disable no-unused-vars */\n    $.fn.persianDatepicker = $.fn.pDatepicker = function (options) {\n        var args = Array.prototype.slice.call(arguments),\n            output = null,\n            self = this;\n        if (!this) {\n            $.error('Invalid selector');\n        }\n        $(this).each(function () {\n            // encapsulation Args\n            var emptyArr = [],\n                tempArg = args.concat(emptyArr),\n                dp = $(this).data('datepicker'),\n                funcName = null;\n            if (dp && typeof tempArg[0] === 'string') {\n                funcName = tempArg[0];\n                output = dp[funcName](tempArg[0]);\n            } else {\n                self.pDatePicker = new Model(this, options);\n            }\n        });\n        $(this).data('datepicker', self.pDatePicker);\n        return self.pDatePicker;\n    };\n    /*eslint-enable no-unused-vars */\n})(jQuery);\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __nested_webpack_require_47883__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Helper = __nested_webpack_require_47883__(0);\nvar PersianDateParser = __nested_webpack_require_47883__(9);\n/**\n * Do every thing about input element like get default value, set new value, set alt field input and etc.\n */\n\nvar Input = function () {\n\n    /**\n     * @param {Model} model\n     * @param {Element}\n     * @return {Input}\n     */\n    function Input(model, inputElement) {\n        _classCallCheck(this, Input);\n\n        /**\n         * @type {Object}\n         */\n        this.model = model;\n\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._firstUpdate = true;\n\n        /**\n         * @type {Element}\n         */\n        this.elem = inputElement;\n\n        if (this.model.options.observer) {\n            this.observe();\n        }\n\n        this.addInitialClass();\n\n        /**\n         * @type {Number}\n         */\n        this.initialUnix = null;\n\n        if (this.model.options.inline == false) {\n            this._attachInputElementEvents();\n        }\n\n        return this;\n    }\n\n    _createClass(Input, [{\n        key: 'addInitialClass',\n        value: function addInitialClass() {\n            $(this.elem).addClass('pwt-datepicker-input-element');\n        }\n    }, {\n        key: 'parseInput',\n        value: function parseInput(inputString) {\n            var parse = new PersianDateParser(),\n                that = this;\n            if (parse.parse(inputString) !== undefined) {\n                var pd = this.model.PersianDate.date(parse.parse(inputString)).valueOf();\n                that.model.state.setSelectedDateTime('unix', pd);\n                that.model.state.setViewDateTime('unix', pd);\n                that.model.view.render();\n            }\n        }\n    }, {\n        key: 'observe',\n        value: function observe() {\n            var that = this;\n            /////////////////   Manipulate by Copy And paste\n            $(that.elem).bind('paste', function (e) {\n                Helper.delay(function () {\n                    that.parseInput(e.target.value);\n                }, 60);\n            });\n            var typingTimer = void 0,\n                doneTypingInterval = that.model.options.inputDelay,\n                ctrlDown = false,\n                ctrlKey = [17, 91],\n                vKey = 86;\n\n            $(document).keydown(function (e) {\n                if ($.inArray(e.keyCode, ctrlKey) > 0) ctrlDown = true;\n            }).keyup(function (e) {\n                if ($.inArray(e.keyCode, ctrlKey) > 0) ctrlDown = false;\n            });\n\n            $(that.elem).bind('keyup', function (e) {\n                var $self = $(this);\n                var trueKey = false;\n                if (e.keyCode === 8 || e.keyCode < 105 && e.keyCode > 96 || e.keyCode < 58 && e.keyCode > 47 || ctrlDown && (e.keyCode == vKey || $.inArray(e.keyCode, ctrlKey) > 0)) {\n                    trueKey = true;\n                }\n                if (trueKey) {\n                    clearTimeout(typingTimer);\n                    typingTimer = setTimeout(function () {\n                        doneTyping($self);\n                    }, doneTypingInterval);\n                }\n            });\n\n            $(that.elem).on('keydown', function () {\n                clearTimeout(typingTimer);\n            });\n            function doneTyping($self) {\n                that.parseInput($self.val());\n            }\n\n            /////////////////   Manipulate by alt changes\n            // TODO\n            // self.model.options.altField.bind(\"change\", function () {\n            //     //if (!self._flagSelfManipulate) {\n            //         let newDate = new Date($(this).val());\n            //         if (newDate !== \"Invalid Date\") {\n            //             let newPersainDate = this.model.PersianDate.date(newDate);\n            //             self.selectDate(newPersainDate.valueOf());\n            //         }\n            //   //  }\n            // });\n        }\n\n        /**\n         * @private\n         * @desc attach events to input field\n         */\n\n    }, {\n        key: '_attachInputElementEvents',\n        value: function _attachInputElementEvents() {\n            var that = this;\n            var closePickerHandler = function closePickerHandler(e) {\n                if (!$(e.target).is(that.elem) && !$(e.target).is(that.model.view.$container) && $(e.target).closest('#' + that.model.view.$container.attr('id')).length == 0 && !$(e.target).is($(that.elem).children())) {\n                    that.model.api.hide();\n                    $('body').unbind('click', closePickerHandler);\n                }\n            };\n\n            $(this.elem).on('focus click', Helper.debounce(function (evt) {\n                that.model.api.show();\n                if (that.model.state.ui.isInline === false) {\n                    $('body').unbind('click', closePickerHandler).bind('click', closePickerHandler);\n                }\n                if (Helper.isMobile) {\n                    $(this).blur();\n                }\n                evt.stopPropagation();\n                return false;\n            }, 200));\n\n            $(this.elem).on('keydown', Helper.debounce(function (evt) {\n                if (evt.which === 9) {\n                    that.model.api.hide();\n                    return false;\n                }\n            }, 200));\n        }\n\n        /**\n         * @desc get <input/> element position\n         * @return {{top: Number, left: Number}}\n         * @todo remove jquery\n         */\n\n    }, {\n        key: 'getInputPosition',\n        value: function getInputPosition() {\n            return $(this.elem).offset();\n        }\n\n        /**\n         * @desc get <input/> element size\n         * @return {{width: Number, height: Number}}\n         * @todo remove jquery\n         */\n\n    }, {\n        key: 'getInputSize',\n        value: function getInputSize() {\n            return {\n                width: $(this.elem).outerWidth(),\n                height: $(this.elem).outerHeight()\n            };\n        }\n\n        /**\n         * @desc update <input/> element value\n         * @param {Number} unix\n         * @todo remove jquery\n         * @private\n         */\n\n    }, {\n        key: '_updateAltField',\n        value: function _updateAltField(unix) {\n            var value = this.model.options.altFieldFormatter(unix);\n            $(this.model.options.altField).val(value);\n        }\n\n        /**\n         * @desc update <input/> element value\n         * @param {Number} unix\n         * @todo remove jquery\n         * @private\n         */\n\n    }, {\n        key: '_updateInputField',\n        value: function _updateInputField(unix) {\n            var value = this.model.options.formatter(unix);\n            if ($(this.elem).val() != value) {\n                $(this.elem).val(value);\n            }\n        }\n\n        /**\n         * @param unix\n         */\n\n    }, {\n        key: 'update',\n        value: function update(unix) {\n            if (this.model.options.initialValue == false && this._firstUpdate) {\n                this._firstUpdate = false;\n            } else {\n                this._updateInputField(unix);\n                this._updateAltField(unix);\n            }\n        }\n\n        /**\n         * @desc return initial value\n         * @return {Number} - unix\n         */\n\n    }, {\n        key: 'getOnInitState',\n        value: function getOnInitState() {\n            var persianDatePickerTimeRegex = '^([0-1][0-9]|2[0-3]):([0-5][0-9])(?::([0-5][0-9]))?$';\n            var garegurianDate = null,\n                $inputElem = $(this.elem),\n                inputValue = void 0;\n\n            // Define input value by check inline mode and input mode\n\n            if ($inputElem[0].nodeName === 'INPUT') {\n                inputValue = $inputElem[0].getAttribute('value');\n            } else {\n                inputValue = $inputElem.data('date');\n            }\n\n            // Check time string by regex\n            if (inputValue && inputValue.match(persianDatePickerTimeRegex)) {\n                var timeArray = inputValue.split(':'),\n                    tempDate = new Date();\n                tempDate.setHours(timeArray[0]);\n                tempDate.setMinutes(timeArray[1]);\n                if (timeArray[2]) {\n                    tempDate.setSeconds(timeArray[2]);\n                } else {\n                    tempDate.setSeconds(0);\n                }\n                this.initialUnix = tempDate.valueOf();\n            } else {\n                if (this.model.options.initialValueType === 'persian' && inputValue) {\n                    var parse = new PersianDateParser();\n                    var pd = new persianDate(parse.parse(inputValue)).valueOf();\n                    garegurianDate = new Date(pd).valueOf();\n                } else if (this.model.options.initialValueType === 'unix' && inputValue) {\n                    garegurianDate = parseInt(inputValue);\n                } else if (inputValue) {\n                    garegurianDate = new Date(inputValue).valueOf();\n                }\n                if (garegurianDate && garegurianDate != 'undefined') {\n                    this.initialUnix = garegurianDate;\n                } else {\n                    this.initialUnix = new Date().valueOf();\n                }\n            }\n            return this.initialUnix;\n        }\n    }]);\n\n    return Input;\n}();\n\nmodule.exports = Input;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __nested_webpack_require_57977__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Hamster = __nested_webpack_require_57977__(14);\n\n/**\n * This navigator class do every thing about navigate and select date\n * @public\n */\n\nvar Navigator = function () {\n\n    /**\n     * @param {object} datepicker\n     * @return {Navigator}\n     */\n    function Navigator(model) {\n        _classCallCheck(this, Navigator);\n\n        /**\n         * @type {Datepicker}\n         */\n        this.model = model;\n        this.liveAttach();\n        this._attachEvents();\n        return this;\n    }\n\n    /**\n     * @desc attach events that needed attach after every render\n     * @public\n     * @todo attach as a live way\n     */\n\n\n    _createClass(Navigator, [{\n        key: 'liveAttach',\n        value: function liveAttach() {\n            // Check options\n            if (this.model.options.navigator.scroll.enabled) {\n                var that = this;\n                var gridPlot = $('#' + that.model.view.id + ' .datepicker-grid-view')[0];\n                Hamster(gridPlot).wheel(function (event, delta) {\n                    if (delta > 0) {\n                        that.model.state.navigate('next');\n                    } else {\n                        that.model.state.navigate('prev');\n                    }\n                    that.model.view.render();\n                    event.preventDefault();\n                });\n\n                if (this.model.options.timePicker.enabled) {\n                    $('#' + that.model.view.id + ' .time-segment').each(function () {\n                        Hamster(this).wheel(function (event, delta) {\n                            var $target = $(event.target);\n                            var key = $target.data('time-key') ? $target.data('time-key') : $target.parents('[data-time-key]').data('time-key');\n                            if (key) {\n                                if (delta > 0) {\n                                    that.timeUp(key);\n                                } else {\n                                    that.timeDown(key);\n                                }\n                            }\n                            that.model.view.render();\n                            event.preventDefault();\n                        });\n                    });\n                }\n            }\n        }\n\n        /**\n         * @desc set time up depend to timekey\n         * @param {String} timekey - accept hour, minute,second\n         * @public\n         */\n\n    }, {\n        key: 'timeUp',\n        value: function timeUp(timekey) {\n            if (this.model.options.timePicker[timekey] == undefined) {\n                return;\n            }\n            var step = void 0,\n                t = void 0,\n                that = this;\n            if (timekey == 'meridian') {\n                step = 12;\n                if (this.model.state.view.meridian == 'PM') {\n                    t = this.model.PersianDate.date(this.model.state.selected.unixDate).add('hour', step).valueOf();\n                } else {\n                    t = this.model.PersianDate.date(this.model.state.selected.unixDate).subtract('hour', step).valueOf();\n                }\n                this.model.state.meridianToggle();\n            } else {\n                step = this.model.options.timePicker[timekey].step;\n                t = this.model.PersianDate.date(this.model.state.selected.unixDate).add(timekey, step).valueOf();\n            }\n            this.model.state.setViewDateTime('unix', t);\n            this.model.state.setSelectedDateTime('unix', t);\n            this.model.view.renderTimePartial();\n            clearTimeout(this.scrollDelayTimeDown);\n            this.scrollDelayTimeUp = setTimeout(function () {\n                that.model.view.markSelectedDay();\n            }, 300);\n        }\n\n        /**\n         * @desc set time down depend to timekey\n         * @param {String} timekey - accept hour, minute,second\n         * @public\n         */\n\n    }, {\n        key: 'timeDown',\n        value: function timeDown(timekey) {\n            if (this.model.options.timePicker[timekey] == undefined) {\n                return;\n            }\n            var step = void 0,\n                t = void 0,\n                that = this;\n            if (timekey == 'meridian') {\n                step = 12;\n                if (this.model.state.view.meridian == 'AM') {\n                    t = this.model.PersianDate.date(this.model.state.selected.unixDate).add('hour', step).valueOf();\n                } else {\n                    t = this.model.PersianDate.date(this.model.state.selected.unixDate).subtract('hour', step).valueOf();\n                }\n                this.model.state.meridianToggle();\n            } else {\n                step = this.model.options.timePicker[timekey].step;\n                t = this.model.PersianDate.date(this.model.state.selected.unixDate).subtract(timekey, step).valueOf();\n            }\n            this.model.state.setViewDateTime('unix', t);\n            this.model.state.setSelectedDateTime('unix', t);\n            this.model.view.renderTimePartial();\n            clearTimeout(this.scrollDelayTimeDown);\n            this.scrollDelayTimeDown = setTimeout(function () {\n                that.model.view.markSelectedDay();\n            }, 300);\n        }\n\n        /**\n         * @desc attach dom events\n         * @todo remove jquery\n         * @private\n         */\n\n    }, {\n        key: '_attachEvents',\n        value: function _attachEvents() {\n            var that = this;\n\n            if (this.model.options.navigator.enabled) {\n                /**\n                 * @description navigator click event\n                 */\n                $(document).on('click', '#' + that.model.view.id + ' .pwt-btn', function () {\n                    if ($(this).is('.pwt-btn-next')) {\n                        that.model.state.navigate('next');\n                        that.model.view.render();\n                        that.model.options.navigator.onNext(that.model);\n                    } else if ($(this).is('.pwt-btn-switch')) {\n                        that.model.state.switchViewMode();\n                        that.model.view.render();\n                        that.model.options.navigator.onSwitch(that.model);\n                    } else if ($(this).is('.pwt-btn-prev')) {\n                        that.model.state.navigate('prev');\n                        that.model.view.render();\n                        that.model.options.navigator.onPrev(that.model);\n                    }\n                });\n            }\n\n            /**\n             * @description check if timePicker enabled attach Events\n             */\n            if (this.model.options.timePicker.enabled) {\n\n                /**\n                 * @description time up btn click event\n                 */\n                $(document).on('click', '#' + that.model.view.id + ' .up-btn', function () {\n                    var timekey = $(this).data('time-key');\n                    that.timeUp(timekey);\n                    that.model.options.onSelect(that.model.state.selected.unixDate);\n                });\n\n                /**\n                 * @description time down btn click event\n                 */\n                $(document).on('click', '#' + that.model.view.id + ' .down-btn', function () {\n                    var timekey = $(this).data('time-key');\n                    that.timeDown(timekey);\n                    that.model.options.onSelect(that.model.state.selected.unixDate);\n                });\n            }\n\n            /**\n             * @description check if dayPicker enabled attach Events\n             */\n            if (this.model.options.dayPicker.enabled) {\n\n                /**\n                 * @description days click event\n                 */\n                $(document).on('click', '#' + that.model.view.id + ' .datepicker-day-view td:not(.disabled)', function () {\n                    var thisUnix = $(this).data('unix'),\n                        mustRender = void 0;\n                    that.model.state.setSelectedDateTime('unix', thisUnix);\n                    if (that.model.state.selected.month !== that.model.state.view.month) {\n                        mustRender = true;\n                    } else {\n                        mustRender = false;\n                    }\n                    that.model.state.setViewDateTime('unix', that.model.state.selected.unixDate);\n                    if (that.model.options.autoClose) {\n                        that.model.view.hide();\n                        that.model.options.onHide(that);\n                    }\n                    if (mustRender) {\n                        that.model.view.render();\n                    } else {\n                        that.model.view.markSelectedDay();\n                    }\n                    that.model.options.dayPicker.onSelect(thisUnix);\n                    that.model.options.onSelect(thisUnix);\n                });\n            }\n\n            /**\n             * @description check if monthPicker enabled attach Events\n             */\n            if (this.model.options.monthPicker.enabled) {\n\n                /**\n                 * @description month click event\n                 */\n                $(document).on('click', '#' + that.model.view.id + ' .datepicker-month-view .month-item:not(.month-item-disable)', function () {\n                    var month = $(this).data('month');\n                    var year = $(this).data('year');\n                    that.model.state.switchViewModeTo('day');\n                    if (!that.model.options.onlySelectOnDate) {\n                        that.model.state.setSelectedDateTime('year', year);\n                        that.model.state.setSelectedDateTime('month', month);\n                        if (that.model.options.autoClose) {\n                            that.model.view.hide();\n                            that.model.options.onHide(that);\n                        }\n                    }\n                    that.model.state.setViewDateTime('month', month);\n                    that.model.view.render();\n                    that.model.options.monthPicker.onSelect(month);\n                    that.model.options.onSelect(that.model.state.selected.unixDate);\n                });\n            }\n\n            /**\n             * @description check if yearPicker enabled attach Events\n             */\n            if (this.model.options.yearPicker.enabled) {\n\n                /**\n                 * @description year click event\n                 */\n                $(document).on('click', '#' + that.model.view.id + ' .datepicker-year-view .year-item:not(.year-item-disable)', function () {\n                    var year = $(this).data('year');\n                    that.model.state.switchViewModeTo('month');\n                    if (!that.model.options.onlySelectOnDate) {\n                        that.model.state.setSelectedDateTime('year', year);\n                        if (that.model.options.autoClose) {\n                            that.model.view.hide();\n                            that.model.options.onHide(that);\n                        }\n                    }\n                    that.model.state.setViewDateTime('year', year);\n                    that.model.view.render();\n                    that.model.options.yearPicker.onSelect(year);\n                    that.model.options.onSelect(that.model.state.selected.unixDate);\n                });\n            }\n        }\n    }]);\n\n    return Navigator;\n}();\n\nmodule.exports = Navigator;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __nested_webpack_require_70175__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Config = __nested_webpack_require_70175__(4);\nvar Template = __nested_webpack_require_70175__(1);\n/**\n * Extend default config from user interred and do compatibility works\n * @public\n */\n\nvar Options = function () {\n\n    /**\n     * @param {object} options config passed when initialize\n     * @return {object}\n     * @todo remove jquery\n     */\n    function Options(options, model) {\n        _classCallCheck(this, Options);\n\n        this.model = model;\n        return this._compatibility($.extend(true, this, Config, options));\n    }\n\n    /**\n     * @private\n     * @param options\n     */\n\n\n    _createClass(Options, [{\n        key: '_compatibility',\n        value: function _compatibility(options) {\n\n            if (options.inline) {\n                options.toolbox.submitButton.enabled = false;\n            }\n\n            if (!options.template) {\n                options.template = Template;\n            }\n            persianDate.toCalendar(options.calendarType);\n            persianDate.toLocale(options.calendar[options.calendarType].locale);\n            if (options.onlyTimePicker) {\n                options.dayPicker.enabled = false;\n                options.monthPicker.enabled = false;\n                options.yearPicker.enabled = false;\n                options.navigator.enabled = false;\n                options.toolbox.enabled = false;\n                options.timePicker.enabled = true;\n            }\n\n            if (options.timePicker.hour.step === null) {\n                options.timePicker.hour.step = options.timePicker.step;\n            }\n            if (options.timePicker.minute.step === null) {\n                options.timePicker.minute.step = options.timePicker.step;\n            }\n            if (options.timePicker.second.step === null) {\n                options.timePicker.second.step = options.timePicker.step;\n            }\n\n            if (options.dayPicker.enabled === false) {\n                options.onlySelectOnDate = false;\n            }\n\n            options._viewModeList = [];\n            if (options.dayPicker.enabled) {\n                options._viewModeList.push('day');\n            }\n            if (options.monthPicker.enabled) {\n                options._viewModeList.push('month');\n            }\n            if (options.yearPicker.enabled) {\n                options._viewModeList.push('year');\n            }\n        }\n    }]);\n\n    return Options;\n}();\n\nmodule.exports = Options;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar PersianDateParser = function () {\n    function PersianDateParser() {\n        _classCallCheck(this, PersianDateParser);\n\n        this.pattern = {\n            iso: /^(-?(?:[1-9][0-9]*)?[0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(\\\\.[0-9]+)?(Z)?$/g,\n            jalali: /^[1-4]\\d{3}(\\/|-|\\.)((0?[1-6](\\/|-|\\.)((3[0-1])|([1-2][0-9])|(0?[1-9])))|((1[0-2]|(0?[7-9]))(\\/|-|\\.)(30|([1-2][0-9])|(0?[1-9]))))$/g\n        };\n    }\n\n    _createClass(PersianDateParser, [{\n        key: 'parse',\n        value: function parse(inputString) {\n            var that = this,\n                persianDateArray = void 0,\n                isoPat = new RegExp(that.pattern.iso),\n                jalaliPat = new RegExp(that.pattern.jalali);\n\n            String.prototype.toEnglishDigits = function () {\n                var charCodeZero = '۰'.charCodeAt(0);\n                return this.replace(/[۰-۹]/g, function (w) {\n                    return w.charCodeAt(0) - charCodeZero;\n                });\n            };\n\n            inputString = inputString.toEnglishDigits();\n            if (jalaliPat.test(inputString)) {\n                /* eslint-disable no-useless-escape */\n                persianDateArray = inputString.split(/\\/|-|\\,|\\./).map(Number);\n                /* eslint-enable no-useless-escape */\n                return persianDateArray;\n            } else if (isoPat.test(inputString)) {\n                /* eslint-disable no-useless-escape */\n                persianDateArray = inputString.split(/\\/|-|\\,|\\:|\\T|\\Z/g).map(Number);\n                return persianDateArray;\n                /* eslint-enable no-useless-escape */\n            } else {\n                return undefined;\n            }\n        }\n    }]);\n\n    return PersianDateParser;\n}();\n\nmodule.exports = PersianDateParser;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar PersianDateWrapper = function () {\n    function PersianDateWrapper(model) {\n        _classCallCheck(this, PersianDateWrapper);\n\n        this.model = model;\n        this.model.options.calendar_ = this.model.options.calendarType;\n        this.model.options.locale_ = this.model.options.calendar[this.model.options.calendarType].locale;\n        return this;\n    }\n\n    _createClass(PersianDateWrapper, [{\n        key: \"date\",\n        value: function date(input) {\n            if (window.inspdCount || window.inspdCount === 0) {\n                window.inspdCount++;\n            } else {\n                window.inspdCount = 0;\n            }\n            var that = this;\n            var output = void 0,\n                cp = void 0;\n            cp = persianDate.toCalendar(that.model.options.calendar_);\n            if (this.model.options.calendar[this.model.options.calendarType].leapYearMode) {\n                cp.toLeapYearMode(this.model.options.calendar[this.model.options.calendarType].leapYearMode);\n            }\n            output = new cp(input);\n            return output.toLocale(that.model.options.locale_);\n        }\n    }]);\n\n    return PersianDateWrapper;\n}();\n\nmodule.exports = PersianDateWrapper;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * All state set in his object and get from this\n * also this object notify other object to update self or update view or etc.\n */\nvar State = function () {\n\n    /**\n     * @param {model} model\n     * @return {State}\n     */\n    function State(model) {\n        _classCallCheck(this, State);\n\n        /**\n         * @type {object}\n         */\n        this.model = model;\n\n        /**\n         * @type {Boolean}\n         */\n        this.filetredDate = this.model.options.minDate || this.model.options.maxDate;\n\n        /**\n         * @desc get generated view mode list from options object\n         * @type {Array}\n         */\n        this.viewModeList = this.model.options._viewModeList;\n\n        /**\n         * @desc view mode string day, month, year\n         * @type {String}\n         * @default day\n         * @todo add time to view modes\n         */\n        this.viewMode = this.viewModeList.indexOf(model.options.viewMode) > 0 ? model.options.viewMode : this.viewModeList[0];\n\n        /**\n         * @desc view mode string index in view mode list\n         * @type {number}\n         */\n        this.viewModeIndex = this.viewModeList.indexOf(model.options.viewMode) > 0 ? this.viewModeList.indexOf(model.options.viewMode) : 0; // defaul 'day'\n\n\n        /**\n         * @desc contain filtered date objects\n         * @type {{start: {year: number, month: number, date: number, hour: number, minute: number, second: number, unixDate: number}, end: {year: number, month: number, date: number, hour: number, minute: number, second: number, unixDate: number}}}\n         */\n        this.filterDate = {\n            start: {\n                year: 0,\n                month: 0,\n                date: 0,\n                hour: 0,\n                minute: 0,\n                second: 0,\n                unixDate: 0\n            },\n            end: {\n                year: 0,\n                month: 0,\n                date: 0,\n                hour: 0,\n                minute: 0,\n                second: 0,\n                unixDate: 0\n            }\n        };\n\n        /**\n         * @desc contain view date object\n         * @type {{year: number, month: number, date: number, hour: number, minute: number, second: number, unixDate: number, dateObject: null, meridian: string}}\n         */\n        this.view = {\n            year: 0,\n            month: 0,\n            date: 0,\n            hour: 0,\n            minute: 0,\n            second: 0,\n            unixDate: 0,\n            dateObject: null,\n            meridian: 'AM'\n        };\n\n        /**\n         * @desc contain selected date object\n         * @type {{year: number, month: number, date: number, hour: number, minute: number, second: number, unixDate: number, dateObject: null}}\n         */\n        this.selected = {\n            year: 0,\n            month: 0,\n            date: 0,\n            hour: 0,\n            hour12: 0,\n            minute: 0,\n            second: 0,\n            unixDate: 0,\n            dateObject: null\n        };\n\n        this.ui = {\n            isOpen: false,\n            isInline: this.model.options.inline\n        };\n\n        this._setFilterDate(this.model.options.minDate, this.model.options.maxDate);\n        return this;\n    }\n\n    /**\n     * @private\n     * @param minDate\n     * @param maxDate\n     */\n\n\n    _createClass(State, [{\n        key: '_setFilterDate',\n        value: function _setFilterDate(minDate, maxDate) {\n            var self = this;\n            if (!minDate) {\n                minDate = -2000000000000000;\n            }\n            if (!maxDate) {\n                maxDate = 2000000000000000;\n            }\n            var pd = self.model.PersianDate.date(minDate);\n            self.filterDate.start.unixDate = minDate;\n            self.filterDate.start.hour = pd.hour();\n            self.filterDate.start.minute = pd.minute();\n            self.filterDate.start.second = pd.second();\n            self.filterDate.start.month = pd.month();\n            self.filterDate.start.date = pd.date();\n            self.filterDate.start.year = pd.year();\n\n            var pdEnd = self.model.PersianDate.date(maxDate);\n            self.filterDate.end.unixDate = maxDate;\n            self.filterDate.end.hour = pdEnd.hour();\n            self.filterDate.end.minute = pdEnd.minute();\n            self.filterDate.end.second = pdEnd.second();\n            self.filterDate.end.month = pdEnd.month();\n            self.filterDate.end.date = pdEnd.date();\n            self.filterDate.end.year = pdEnd.year();\n        }\n\n        /**\n         * @desc change view state\n         * @param {String} nav - accept next, prev\n         */\n\n    }, {\n        key: 'navigate',\n        value: function navigate(nav) {\n            if (nav == 'next') {\n                if (this.viewMode == 'year') {\n                    this.setViewDateTime('year', this.view.year + 12);\n                }\n                if (this.viewMode == 'month') {\n                    var newYear = this.view.year + 1;\n                    if (newYear === 0) {\n                        newYear = 1;\n                    }\n                    this.setViewDateTime('year', newYear);\n                }\n                if (this.viewMode == 'day') {\n                    var _newYear = this.view.year + 1;\n                    if (_newYear === 0) {\n                        _newYear = 1;\n                    }\n                    if (this.view.month + 1 == 13) {\n                        this.setViewDateTime('year', _newYear);\n                        this.setViewDateTime('month', 1);\n                    } else {\n                        this.setViewDateTime('month', this.view.month + 1);\n                    }\n                }\n            } else {\n                if (this.viewMode == 'year') {\n                    this.setViewDateTime('year', this.view.year - 12);\n                }\n                if (this.viewMode == 'month') {\n                    var _newYear2 = this.view.year - 1;\n                    if (_newYear2 === 0) {\n                        _newYear2 = -1;\n                    }\n                    this.setViewDateTime('year', _newYear2);\n                }\n                if (this.viewMode == 'day') {\n                    if (this.view.month - 1 <= 0) {\n                        var _newYear3 = this.view.year - 1;\n                        if (_newYear3 === 0) {\n                            _newYear3 = -1;\n                        }\n                        this.setViewDateTime('year', _newYear3);\n                        this.setViewDateTime('month', 12);\n                    } else {\n                        this.setViewDateTime('month', this.view.month - 1);\n                    }\n                }\n            }\n        }\n\n        /**\n         * @public\n         * @desc every time called view state changed to next in queue\n         * @return {State}\n         */\n\n    }, {\n        key: 'switchViewMode',\n        value: function switchViewMode() {\n            this.viewModeIndex = this.viewModeIndex + 1 >= this.viewModeList.length ? 0 : this.viewModeIndex + 1;\n            this.viewMode = this.viewModeList[this.viewModeIndex] ? this.viewModeList[this.viewModeIndex] : this.viewModeList[0];\n            this._setViewDateTimeUnix();\n            return this;\n        }\n\n        /**\n         * @desc switch to specified view mode\n         * @param {String} viewMode - accept date, month, year\n         */\n\n    }, {\n        key: 'switchViewModeTo',\n        value: function switchViewModeTo(viewMode) {\n            if (this.viewModeList.indexOf(viewMode) >= 0) {\n                this.viewMode = viewMode;\n                this.viewModeIndex = this.viewModeList.indexOf(viewMode);\n            }\n        }\n\n        /**\n         * @desc called on date select\n         * @param {String} key - accept date, month, year, hour, minute, second\n         * @param {Number} value\n         * @public\n         * @return {State}\n         */\n\n    }, {\n        key: 'setSelectedDateTime',\n        value: function setSelectedDateTime(key, value) {\n            var that = this;\n            switch (key) {\n                case 'unix':\n                    that.selected.unixDate = value;\n                    var pd = this.model.PersianDate.date(value);\n                    that.selected.year = pd.year();\n                    that.selected.month = pd.month();\n                    that.selected.date = pd.date();\n                    that.selected.hour = pd.hour();\n                    that.selected.hour12 = pd.format('hh');\n                    that.selected.minute = pd.minute();\n                    that.selected.second = pd.second();\n                    break;\n                case 'year':\n                    this.selected.year = value;\n                    break;\n                case 'month':\n                    this.selected.month = value;\n                    break;\n                case 'date':\n                    this.selected.date = value;\n                    break;\n                case 'hour':\n                    this.selected.hour = value;\n                    break;\n                case 'minute':\n                    this.selected.minute = value;\n                    break;\n                case 'second':\n                    this.selected.second = value;\n                    break;\n            }\n            that._updateSelectedUnix();\n            return this;\n        }\n\n        /**\n         * @return {State}\n         * @private\n         */\n\n    }, {\n        key: '_updateSelectedUnix',\n        value: function _updateSelectedUnix() {\n            this.selected.dateObject = this.model.PersianDate.date([this.selected.year, this.selected.month, this.selected.date, this.view.hour, this.view.minute, this.view.second]);\n            this.selected.unixDate = this.selected.dateObject.valueOf();\n            this.model.updateInput(this.selected.unixDate);\n            return this;\n        }\n\n        /**\n         *\n         * @return {State}\n         * @private\n         */\n\n    }, {\n        key: '_setViewDateTimeUnix',\n        value: function _setViewDateTimeUnix() {\n            var daysInMonth = new persianDate().daysInMonth(this.view.year, this.view.month);\n            if (this.view.date > daysInMonth) {\n                this.view.date = daysInMonth;\n            }\n            this.view.dateObject = this.model.PersianDate.date([this.view.year, this.view.month, this.view.date, this.view.hour, this.view.minute, this.view.second]);\n            this.view.year = this.view.dateObject.year();\n            this.view.month = this.view.dateObject.month();\n            this.view.date = this.view.dateObject.date();\n            this.view.hour = this.view.dateObject.hour();\n            this.view.hour12 = this.view.dateObject.format('hh');\n            this.view.minute = this.view.dateObject.minute();\n            this.view.second = this.view.dateObject.second();\n            this.view.unixDate = this.view.dateObject.valueOf();\n            return this;\n        }\n\n        /**\n         *\n         * @param {String} key -  accept date, month, year, hour, minute, second\n         * @param {Number} value\n         * @return {State}\n         */\n\n    }, {\n        key: 'setViewDateTime',\n        value: function setViewDateTime(key, value) {\n            var self = this;\n            switch (key) {\n                case 'unix':\n                    var pd = this.model.PersianDate.date(value);\n                    self.view.year = pd.year();\n                    self.view.month = pd.month();\n                    self.view.date = pd.date();\n                    self.view.hour = pd.hour();\n                    self.view.minute = pd.minute();\n                    self.view.second = pd.second();\n                    break;\n                case 'year':\n                    this.view.year = value;\n                    break;\n                case 'month':\n                    this.view.month = value;\n                    break;\n                case 'date':\n                    this.view.date = value;\n                    break;\n                case 'hour':\n                    this.view.hour = value;\n                    break;\n                case 'minute':\n                    this.view.minute = value;\n                    break;\n                case 'second':\n                    this.view.second = value;\n                    break;\n            }\n            this._setViewDateTimeUnix();\n            return this;\n        }\n\n        /**\n         * desc change meridian state\n         */\n\n    }, {\n        key: 'meridianToggle',\n        value: function meridianToggle() {\n            var self = this;\n            if (self.view.meridian === 'AM') {\n                self.view.meridian = 'PM';\n            } else if (self.view.meridian === 'PM') {\n                self.view.meridian = 'AM';\n            }\n        }\n    }]);\n\n    return State;\n}();\n\nmodule.exports = State;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Do every things about toolbox, like attach events to toolbox elements\n */\nvar Toolbox = function () {\n\n    /**\n     * @param {Datepicker} datepicker\n     * @return {Toolbox}\n     */\n    function Toolbox(model) {\n        _classCallCheck(this, Toolbox);\n\n        /**\n         * @type {Datepicker}\n         */\n        this.model = model;\n        this._attachEvents();\n        return this;\n    }\n\n    _createClass(Toolbox, [{\n        key: '_toggleCalendartype',\n        value: function _toggleCalendartype() {\n            var that = this;\n            if (that.model.options.calendar_ == 'persian') {\n                that.model.options.calendar_ = 'gregorian';\n                that.model.options.locale_ = this.model.options.calendar.gregorian.locale;\n            } else {\n                that.model.options.calendar_ = 'persian';\n                that.model.options.locale_ = this.model.options.calendar.persian.locale;\n            }\n        }\n\n        /**\n         * attach all events about toolbox\n         */\n\n    }, {\n        key: '_attachEvents',\n        value: function _attachEvents() {\n            var that = this;\n            $(document).on('click', '#' + that.model.view.id + ' .pwt-btn-today', function () {\n                that.model.state.setSelectedDateTime('unix', new Date().valueOf());\n                that.model.state.setViewDateTime('unix', new Date().valueOf());\n                that.model.view.reRender();\n                /**\n                 * @deprecated\n                 * @todo remove this\n                 */\n                that.model.options.toolbox.onToday(that.model);\n                that.model.options.toolbox.todayButton.onToday(that.model);\n            });\n\n            $(document).on('click', '#' + that.model.view.id + ' .pwt-btn-calendar', function () {\n                that._toggleCalendartype();\n                that.model.state.setSelectedDateTime('unix', that.model.state.selected.unixDate);\n                that.model.state.setViewDateTime('unix', that.model.state.view.unixDate);\n                that.model.view.render();\n                that.model.options.toolbox.calendarSwitch.onSwitch(that.model);\n            });\n\n            $(document).on('click', '#' + that.model.view.id + ' .pwt-btn-submit', function () {\n                that.model.view.hide();\n                that.model.options.toolbox.submitButton.onSubmit(that.model);\n                that.model.options.onHide(this);\n            });\n        }\n    }]);\n\n    return Toolbox;\n}();\n\nmodule.exports = Toolbox;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __nested_webpack_require_94973__) {\n\n\"use strict\";\n\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Template = __nested_webpack_require_94973__(1);\nvar Helper = __nested_webpack_require_94973__(0);\nvar Mustache = __nested_webpack_require_94973__(15);\n\n/**\n * As its name suggests, all rendering works do in this object\n */\n\nvar View = function () {\n\n    /**\n     *\n     * @param {Datepicker} model\n     * @return {View}\n     */\n    function View(model) {\n        _classCallCheck(this, View);\n\n        /**\n         * @type {number}\n         */\n        this.yearsViewCount = 12;\n\n        /**\n         *\n         * @type {Datepicker}\n         */\n        this.model = model;\n\n        /**\n         *\n         * @type {null}\n         */\n        this.rendered = null;\n\n        /**\n         *\n         * @type {null}\n         */\n        this.$container = null;\n\n        /**\n         *\n         * @type {string}\n         */\n        this.id = 'persianDateInstance-' + parseInt(Math.random(100) * 1000);\n        var that = this;\n\n        if (this.model.state.ui.isInline) {\n            this.$container = $('<div  id=\"' + this.id + '\" class=\"datepicker-container-inline\"></div>').appendTo(that.model.inputElement);\n        } else {\n            this.$container = $('<div  id=\"' + this.id + '\" class=\"datepicker-container\"></div>').appendTo('body');\n            this.hide();\n            this.setPickerBoxPosition();\n            this.addCompatibilityClass();\n        }\n        return this;\n    }\n\n    /**\n     * @desc add css class to handle compatibility ui things\n     */\n\n\n    _createClass(View, [{\n        key: 'addCompatibilityClass',\n        value: function addCompatibilityClass() {\n            if (Helper.isMobile && this.model.options.responsive) {\n                this.$container.addClass('pwt-mobile-view');\n            }\n        }\n\n        /**\n         * @desc remove datepicker container element from dom\n         */\n\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            this.$container.remove();\n        }\n\n        /**\n         * @desc set datepicker container element based on <input/> element position\n         */\n\n    }, {\n        key: 'setPickerBoxPosition',\n        value: function setPickerBoxPosition() {\n            var inputPosition = this.model.input.getInputPosition(),\n                inputSize = this.model.input.getInputSize();\n\n            if (Helper.isMobile && this.model.options.responsive) {\n                return false;\n            }\n\n            if (this.model.options.position === 'auto') {\n                this.$container.css({\n                    left: inputPosition.left + 'px',\n                    top: inputSize.height + inputPosition.top + 'px'\n                });\n            } else {\n                this.$container.css({\n                    left: this.model.options.position[1] + inputPosition.left + 'px',\n                    top: this.model.options.position[0] + inputPosition.top + 'px'\n                });\n            }\n        }\n\n        /**\n         * @desc show datepicker container element\n         */\n\n    }, {\n        key: 'show',\n        value: function show() {\n            this.$container.removeClass('pwt-hide');\n            this.setPickerBoxPosition();\n        }\n\n        /**\n         * @desc hide datepicker container element\n         */\n\n    }, {\n        key: 'hide',\n        value: function hide() {\n            this.$container.addClass('pwt-hide');\n        }\n\n        /**\n         * @desc toggle datepicker container element\n         */\n\n    }, {\n        key: 'toggle',\n        value: function toggle() {\n            this.$container.toggleClass('pwt-hide');\n        }\n\n        /**\n         * @desc return navigator switch text\n         * @param {String} data -  accept day, month, year\n         * @private\n         * @return {String}\n         */\n\n    }, {\n        key: '_getNavSwitchText',\n        value: function _getNavSwitchText(data) {\n            var output = void 0;\n            if (this.model.state.viewMode == 'day') {\n                output = this.model.options.dayPicker.titleFormatter.call(this, data.year, data.month);\n            } else if (this.model.state.viewMode == 'month') {\n                output = this.model.options.monthPicker.titleFormatter.call(this, data.dateObject.valueOf());\n            } else if (this.model.state.viewMode == 'year') {\n                output = this.model.options.yearPicker.titleFormatter.call(this, data.year);\n            }\n            return output;\n        }\n\n        /**\n         * @desc check year is accessible\n         * @param {Number} year - year number\n         * @return {Boolean}\n         */\n\n    }, {\n        key: 'checkYearAccess',\n        value: function checkYearAccess(year) {\n            var output = true;\n            if (this.model.state.filetredDate) {\n                var startYear = this.model.state.filterDate.start.year,\n                    endYear = this.model.state.filterDate.end.year;\n                if (startYear && year < startYear) {\n                    return false;\n                } else if (endYear && year > endYear) {\n                    return false;\n                }\n            }\n            if (output) {\n                return this.model.options.checkYear(year);\n            }\n        }\n\n        /**\n         * @private\n         * @param viewState\n         * @return {{enabled: boolean, viewMode: boolean, list: Array}}\n         */\n\n    }, {\n        key: '_getYearViewModel',\n        value: function _getYearViewModel(viewState) {\n            var _this = this;\n\n            var isEnabled = this.model.options.yearPicker.enabled;\n            // Make performance better\n            if (!isEnabled) {\n                return {\n                    enabled: false\n                };\n            }\n            /**\n             * @description Generate years list based on viewState year\n             * @return ['1380',n+12,'1392']\n             */\n            var list = [].concat(_toConsumableArray(Array(this.yearsViewCount).keys())).map(function (value) {\n                return value + parseInt(viewState.year / _this.yearsViewCount) * _this.yearsViewCount;\n            });\n            /*\n             * @description Generate years object based on list\n             */\n            var yearsModel = [],\n                yearStr = this.model.PersianDate.date();\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = list[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var i = _step.value;\n\n                    yearStr.year([i]);\n                    yearsModel.push({\n                        title: yearStr.format('YYYY'),\n                        enabled: this.checkYearAccess(i),\n                        dataYear: i,\n                        selected: this.model.state.selected.year == i\n                    });\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            return {\n                enabled: isEnabled,\n                viewMode: this.model.state.viewMode == 'year',\n                list: yearsModel\n            };\n        }\n\n        /**\n         * @desc check month is accessible\n         * @param {Number} month - month number\n         * @return {Boolean}\n         */\n\n    }, {\n        key: 'checkMonthAccess',\n        value: function checkMonthAccess(month) {\n            month = month + 1;\n            var output = true,\n                y = this.model.state.view.year;\n            if (this.model.state.filetredDate) {\n                var startMonth = this.model.state.filterDate.start.month,\n                    endMonth = this.model.state.filterDate.end.month,\n                    startYear = this.model.state.filterDate.start.year,\n                    endYear = this.model.state.filterDate.end.year;\n                if (startMonth && endMonth && (y == endYear && month > endMonth || y > endYear) || y == startYear && month < startMonth || y < startYear) {\n                    return false;\n                } else if (endMonth && (y == endYear && month > endMonth || y > endYear)) {\n                    return false;\n                } else if (startMonth && (y == startYear && month < startMonth || y < startYear)) {\n                    return false;\n                }\n            }\n            if (output) {\n                return this.model.options.checkMonth(month, y);\n            }\n        }\n\n        /**\n         * @private\n         * @return {{enabled: boolean, viewMode: boolean, list: Array}}\n         */\n\n    }, {\n        key: '_getMonthViewModel',\n        value: function _getMonthViewModel() {\n            var isEnaled = this.model.options.monthPicker.enabled;\n            // Make performance better\n            if (!isEnaled) {\n                return {\n                    enabled: false\n                };\n            }\n\n            var monthModel = [],\n                that = this;\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = that.model.PersianDate.date().rangeName().months.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var _step2$value = _slicedToArray(_step2.value, 2),\n                        index = _step2$value[0],\n                        month = _step2$value[1];\n\n                    monthModel.push({\n                        title: month,\n                        enabled: this.checkMonthAccess(index),\n                        year: this.model.state.view.year,\n                        dataMonth: index + 1,\n                        selected: this.model.state.selected.year == this.model.state.view.year && this.model.state.selected.month == index + 1\n                    });\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            return {\n                enabled: isEnaled,\n                viewMode: this.model.state.viewMode == 'month',\n                list: monthModel\n            };\n        }\n\n        /**\n         * @desc check day is accessible\n         * @param {Number} thisUnix - month number\n         * @return {Boolean}\n         */\n\n    }, {\n        key: 'checkDayAccess',\n        value: function checkDayAccess(unixtimespan) {\n            var self = this,\n                output = true;\n            self.minDate = this.model.options.minDate;\n            self.maxDate = this.model.options.maxDate;\n\n            if (self.model.state.filetredDate) {\n                if (self.minDate && self.maxDate) {\n                    self.minDate = self.model.PersianDate.date(self.minDate).startOf('day').valueOf();\n                    self.maxDate = self.model.PersianDate.date(self.maxDate).endOf('day').valueOf();\n                    if (!(unixtimespan >= self.minDate && unixtimespan <= self.maxDate)) {\n                        return false;\n                    }\n                } else if (self.minDate) {\n                    self.minDate = self.model.PersianDate.date(self.minDate).startOf('day').valueOf();\n                    if (unixtimespan <= self.minDate) {\n                        return false;\n                    }\n                } else if (self.maxDate) {\n                    self.maxDate = self.model.PersianDate.date(self.maxDate).endOf('day').valueOf();\n                    if (unixtimespan >= self.maxDate) {\n                        return false;\n                    }\n                }\n            }\n            if (output) {\n                return self.model.options.checkDate(unixtimespan);\n            }\n        }\n\n        /**\n         * @private\n         * @return {object}\n         */\n\n    }, {\n        key: '_getDayViewModel',\n        value: function _getDayViewModel() {\n            if (this.model.state.viewMode != 'day') {\n                return [];\n            }\n\n            var isEnabled = this.model.options.dayPicker.enabled;\n            // Make performance better\n            if (!isEnabled) {\n                return {\n                    enabled: false\n                };\n            }\n\n            //log('if you see this many time your code has performance issue');\n            var viewMonth = this.model.state.view.month,\n                viewYear = this.model.state.view.year;\n            var pdateInstance = this.model.PersianDate.date(),\n                daysCount = pdateInstance.daysInMonth(viewYear, viewMonth),\n                firstWeekDayOfMonth = pdateInstance.getFirstWeekDayOfMonth(viewYear, viewMonth) - 1,\n                outputList = [],\n                daysListindex = 0,\n                nextMonthListIndex = 0,\n                daysMatrix = [['null', 'null', 'null', 'null', 'null', 'null', 'null'], ['null', 'null', 'null', 'null', 'null', 'null', 'null'], ['null', 'null', 'null', 'null', 'null', 'null', 'null'], ['null', 'null', 'null', 'null', 'null', 'null', 'null'], ['null', 'null', 'null', 'null', 'null', 'null', 'null'], ['null', 'null', 'null', 'null', 'null', 'null', 'null']];\n\n            var anotherCalendar = this._getAnotherCalendar();\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n                for (var _iterator3 = daysMatrix.entries()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                    var _step3$value = _slicedToArray(_step3.value, 2),\n                        rowIndex = _step3$value[0],\n                        daysRow = _step3$value[1];\n\n                    outputList[rowIndex] = [];\n                    var _iteratorNormalCompletion4 = true;\n                    var _didIteratorError4 = false;\n                    var _iteratorError4 = undefined;\n\n                    try {\n                        for (var _iterator4 = daysRow.entries()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                            var _step4$value = _slicedToArray(_step4.value, 1),\n                                dayIndex = _step4$value[0];\n\n                            var calcedDate = void 0,\n                                otherMonth = void 0;\n                            // Set hour 12 prevent issues with DST times\n                            if (rowIndex === 0 && dayIndex < firstWeekDayOfMonth) {\n                                calcedDate = this.model.state.view.dateObject.startOf('month').hour(12).subtract('days', firstWeekDayOfMonth - dayIndex);\n                                otherMonth = true;\n                            } else if (rowIndex === 0 && dayIndex >= firstWeekDayOfMonth || rowIndex <= 5 && daysListindex < daysCount) {\n                                daysListindex += 1;\n                                calcedDate = new persianDate([this.model.state.view.year, this.model.state.view.month, daysListindex]);\n                                otherMonth = false;\n                            } else {\n                                nextMonthListIndex += 1;\n                                calcedDate = this.model.state.view.dateObject.endOf('month').hour(12).add('days', nextMonthListIndex);\n                                otherMonth = true;\n                            }\n                            outputList[rowIndex].push({\n                                title: calcedDate.format('D'),\n                                alterCalTitle: new persianDate(calcedDate.valueOf()).toCalendar(anotherCalendar[0]).toLocale(anotherCalendar[1]).format('D'),\n                                dataDate: [calcedDate.year(), calcedDate.month(), calcedDate.date()].join(','),\n                                dataUnix: calcedDate.hour(12).valueOf(),\n                                otherMonth: otherMonth,\n                                // TODO: make configurable\n                                enabled: this.checkDayAccess(calcedDate.valueOf())\n                            });\n                        }\n                    } catch (err) {\n                        _didIteratorError4 = true;\n                        _iteratorError4 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                                _iterator4.return();\n                            }\n                        } finally {\n                            if (_didIteratorError4) {\n                                throw _iteratorError4;\n                            }\n                        }\n                    }\n                }\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally {\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n\n            return {\n                enabled: isEnabled,\n                viewMode: this.model.state.viewMode == 'day',\n                list: outputList\n            };\n        }\n    }, {\n        key: 'markSelectedDay',\n        value: function markSelectedDay() {\n            var selected = this.model.state.selected;\n            this.$container.find('.table-days td').each(function () {\n                if ($(this).data('date') == [selected.year, selected.month, selected.date].join(',')) {\n                    $(this).addClass('selected');\n                } else {\n                    $(this).removeClass('selected');\n                }\n            });\n        }\n    }, {\n        key: 'markToday',\n        value: function markToday() {\n            var today = new persianDate();\n            this.$container.find('.table-days td').each(function () {\n                if ($(this).data('date') == [today.year(), today.month(), today.date()].join(',')) {\n                    $(this).addClass('today');\n                } else {\n                    $(this).removeClass('today');\n                }\n            });\n        }\n\n        /**\n         * @private\n         * @return {{enabled: boolean, hour: {title, enabled: boolean}, minute: {title, enabled: boolean}, second: {title, enabled: boolean}, meridian: {title: (meridian|{title, enabled}|ClassDatepicker.ClassConfig.timePicker.meridian|{enabled}|string|string), enabled: boolean}}}\n         */\n\n    }, {\n        key: '_getTimeViewModel',\n        value: function _getTimeViewModel() {\n\n            var isEnabled = this.model.options.timePicker.enabled;\n            // Make performance better\n            if (!isEnabled) {\n                return {\n                    enabled: false\n                };\n            }\n\n            var hourTitle = void 0;\n            if (this.model.options.timePicker.meridian.enabled) {\n                hourTitle = this.model.state.view.dateObject.format('hh');\n            } else {\n                hourTitle = this.model.state.view.dateObject.format('HH');\n            }\n\n            return {\n                enabled: isEnabled,\n                hour: {\n                    title: hourTitle,\n                    enabled: this.model.options.timePicker.hour.enabled\n                },\n                minute: {\n                    title: this.model.state.view.dateObject.format('mm'),\n                    enabled: this.model.options.timePicker.minute.enabled\n                },\n                second: {\n                    title: this.model.state.view.dateObject.format('ss'),\n                    enabled: this.model.options.timePicker.second.enabled\n                },\n                meridian: {\n                    title: this.model.state.view.dateObject.format('a'),\n                    enabled: this.model.options.timePicker.meridian.enabled\n                }\n            };\n        }\n\n        /**\n         *\n         * @return {{enabled: boolean, list: (*|Array)}}\n         * @private\n         */\n\n    }, {\n        key: '_getWeekViewModel',\n        value: function _getWeekViewModel() {\n            return {\n                enabled: true,\n                list: this.model.PersianDate.date().rangeName().weekdaysMin\n            };\n        }\n\n        /**\n         *\n         * @return {string}\n         */\n\n    }, {\n        key: 'getCssClass',\n        value: function getCssClass() {\n            return [this.model.state.ui.isInline ? 'datepicker-plot-area-inline-view' : '', !this.model.options.timePicker.meridian.enabled ? 'datepicker-state-no-meridian' : '', this.model.options.onlyTimePicker ? 'datepicker-state-only-time' : '', !this.model.options.timePicker.second.enabled ? 'datepicker-state-no-second' : '', this.model.options.calendar_ == 'gregorian' ? 'datepicker-gregorian' : 'datepicker-persian'].join(' ');\n        }\n\n        /**\n         * @param data\n         * @return {*}\n         */\n\n    }, {\n        key: 'getViewModel',\n        value: function getViewModel(data) {\n            var anotherCalendar = this._getAnotherCalendar();\n            return {\n                plotId: '',\n                navigator: {\n                    enabled: this.model.options.navigator.enabled,\n                    switch: {\n                        enabled: true,\n                        text: this._getNavSwitchText(data)\n                    },\n                    text: this.model.options.navigator.text\n                },\n                selected: this.model.state.selected,\n                time: this._getTimeViewModel(data),\n                days: this._getDayViewModel(data),\n                weekdays: this._getWeekViewModel(data),\n                month: this._getMonthViewModel(data),\n                year: this._getYearViewModel(data),\n                toolbox: this.model.options.toolbox,\n                cssClass: this.getCssClass(),\n                onlyTimePicker: this.model.options.onlyTimePicker,\n                altCalendarShowHint: this.model.options.calendar[anotherCalendar[0]].showHint,\n                calendarSwitchText: this.model.state.view.dateObject.toCalendar(anotherCalendar[0]).toLocale(anotherCalendar[1]).format(this.model.options.toolbox.calendarSwitch.format),\n                todayButtonText: this._getButtonText().todayButtontext,\n                submitButtonText: this._getButtonText().submitButtonText\n            };\n        }\n    }, {\n        key: '_getButtonText',\n        value: function _getButtonText() {\n            var output = {};\n            if (this.model.options.locale_ == 'fa') {\n                output.todayButtontext = this.model.options.toolbox.todayButton.text.fa;\n                output.submitButtonText = this.model.options.toolbox.submitButton.text.fa;\n            } else if (this.model.options.locale_ == 'en') {\n                output.todayButtontext = this.model.options.toolbox.todayButton.text.en;\n                output.submitButtonText = this.model.options.toolbox.submitButton.text.en;\n            }\n            return output;\n        }\n    }, {\n        key: '_getAnotherCalendar',\n        value: function _getAnotherCalendar() {\n            var that = this,\n                cal = void 0,\n                loc = void 0;\n            if (that.model.options.calendar_ == 'persian') {\n                cal = 'gregorian';\n                loc = that.model.options.calendar.gregorian.locale;\n            } else {\n                cal = 'persian';\n                loc = that.model.options.calendar.persian.locale;\n            }\n            return [cal, loc];\n        }\n\n        /**\n         * @desc render times area, prevent performance issue with scroll and time section\n         */\n\n    }, {\n        key: 'renderTimePartial',\n        value: function renderTimePartial() {\n            var timeViewModel = this._getTimeViewModel(this.model.state.view);\n            this.$container.find('[data-time-key=\"hour\"] input').val(timeViewModel.hour.title);\n            this.$container.find('[data-time-key=\"minute\"] input').val(timeViewModel.minute.title);\n            this.$container.find('[data-time-key=\"second\"] input').val(timeViewModel.second.title);\n            this.$container.find('[data-time-key=\"meridian\"] input').val(timeViewModel.meridian.title);\n        }\n\n        /**\n         * @render datepicker view element\n         * @param data\n         */\n\n    }, {\n        key: 'render',\n        value: function render(data) {\n            if (!data) {\n                data = this.model.state.view;\n            }\n            Helper.debug(this, 'render');\n            Mustache.parse(Template);\n            this.rendered = $(Mustache.render(this.model.options.template, this.getViewModel(data)));\n            this.$container.empty().append(this.rendered);\n            this.markSelectedDay();\n            this.markToday();\n            this.afterRender();\n        }\n    }, {\n        key: 'reRender',\n        value: function reRender() {\n            var data = this.model.state.view;\n            this.render(data);\n        }\n\n        /**\n         * @desc do after render work like attache events\n         */\n\n    }, {\n        key: 'afterRender',\n        value: function afterRender() {\n            if (this.model.navigator) {\n                this.model.navigator.liveAttach();\n            }\n        }\n    }]);\n\n    return View;\n}();\n\nmodule.exports = View;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*\n * Hamster.js v1.1.2\n * (c) 2013 Monospaced http://monospaced.com\n * License: MIT\n */\n\n(function(window, document){\n'use strict';\n\n/**\n * Hamster\n * use this to create instances\n * @returns {Hamster.Instance}\n * @constructor\n */\nvar Hamster = function(element) {\n  return new Hamster.Instance(element);\n};\n\n// default event name\nHamster.SUPPORT = 'wheel';\n\n// default DOM methods\nHamster.ADD_EVENT = 'addEventListener';\nHamster.REMOVE_EVENT = 'removeEventListener';\nHamster.PREFIX = '';\n\n// until browser inconsistencies have been fixed...\nHamster.READY = false;\n\nHamster.Instance = function(element){\n  if (!Hamster.READY) {\n    // fix browser inconsistencies\n    Hamster.normalise.browser();\n\n    // Hamster is ready...!\n    Hamster.READY = true;\n  }\n\n  this.element = element;\n\n  // store attached event handlers\n  this.handlers = [];\n\n  // return instance\n  return this;\n};\n\n/**\n * create new hamster instance\n * all methods should return the instance itself, so it is chainable.\n * @param   {HTMLElement}       element\n * @returns {Hamster.Instance}\n * @constructor\n */\nHamster.Instance.prototype = {\n  /**\n   * bind events to the instance\n   * @param   {Function}    handler\n   * @param   {Boolean}     useCapture\n   * @returns {Hamster.Instance}\n   */\n  wheel: function onEvent(handler, useCapture){\n    Hamster.event.add(this, Hamster.SUPPORT, handler, useCapture);\n\n    // handle MozMousePixelScroll in older Firefox\n    if (Hamster.SUPPORT === 'DOMMouseScroll') {\n      Hamster.event.add(this, 'MozMousePixelScroll', handler, useCapture);\n    }\n\n    return this;\n  },\n\n  /**\n   * unbind events to the instance\n   * @param   {Function}    handler\n   * @param   {Boolean}     useCapture\n   * @returns {Hamster.Instance}\n   */\n  unwheel: function offEvent(handler, useCapture){\n    // if no handler argument,\n    // unbind the last bound handler (if exists)\n    if (handler === undefined && (handler = this.handlers.slice(-1)[0])) {\n      handler = handler.original;\n    }\n\n    Hamster.event.remove(this, Hamster.SUPPORT, handler, useCapture);\n\n    // handle MozMousePixelScroll in older Firefox\n    if (Hamster.SUPPORT === 'DOMMouseScroll') {\n      Hamster.event.remove(this, 'MozMousePixelScroll', handler, useCapture);\n    }\n\n    return this;\n  }\n};\n\nHamster.event = {\n  /**\n   * cross-browser 'addWheelListener'\n   * @param   {Instance}    hamster\n   * @param   {String}      eventName\n   * @param   {Function}    handler\n   * @param   {Boolean}     useCapture\n   */\n  add: function add(hamster, eventName, handler, useCapture){\n    // store the original handler\n    var originalHandler = handler;\n\n    // redefine the handler\n    handler = function(originalEvent){\n\n      if (!originalEvent) {\n        originalEvent = window.event;\n      }\n\n      // create a normalised event object,\n      // and normalise \"deltas\" of the mouse wheel\n      var event = Hamster.normalise.event(originalEvent),\n          delta = Hamster.normalise.delta(originalEvent);\n\n      // fire the original handler with normalised arguments\n      return originalHandler(event, delta[0], delta[1], delta[2]);\n\n    };\n\n    // cross-browser addEventListener\n    hamster.element[Hamster.ADD_EVENT](Hamster.PREFIX + eventName, handler, useCapture || false);\n\n    // store original and normalised handlers on the instance\n    hamster.handlers.push({\n      original: originalHandler,\n      normalised: handler\n    });\n  },\n\n  /**\n   * removeWheelListener\n   * @param   {Instance}    hamster\n   * @param   {String}      eventName\n   * @param   {Function}    handler\n   * @param   {Boolean}     useCapture\n   */\n  remove: function remove(hamster, eventName, handler, useCapture){\n    // find the normalised handler on the instance\n    var originalHandler = handler,\n        lookup = {},\n        handlers;\n    for (var i = 0, len = hamster.handlers.length; i < len; ++i) {\n      lookup[hamster.handlers[i].original] = hamster.handlers[i];\n    }\n    handlers = lookup[originalHandler];\n    handler = handlers.normalised;\n\n    // cross-browser removeEventListener\n    hamster.element[Hamster.REMOVE_EVENT](Hamster.PREFIX + eventName, handler, useCapture || false);\n\n    // remove original and normalised handlers from the instance\n    for (var h in hamster.handlers) {\n      if (hamster.handlers[h] == handlers) {\n        hamster.handlers.splice(h, 1);\n        break;\n      }\n    }\n  }\n};\n\n/**\n * these hold the lowest deltas,\n * used to normalise the delta values\n * @type {Number}\n */\nvar lowestDelta,\n    lowestDeltaXY;\n\nHamster.normalise = {\n  /**\n   * fix browser inconsistencies\n   */\n  browser: function normaliseBrowser(){\n    // detect deprecated wheel events\n    if (!('onwheel' in document || document.documentMode >= 9)) {\n      Hamster.SUPPORT = document.onmousewheel !== undefined ?\n                        'mousewheel' : // webkit and IE < 9 support at least \"mousewheel\"\n                        'DOMMouseScroll'; // assume remaining browsers are older Firefox\n    }\n\n    // detect deprecated event model\n    if (!window.addEventListener) {\n      // assume IE < 9\n      Hamster.ADD_EVENT = 'attachEvent';\n      Hamster.REMOVE_EVENT = 'detachEvent';\n      Hamster.PREFIX = 'on';\n    }\n\n  },\n\n  /**\n   * create a normalised event object\n   * @param   {Function}    originalEvent\n   * @returns {Object}      event\n   */\n   event: function normaliseEvent(originalEvent){\n    var event = {\n          // keep a reference to the original event object\n          originalEvent: originalEvent,\n          target: originalEvent.target || originalEvent.srcElement,\n          type: 'wheel',\n          deltaMode: originalEvent.type === 'MozMousePixelScroll' ? 0 : 1,\n          deltaX: 0,\n          deltaZ: 0,\n          preventDefault: function(){\n            if (originalEvent.preventDefault) {\n              originalEvent.preventDefault();\n            } else {\n              originalEvent.returnValue = false;\n            }\n          },\n          stopPropagation: function(){\n            if (originalEvent.stopPropagation) {\n              originalEvent.stopPropagation();\n            } else {\n              originalEvent.cancelBubble = false;\n            }\n          }\n        };\n\n    // calculate deltaY (and deltaX) according to the event\n\n    // 'mousewheel'\n    if (originalEvent.wheelDelta) {\n      event.deltaY = - 1/40 * originalEvent.wheelDelta;\n    }\n    // webkit\n    if (originalEvent.wheelDeltaX) {\n      event.deltaX = - 1/40 * originalEvent.wheelDeltaX;\n    }\n\n    // 'DomMouseScroll'\n    if (originalEvent.detail) {\n      event.deltaY = originalEvent.detail;\n    }\n\n    return event;\n  },\n\n  /**\n   * normalise 'deltas' of the mouse wheel\n   * @param   {Function}    originalEvent\n   * @returns {Array}       deltas\n   */\n  delta: function normaliseDelta(originalEvent){\n    var delta = 0,\n      deltaX = 0,\n      deltaY = 0,\n      absDelta = 0,\n      absDeltaXY = 0,\n      fn;\n\n    // normalise deltas according to the event\n\n    // 'wheel' event\n    if (originalEvent.deltaY) {\n      deltaY = originalEvent.deltaY * -1;\n      delta  = deltaY;\n    }\n    if (originalEvent.deltaX) {\n      deltaX = originalEvent.deltaX;\n      delta  = deltaX * -1;\n    }\n\n    // 'mousewheel' event\n    if (originalEvent.wheelDelta) {\n      delta = originalEvent.wheelDelta;\n    }\n    // webkit\n    if (originalEvent.wheelDeltaY) {\n      deltaY = originalEvent.wheelDeltaY;\n    }\n    if (originalEvent.wheelDeltaX) {\n      deltaX = originalEvent.wheelDeltaX * -1;\n    }\n\n    // 'DomMouseScroll' event\n    if (originalEvent.detail) {\n      delta = originalEvent.detail * -1;\n    }\n\n    // Don't return NaN\n    if (delta === 0) {\n      return [0, 0, 0];\n    }\n\n    // look for lowest delta to normalize the delta values\n    absDelta = Math.abs(delta);\n    if (!lowestDelta || absDelta < lowestDelta) {\n      lowestDelta = absDelta;\n    }\n    absDeltaXY = Math.max(Math.abs(deltaY), Math.abs(deltaX));\n    if (!lowestDeltaXY || absDeltaXY < lowestDeltaXY) {\n      lowestDeltaXY = absDeltaXY;\n    }\n\n    // convert deltas to whole numbers\n    fn = delta > 0 ? 'floor' : 'ceil';\n    delta  = Math[fn](delta / lowestDelta);\n    deltaX = Math[fn](deltaX / lowestDeltaXY);\n    deltaY = Math[fn](deltaY / lowestDeltaXY);\n\n    return [delta, deltaX, deltaY];\n  }\n};\n\nif (typeof window.define === 'function' && window.define.amd) {\n  // AMD\n  window.define('hamster', [], function(){\n    return Hamster;\n  });\n} else if (true) {\n  // CommonJS\n  module.exports = Hamster;\n} else {}\n\n})(window, window.document);\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */\n\n/*global define: false Mustache: true*/\n\n(function defineMustache (global, factory) {\n  if (typeof exports === 'object' && exports && typeof exports.nodeName !== 'string') {\n    factory(exports); // CommonJS\n  } else if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD\n  } else {}\n}(this, function mustacheFactory (mustache) {\n\n  var objectToString = Object.prototype.toString;\n  var isArray = Array.isArray || function isArrayPolyfill (object) {\n    return objectToString.call(object) === '[object Array]';\n  };\n\n  function isFunction (object) {\n    return typeof object === 'function';\n  }\n\n  /**\n   * More correct typeof string handling array\n   * which normally returns typeof 'object'\n   */\n  function typeStr (obj) {\n    return isArray(obj) ? 'array' : typeof obj;\n  }\n\n  function escapeRegExp (string) {\n    return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, '\\\\$&');\n  }\n\n  /**\n   * Null safe way of checking whether or not an object,\n   * including its prototype, has a given property\n   */\n  function hasProperty (obj, propName) {\n    return obj != null && typeof obj === 'object' && (propName in obj);\n  }\n\n  /**\n   * Safe way of detecting whether or not the given thing is a primitive and\n   * whether it has the given property\n   */\n  function primitiveHasOwnProperty (primitive, propName) {  \n    return (\n      primitive != null\n      && typeof primitive !== 'object'\n      && primitive.hasOwnProperty\n      && primitive.hasOwnProperty(propName)\n    );\n  }\n\n  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n  // See https://github.com/janl/mustache.js/issues/189\n  var regExpTest = RegExp.prototype.test;\n  function testRegExp (re, string) {\n    return regExpTest.call(re, string);\n  }\n\n  var nonSpaceRe = /\\S/;\n  function isWhitespace (string) {\n    return !testRegExp(nonSpaceRe, string);\n  }\n\n  var entityMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '/': '&#x2F;',\n    '`': '&#x60;',\n    '=': '&#x3D;'\n  };\n\n  function escapeHtml (string) {\n    return String(string).replace(/[&<>\"'`=\\/]/g, function fromEntityMap (s) {\n      return entityMap[s];\n    });\n  }\n\n  var whiteRe = /\\s*/;\n  var spaceRe = /\\s+/;\n  var equalsRe = /\\s*=/;\n  var curlyRe = /\\s*\\}/;\n  var tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n\n  /**\n   * Breaks up the given `template` string into a tree of tokens. If the `tags`\n   * argument is given here it must be an array with two string values: the\n   * opening and closing tags used in the template (e.g. [ \"<%\", \"%>\" ]). Of\n   * course, the default is to use mustaches (i.e. mustache.tags).\n   *\n   * A token is an array with at least 4 elements. The first element is the\n   * mustache symbol that was used inside the tag, e.g. \"#\" or \"&\". If the tag\n   * did not contain a symbol (i.e. {{myValue}}) this element is \"name\". For\n   * all text that appears outside a symbol this element is \"text\".\n   *\n   * The second element of a token is its \"value\". For mustache tags this is\n   * whatever else was inside the tag besides the opening symbol. For text tokens\n   * this is the text itself.\n   *\n   * The third and fourth elements of the token are the start and end indices,\n   * respectively, of the token in the original template.\n   *\n   * Tokens that are the root node of a subtree contain two more elements: 1) an\n   * array of tokens in the subtree and 2) the index in the original template at\n   * which the closing tag for that section begins.\n   */\n  function parseTemplate (template, tags) {\n    if (!template)\n      return [];\n\n    var sections = [];     // Stack to hold section tokens\n    var tokens = [];       // Buffer to hold the tokens\n    var spaces = [];       // Indices of whitespace tokens on the current line\n    var hasTag = false;    // Is there a {{tag}} on the current line?\n    var nonSpace = false;  // Is there a non-space char on the current line?\n\n    // Strips all whitespace tokens array for the current line\n    // if there was a {{#tag}} on it and otherwise only space.\n    function stripSpace () {\n      if (hasTag && !nonSpace) {\n        while (spaces.length)\n          delete tokens[spaces.pop()];\n      } else {\n        spaces = [];\n      }\n\n      hasTag = false;\n      nonSpace = false;\n    }\n\n    var openingTagRe, closingTagRe, closingCurlyRe;\n    function compileTags (tagsToCompile) {\n      if (typeof tagsToCompile === 'string')\n        tagsToCompile = tagsToCompile.split(spaceRe, 2);\n\n      if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)\n        throw new Error('Invalid tags: ' + tagsToCompile);\n\n      openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\\\s*');\n      closingTagRe = new RegExp('\\\\s*' + escapeRegExp(tagsToCompile[1]));\n      closingCurlyRe = new RegExp('\\\\s*' + escapeRegExp('}' + tagsToCompile[1]));\n    }\n\n    compileTags(tags || mustache.tags);\n\n    var scanner = new Scanner(template);\n\n    var start, type, value, chr, token, openSection;\n    while (!scanner.eos()) {\n      start = scanner.pos;\n\n      // Match any text between tags.\n      value = scanner.scanUntil(openingTagRe);\n\n      if (value) {\n        for (var i = 0, valueLength = value.length; i < valueLength; ++i) {\n          chr = value.charAt(i);\n\n          if (isWhitespace(chr)) {\n            spaces.push(tokens.length);\n          } else {\n            nonSpace = true;\n          }\n\n          tokens.push([ 'text', chr, start, start + 1 ]);\n          start += 1;\n\n          // Check for whitespace on the current line.\n          if (chr === '\\n')\n            stripSpace();\n        }\n      }\n\n      // Match the opening tag.\n      if (!scanner.scan(openingTagRe))\n        break;\n\n      hasTag = true;\n\n      // Get the tag type.\n      type = scanner.scan(tagRe) || 'name';\n      scanner.scan(whiteRe);\n\n      // Get the tag value.\n      if (type === '=') {\n        value = scanner.scanUntil(equalsRe);\n        scanner.scan(equalsRe);\n        scanner.scanUntil(closingTagRe);\n      } else if (type === '{') {\n        value = scanner.scanUntil(closingCurlyRe);\n        scanner.scan(curlyRe);\n        scanner.scanUntil(closingTagRe);\n        type = '&';\n      } else {\n        value = scanner.scanUntil(closingTagRe);\n      }\n\n      // Match the closing tag.\n      if (!scanner.scan(closingTagRe))\n        throw new Error('Unclosed tag at ' + scanner.pos);\n\n      token = [ type, value, start, scanner.pos ];\n      tokens.push(token);\n\n      if (type === '#' || type === '^') {\n        sections.push(token);\n      } else if (type === '/') {\n        // Check section nesting.\n        openSection = sections.pop();\n\n        if (!openSection)\n          throw new Error('Unopened section \"' + value + '\" at ' + start);\n\n        if (openSection[1] !== value)\n          throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\n      } else if (type === 'name' || type === '{' || type === '&') {\n        nonSpace = true;\n      } else if (type === '=') {\n        // Set the tags for the next time around.\n        compileTags(value);\n      }\n    }\n\n    // Make sure there are no open sections when we're done.\n    openSection = sections.pop();\n\n    if (openSection)\n      throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\n\n    return nestTokens(squashTokens(tokens));\n  }\n\n  /**\n   * Combines the values of consecutive text tokens in the given `tokens` array\n   * to a single token.\n   */\n  function squashTokens (tokens) {\n    var squashedTokens = [];\n\n    var token, lastToken;\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      token = tokens[i];\n\n      if (token) {\n        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\n          lastToken[1] += token[1];\n          lastToken[3] = token[3];\n        } else {\n          squashedTokens.push(token);\n          lastToken = token;\n        }\n      }\n    }\n\n    return squashedTokens;\n  }\n\n  /**\n   * Forms the given array of `tokens` into a nested tree structure where\n   * tokens that represent a section have two additional items: 1) an array of\n   * all tokens that appear in that section and 2) the index in the original\n   * template that represents the end of that section.\n   */\n  function nestTokens (tokens) {\n    var nestedTokens = [];\n    var collector = nestedTokens;\n    var sections = [];\n\n    var token, section;\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      token = tokens[i];\n\n      switch (token[0]) {\n        case '#':\n        case '^':\n          collector.push(token);\n          sections.push(token);\n          collector = token[4] = [];\n          break;\n        case '/':\n          section = sections.pop();\n          section[5] = token[2];\n          collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;\n          break;\n        default:\n          collector.push(token);\n      }\n    }\n\n    return nestedTokens;\n  }\n\n  /**\n   * A simple string scanner that is used by the template parser to find\n   * tokens in template strings.\n   */\n  function Scanner (string) {\n    this.string = string;\n    this.tail = string;\n    this.pos = 0;\n  }\n\n  /**\n   * Returns `true` if the tail is empty (end of string).\n   */\n  Scanner.prototype.eos = function eos () {\n    return this.tail === '';\n  };\n\n  /**\n   * Tries to match the given regular expression at the current position.\n   * Returns the matched text if it can match, the empty string otherwise.\n   */\n  Scanner.prototype.scan = function scan (re) {\n    var match = this.tail.match(re);\n\n    if (!match || match.index !== 0)\n      return '';\n\n    var string = match[0];\n\n    this.tail = this.tail.substring(string.length);\n    this.pos += string.length;\n\n    return string;\n  };\n\n  /**\n   * Skips all text until the given regular expression can be matched. Returns\n   * the skipped string, which is the entire tail if no match can be made.\n   */\n  Scanner.prototype.scanUntil = function scanUntil (re) {\n    var index = this.tail.search(re), match;\n\n    switch (index) {\n      case -1:\n        match = this.tail;\n        this.tail = '';\n        break;\n      case 0:\n        match = '';\n        break;\n      default:\n        match = this.tail.substring(0, index);\n        this.tail = this.tail.substring(index);\n    }\n\n    this.pos += match.length;\n\n    return match;\n  };\n\n  /**\n   * Represents a rendering context by wrapping a view object and\n   * maintaining a reference to the parent context.\n   */\n  function Context (view, parentContext) {\n    this.view = view;\n    this.cache = { '.': this.view };\n    this.parent = parentContext;\n  }\n\n  /**\n   * Creates a new context using the given view with this context\n   * as the parent.\n   */\n  Context.prototype.push = function push (view) {\n    return new Context(view, this);\n  };\n\n  /**\n   * Returns the value of the given name in this context, traversing\n   * up the context hierarchy if the value is absent in this context's view.\n   */\n  Context.prototype.lookup = function lookup (name) {\n    var cache = this.cache;\n\n    var value;\n    if (cache.hasOwnProperty(name)) {\n      value = cache[name];\n    } else {\n      var context = this, intermediateValue, names, index, lookupHit = false;\n\n      while (context) {\n        if (name.indexOf('.') > 0) {\n          intermediateValue = context.view;\n          names = name.split('.');\n          index = 0;\n\n          /**\n           * Using the dot notion path in `name`, we descend through the\n           * nested objects.\n           *\n           * To be certain that the lookup has been successful, we have to\n           * check if the last object in the path actually has the property\n           * we are looking for. We store the result in `lookupHit`.\n           *\n           * This is specially necessary for when the value has been set to\n           * `undefined` and we want to avoid looking up parent contexts.\n           *\n           * In the case where dot notation is used, we consider the lookup\n           * to be successful even if the last \"object\" in the path is\n           * not actually an object but a primitive (e.g., a string, or an\n           * integer), because it is sometimes useful to access a property\n           * of an autoboxed primitive, such as the length of a string.\n           **/\n          while (intermediateValue != null && index < names.length) {\n            if (index === names.length - 1)\n              lookupHit = (\n                hasProperty(intermediateValue, names[index]) \n                || primitiveHasOwnProperty(intermediateValue, names[index])\n              );\n\n            intermediateValue = intermediateValue[names[index++]];\n          }\n        } else {\n          intermediateValue = context.view[name];\n\n          /**\n           * Only checking against `hasProperty`, which always returns `false` if\n           * `context.view` is not an object. Deliberately omitting the check\n           * against `primitiveHasOwnProperty` if dot notation is not used.\n           *\n           * Consider this example:\n           * ```\n           * Mustache.render(\"The length of a football field is {{#length}}{{length}}{{/length}}.\", {length: \"100 yards\"})\n           * ```\n           *\n           * If we were to check also against `primitiveHasOwnProperty`, as we do\n           * in the dot notation case, then render call would return:\n           *\n           * \"The length of a football field is 9.\"\n           *\n           * rather than the expected:\n           *\n           * \"The length of a football field is 100 yards.\"\n           **/\n          lookupHit = hasProperty(context.view, name);\n        }\n\n        if (lookupHit) {\n          value = intermediateValue;\n          break;\n        }\n\n        context = context.parent;\n      }\n\n      cache[name] = value;\n    }\n\n    if (isFunction(value))\n      value = value.call(this.view);\n\n    return value;\n  };\n\n  /**\n   * A Writer knows how to take a stream of tokens and render them to a\n   * string, given a context. It also maintains a cache of templates to\n   * avoid the need to parse the same template twice.\n   */\n  function Writer () {\n    this.cache = {};\n  }\n\n  /**\n   * Clears all cached templates in this writer.\n   */\n  Writer.prototype.clearCache = function clearCache () {\n    this.cache = {};\n  };\n\n  /**\n   * Parses and caches the given `template` according to the given `tags` or\n   * `mustache.tags` if `tags` is omitted,  and returns the array of tokens\n   * that is generated from the parse.\n   */\n  Writer.prototype.parse = function parse (template, tags) {\n    var cache = this.cache;\n    var cacheKey = template + ':' + (tags || mustache.tags).join(':');\n    var tokens = cache[cacheKey];\n\n    if (tokens == null)\n      tokens = cache[cacheKey] = parseTemplate(template, tags);\n\n    return tokens;\n  };\n\n  /**\n   * High-level method that is used to render the given `template` with\n   * the given `view`.\n   *\n   * The optional `partials` argument may be an object that contains the\n   * names and templates of partials that are used in the template. It may\n   * also be a function that is used to load partial templates on the fly\n   * that takes a single argument: the name of the partial.\n   *\n   * If the optional `tags` argument is given here it must be an array with two\n   * string values: the opening and closing tags used in the template (e.g.\n   * [ \"<%\", \"%>\" ]). The default is to mustache.tags.\n   */\n  Writer.prototype.render = function render (template, view, partials, tags) {\n    var tokens = this.parse(template, tags);\n    var context = (view instanceof Context) ? view : new Context(view);\n    return this.renderTokens(tokens, context, partials, template, tags);\n  };\n\n  /**\n   * Low-level method that renders the given array of `tokens` using\n   * the given `context` and `partials`.\n   *\n   * Note: The `originalTemplate` is only ever used to extract the portion\n   * of the original template that was contained in a higher-order section.\n   * If the template doesn't use higher-order sections, this argument may\n   * be omitted.\n   */\n  Writer.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate, tags) {\n    var buffer = '';\n\n    var token, symbol, value;\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      value = undefined;\n      token = tokens[i];\n      symbol = token[0];\n\n      if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate);\n      else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate);\n      else if (symbol === '>') value = this.renderPartial(token, context, partials, tags);\n      else if (symbol === '&') value = this.unescapedValue(token, context);\n      else if (symbol === 'name') value = this.escapedValue(token, context);\n      else if (symbol === 'text') value = this.rawValue(token);\n\n      if (value !== undefined)\n        buffer += value;\n    }\n\n    return buffer;\n  };\n\n  Writer.prototype.renderSection = function renderSection (token, context, partials, originalTemplate) {\n    var self = this;\n    var buffer = '';\n    var value = context.lookup(token[1]);\n\n    // This function is used to render an arbitrary template\n    // in the current context by higher-order sections.\n    function subRender (template) {\n      return self.render(template, context, partials);\n    }\n\n    if (!value) return;\n\n    if (isArray(value)) {\n      for (var j = 0, valueLength = value.length; j < valueLength; ++j) {\n        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);\n      }\n    } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {\n      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);\n    } else if (isFunction(value)) {\n      if (typeof originalTemplate !== 'string')\n        throw new Error('Cannot use higher-order sections without the original template');\n\n      // Extract the portion of the original template that the section contains.\n      value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);\n\n      if (value != null)\n        buffer += value;\n    } else {\n      buffer += this.renderTokens(token[4], context, partials, originalTemplate);\n    }\n    return buffer;\n  };\n\n  Writer.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate) {\n    var value = context.lookup(token[1]);\n\n    // Use JavaScript's definition of falsy. Include empty arrays.\n    // See https://github.com/janl/mustache.js/issues/186\n    if (!value || (isArray(value) && value.length === 0))\n      return this.renderTokens(token[4], context, partials, originalTemplate);\n  };\n\n  Writer.prototype.renderPartial = function renderPartial (token, context, partials, tags) {\n    if (!partials) return;\n\n    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];\n    if (value != null)\n      return this.renderTokens(this.parse(value, tags), context, partials, value);\n  };\n\n  Writer.prototype.unescapedValue = function unescapedValue (token, context) {\n    var value = context.lookup(token[1]);\n    if (value != null)\n      return value;\n  };\n\n  Writer.prototype.escapedValue = function escapedValue (token, context) {\n    var value = context.lookup(token[1]);\n    if (value != null)\n      return mustache.escape(value);\n  };\n\n  Writer.prototype.rawValue = function rawValue (token) {\n    return token[1];\n  };\n\n  mustache.name = 'mustache.js';\n  mustache.version = '3.0.1';\n  mustache.tags = [ '{{', '}}' ];\n\n  // All high-level mustache.* functions use this writer.\n  var defaultWriter = new Writer();\n\n  /**\n   * Clears all cached templates in the default writer.\n   */\n  mustache.clearCache = function clearCache () {\n    return defaultWriter.clearCache();\n  };\n\n  /**\n   * Parses and caches the given template in the default writer and returns the\n   * array of tokens it contains. Doing this ahead of time avoids the need to\n   * parse templates on the fly as they are rendered.\n   */\n  mustache.parse = function parse (template, tags) {\n    return defaultWriter.parse(template, tags);\n  };\n\n  /**\n   * Renders the `template` with the given `view` and `partials` using the\n   * default writer. If the optional `tags` argument is given here it must be an\n   * array with two string values: the opening and closing tags used in the\n   * template (e.g. [ \"<%\", \"%>\" ]). The default is to mustache.tags.\n   */\n  mustache.render = function render (template, view, partials, tags) {\n    if (typeof template !== 'string') {\n      throw new TypeError('Invalid template! Template should be a \"string\" ' +\n                          'but \"' + typeStr(template) + '\" was given as the first ' +\n                          'argument for mustache#render(template, view, partials)');\n    }\n\n    return defaultWriter.render(template, view, partials, tags);\n  };\n\n  // This is here for backwards compatibility with 0.4.x.,\n  /*eslint-disable */ // eslint wants camel cased function name\n  mustache.to_html = function to_html (template, view, partials, send) {\n    /*eslint-enable*/\n\n    var result = mustache.render(template, view, partials);\n\n    if (isFunction(send)) {\n      send(result);\n    } else {\n      return result;\n    }\n  };\n\n  // Export the escaping function so that the user may override it.\n  // See https://github.com/janl/mustache.js/issues/244\n  mustache.escape = escapeHtml;\n\n  // Export these mainly for testing, but also for advanced usage.\n  mustache.Scanner = Scanner;\n  mustache.Context = Context;\n  mustache.Writer = Writer;\n\n  return mustache;\n}));\n\n\n/***/ })\n/******/ ]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGVyc2lhbi1kYXRlcGlja2VyL2Rpc3QvanMvcGVyc2lhbi1kYXRlcGlja2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksSUFBeUQ7QUFDN0Q7QUFDQSxNQUFNLEVBS2tDO0FBQ3hDLENBQUM7QUFDRCxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOEJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLDhCQUFtQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsVUFBVSw4QkFBbUIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QixlQUFlLDhCQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0Esb0NBQW9DLDRCQUE0QjtBQUNoRSwwQ0FBMEM7QUFDMUMsV0FBVyw4QkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQixrQ0FBa0M7QUFDL0Q7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQSxpQkFBaUIsOEJBQW1CLENBQUMsOEJBQW1CO0FBQ3hELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGdDQUFtQjs7QUFFcEQ7OztBQUdBLGFBQWEsZ0NBQW1COztBQUVoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQjtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QixlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxXQUFXLFVBQVUsU0FBUyxLQUFLLG9CQUFvQjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0MsZUFBZTtBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrREFBa0QsaUJBQWlCO0FBQ25FO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLE1BQU07O0FBRTdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0QsT0FBTztBQUNQO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wZXJzaWFuLWRhdGVwaWNrZXIvZGlzdC9qcy9wZXJzaWFuLWRhdGVwaWNrZXIuanM/NmUzMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuKiogcGVyc2lhbi1kYXRlcGlja2VyIC0gdjEuMi4wXG4qKiBSZXphIEJhYmFraGFuaSA8YmFiYWtoYW5pLnJlemFAZ21haWwuY29tPlxuKiogaHR0cDovL2JhYmFraGFuaS5naXRodWIuaW8vUGVyc2lhbldlYlRvb2xraXQvZG9jcy9kYXRlcGlja2VyXG4qKiBVbmRlciBNSVQgbGljZW5zZSBcbiovIFxuXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJwZXJzaWFuRGF0ZXBpY2tlclwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJwZXJzaWFuRGF0ZXBpY2tlclwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxuLyoqKioqKi8gXHRcdFx0fSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDUpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgSGVscGVyID0ge1xuXG4gICAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAgICBkZWJvdW5jZTogZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgICAgIHZhciB0aW1lb3V0O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbiBsYXRlcigpIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIWltbWVkaWF0ZSkgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICAgICAgICAgIGlmIChjYWxsTm93KSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEBkZXNjIG5vcm1hbCBsb2dcbiAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgKiBAZXhhbXBsZSBsb2coJ3dob29vb29oYScpXG4gICAgICovXG4gICAgbG9nOiBmdW5jdGlvbiBsb2coaW5wdXQpIHtcbiAgICAgICAgLyplc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgIGNvbnNvbGUubG9nKGlucHV0KTtcbiAgICAgICAgLyplc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgICB9LFxuXG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11c2VsZXNzLWVzY2FwZSAqL1xuICAgIGlzTW9iaWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGVjayA9IGZhbHNlO1xuICAgICAgICAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGlmICgvKGFuZHJvaWR8YmJcXGQrfG1lZWdvKS4rbW9iaWxlfGF2YW50Z298YmFkYVxcL3xibGFja2JlcnJ5fGJsYXplcnxjb21wYWx8ZWxhaW5lfGZlbm5lY3xoaXB0b3B8aWVtb2JpbGV8aXAoaG9uZXxvZCl8aXJpc3xraW5kbGV8bGdlIHxtYWVtb3xtaWRwfG1tcHxtb2JpbGUuK2ZpcmVmb3h8bmV0ZnJvbnR8b3BlcmEgbShvYnxpbilpfHBhbG0oIG9zKT98cGhvbmV8cChpeGl8cmUpXFwvfHBsdWNrZXJ8cG9ja2V0fHBzcHxzZXJpZXMoNHw2KTB8c3ltYmlhbnx0cmVvfHVwXFwuKGJyb3dzZXJ8bGluayl8dm9kYWZvbmV8d2FwfHdpbmRvd3MgY2V8eGRhfHhpaW5vfGFuZHJvaWR8aXBhZHxwbGF5Ym9va3xzaWxrL2kudGVzdChhKSB8fCAvMTIwN3w2MzEwfDY1OTB8M2dzb3w0dGhwfDUwWzEtNl1pfDc3MHN8ODAyc3xhIHdhfGFiYWN8YWMoZXJ8b298c1xcLSl8YWkoa298cm4pfGFsKGF2fGNhfGNvKXxhbW9pfGFuKGV4fG55fHl3KXxhcHR1fGFyKGNofGdvKXxhcyh0ZXx1cyl8YXR0d3xhdShkaXxcXC1tfHIgfHMgKXxhdmFufGJlKGNrfGxsfG5xKXxiaShsYnxyZCl8YmwoYWN8YXopfGJyKGV8dil3fGJ1bWJ8YndcXC0obnx1KXxjNTVcXC98Y2FwaXxjY3dhfGNkbVxcLXxjZWxsfGNodG18Y2xkY3xjbWRcXC18Y28obXB8bmQpfGNyYXd8ZGEoaXR8bGx8bmcpfGRidGV8ZGNcXC1zfGRldml8ZGljYXxkbW9ifGRvKGN8cClvfGRzKDEyfFxcLWQpfGVsKDQ5fGFpKXxlbShsMnx1bCl8ZXIoaWN8azApfGVzbDh8ZXooWzQtN10wfG9zfHdhfHplKXxmZXRjfGZseShcXC18Xyl8ZzEgdXxnNTYwfGdlbmV8Z2ZcXC01fGdcXC1tb3xnbyhcXC53fG9kKXxncihhZHx1bil8aGFpZXxoY2l0fGhkXFwtKG18cHx0KXxoZWlcXC18aGkocHR8dGEpfGhwKCBpfGlwKXxoc1xcLWN8aHQoYyhcXC18IHxffGF8Z3xwfHN8dCl8dHApfGh1KGF3fHRjKXxpXFwtKDIwfGdvfG1hKXxpMjMwfGlhYyggfFxcLXxcXC8pfGlicm98aWRlYXxpZzAxfGlrb218aW0xa3xpbm5vfGlwYXF8aXJpc3xqYSh0fHYpYXxqYnJvfGplbXV8amlnc3xrZGRpfGtlaml8a2d0KCB8XFwvKXxrbG9ufGtwdCB8a3djXFwtfGt5byhjfGspfGxlKG5vfHhpKXxsZyggZ3xcXC8oa3xsfHUpfDUwfDU0fFxcLVthLXddKXxsaWJ3fGx5bnh8bTFcXC13fG0zZ2F8bTUwXFwvfG1hKHRlfHVpfHhvKXxtYygwMXwyMXxjYSl8bVxcLWNyfG1lKHJjfHJpKXxtaShvOHxvYXx0cyl8bW1lZnxtbygwMXwwMnxiaXxkZXxkb3x0KFxcLXwgfG98dil8enopfG10KDUwfHAxfHYgKXxtd2JwfG15d2F8bjEwWzAtMl18bjIwWzItM118bjMwKDB8Mil8bjUwKDB8Mnw1KXxuNygwKDB8MSl8MTApfG5lKChjfG0pXFwtfG9ufHRmfHdmfHdnfHd0KXxub2soNnxpKXxuenBofG8yaW18b3AodGl8d3YpfG9yYW58b3dnMXxwODAwfHBhbihhfGR8dCl8cGR4Z3xwZygxM3xcXC0oWzEtOF18YykpfHBoaWx8cGlyZXxwbChheXx1Yyl8cG5cXC0yfHBvKGNrfHJ0fHNlKXxwcm94fHBzaW98cHRcXC1nfHFhXFwtYXxxYygwN3wxMnwyMXwzMnw2MHxcXC1bMi03XXxpXFwtKXxxdGVrfHIzODB8cjYwMHxyYWtzfHJpbTl8cm8odmV8em8pfHM1NVxcL3xzYShnZXxtYXxtbXxtc3xueXx2YSl8c2MoMDF8aFxcLXxvb3xwXFwtKXxzZGtcXC98c2UoYyhcXC18MHwxKXw0N3xtY3xuZHxyaSl8c2doXFwtfHNoYXJ8c2llKFxcLXxtKXxza1xcLTB8c2woNDV8aWQpfHNtKGFsfGFyfGIzfGl0fHQ1KXxzbyhmdHxueSl8c3AoMDF8aFxcLXx2XFwtfHYgKXxzeSgwMXxtYil8dDIoMTh8NTApfHQ2KDAwfDEwfDE4KXx0YShndHxsayl8dGNsXFwtfHRkZ1xcLXx0ZWwoaXxtKXx0aW1cXC18dFxcLW1vfHRvKHBsfHNoKXx0cyg3MHxtXFwtfG0zfG01KXx0eFxcLTl8dXAoXFwuYnxnMXxzaSl8dXRzdHx2NDAwfHY3NTB8dmVyaXx2aShyZ3x0ZSl8dmsoNDB8NVswLTNdfFxcLXYpfHZtNDB8dm9kYXx2dWxjfHZ4KDUyfDUzfDYwfDYxfDcwfDgwfDgxfDgzfDg1fDk4KXx3M2MoXFwtfCApfHdlYmN8d2hpdHx3aShnIHxuY3xudyl8d21sYnx3b251fHg3MDB8eWFzXFwtfHlvdXJ8emV0b3x6dGVcXC0vaS50ZXN0KGEuc3Vic3RyKDAsIDQpKSkgY2hlY2sgPSB0cnVlO1xuICAgICAgICB9KShuYXZpZ2F0b3IudXNlckFnZW50IHx8IG5hdmlnYXRvci52ZW5kb3IgfHwgd2luZG93Lm9wZXJhKTtcbiAgICAgICAgcmV0dXJuIGNoZWNrO1xuICAgIH0oKSxcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVzZWxlc3MtZXNjYXBlICovXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBzaG93IGRlYnVnIG1lc3NhZ2VzIGlmIHdpbmRvdy5wZXJzaWFuRGF0ZXBpY2tlckRlYnVnIHNldCBhcyB0cnVlXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgKiBAZXhhbXBsZSB3aW5kb3cucGVyc2lhbkRhdGVwaWNrZXJEZWJ1ZyA9IHRydWU7XG4gICAgICogZGVidWcoJ2VsZW1lbnQnLCdtZXNzYWdlJyk7XG4gICAgICovXG4gICAgZGVidWc6IGZ1bmN0aW9uIGRlYnVnKGVsZW0sIGlucHV0KSB7XG4gICAgICAgIC8qZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICAgICAgICBpZiAod2luZG93LnBlcnNpYW5EYXRlcGlja2VyRGVidWcpIHtcbiAgICAgICAgICAgIGlmIChlbGVtLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRGVidWc6ICcgKyBlbGVtLmNvbnN0cnVjdG9yLm5hbWUgKyAnIDogJyArIGlucHV0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0RlYnVnOiAnICsgaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gICAgfSxcbiAgICBkZWxheTogZnVuY3Rpb24gZGVsYXkoY2FsbGJhY2ssIG1zKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh3aW5kb3cuZGF0ZXBpY2tlclRpbWVyKTtcbiAgICAgICAgd2luZG93LmRhdGVwaWNrZXJUaW1lciA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIG1zKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhlbHBlcjtcblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xudmFyIFRlbXBsYXRlID0gXCJcXG48ZGl2IGlkPVxcXCJwbG90SWRcXFwiIGNsYXNzPVxcXCJkYXRlcGlja2VyLXBsb3QtYXJlYSB7e2Nzc0NsYXNzfX1cXFwiPlxcbiAgICB7eyNuYXZpZ2F0b3IuZW5hYmxlZH19XFxuICAgICAgICA8ZGl2IGRhdGEtbmF2aWdhdG9yIGNsYXNzPVxcXCJkYXRlcGlja2VyLW5hdmlnYXRvclxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicHd0LWJ0biBwd3QtYnRuLW5leHRcXFwiPnt7bmF2aWdhdG9yLnRleHQuYnRuTmV4dFRleHR9fTwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInB3dC1idG4gcHd0LWJ0bi1zd2l0Y2hcXFwiPnt7bmF2aWdhdG9yLnN3aXRjaC50ZXh0fX08L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwd3QtYnRuIHB3dC1idG4tcHJldlxcXCI+e3tuYXZpZ2F0b3IudGV4dC5idG5QcmV2VGV4dH19PC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAge3svbmF2aWdhdG9yLmVuYWJsZWR9fVxcbiAgICA8ZGl2IGNsYXNzPVxcXCJkYXRlcGlja2VyLWdyaWQtdmlld1xcXCIgPlxcbiAgICB7eyNkYXlzLmVuYWJsZWR9fVxcbiAgICAgICAge3sjZGF5cy52aWV3TW9kZX19XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJkYXRlcGlja2VyLWRheS12aWV3XFxcIiA+ICAgIFxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm1vbnRoLWdyaWQtYm94XFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaGVhZGVyXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInRpdGxlXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImhlYWRlci1yb3dcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt7I3dlZWtkYXlzLmxpc3R9fVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJoZWFkZXItcm93LWNlbGxcXFwiPnt7Ln19PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAge3svd2Vla2RheXMubGlzdH19XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+ICAgIFxcbiAgICAgICAgICAgICAgICA8dGFibGUgY2VsbHNwYWNpbmc9XFxcIjBcXFwiIGNsYXNzPVxcXCJ0YWJsZS1kYXlzXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICB7eyNkYXlzLmxpc3R9fVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eyMufX1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eyNlbmFibGVkfX1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGRhdGEtZGF0ZT1cXFwie3tkYXRhRGF0ZX19XFxcIiBkYXRhLXVuaXg9XFxcInt7ZGF0YVVuaXh9fVxcXCIgPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gIGNsYXNzPVxcXCJ7eyNvdGhlck1vbnRofX1vdGhlci1tb250aHt7L290aGVyTW9udGh9fVxcXCI+e3t0aXRsZX19PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3sjYWx0Q2FsZW5kYXJTaG93SGludH19XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSAgY2xhc3M9XFxcImFsdGVyLWNhbGVuZGFyLWRheVxcXCI+e3thbHRlckNhbFRpdGxlfX08L2k+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ey9hbHRDYWxlbmRhclNob3dIaW50fX1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ey9lbmFibGVkfX1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7e15lbmFibGVkfX1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGRhdGEtZGF0ZT1cXFwie3tkYXRhRGF0ZX19XFxcIiBkYXRhLXVuaXg9XFxcInt7ZGF0YVVuaXh9fVxcXCIgY2xhc3M9XFxcImRpc2FibGVkXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ7eyNvdGhlck1vbnRofX1vdGhlci1tb250aHt7L290aGVyTW9udGh9fVxcXCI+e3t0aXRsZX19PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3sjYWx0Q2FsZW5kYXJTaG93SGludH19XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSAgY2xhc3M9XFxcImFsdGVyLWNhbGVuZGFyLWRheVxcXCI+e3thbHRlckNhbFRpdGxlfX08L2k+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ey9hbHRDYWxlbmRhclNob3dIaW50fX1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ey9lbmFibGVkfX1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7Ly59fVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt7L2RheXMubGlzdH19XFxuICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxcbiAgICAgICAgICAgICAgICA8L3RhYmxlPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICB7ey9kYXlzLnZpZXdNb2RlfX1cXG4gICAge3svZGF5cy5lbmFibGVkfX1cXG4gICAgXFxuICAgIHt7I21vbnRoLmVuYWJsZWR9fVxcbiAgICAgICAge3sjbW9udGgudmlld01vZGV9fVxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImRhdGVwaWNrZXItbW9udGgtdmlld1xcXCI+XFxuICAgICAgICAgICAgICAgIHt7I21vbnRoLmxpc3R9fVxcbiAgICAgICAgICAgICAgICAgICAge3sjZW5hYmxlZH19ICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBkYXRhLXllYXI9XFxcInt7eWVhcn19XFxcIiBkYXRhLW1vbnRoPVxcXCJ7e2RhdGFNb250aH19XFxcIiBjbGFzcz1cXFwibW9udGgtaXRlbSB7eyNzZWxlY3RlZH19c2VsZWN0ZWR7ey9zZWxlY3RlZH19XFxcIj57e3RpdGxlfX08L3NtYWxsPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAge3svZW5hYmxlZH19XFxuICAgICAgICAgICAgICAgICAgICB7e15lbmFibGVkfX0gICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGRhdGEteWVhcj1cXFwie3t5ZWFyfX1cXFwiZGF0YS1tb250aD1cXFwie3tkYXRhTW9udGh9fVxcXCIgY2xhc3M9XFxcIm1vbnRoLWl0ZW0gbW9udGgtaXRlbS1kaXNhYmxlIHt7I3NlbGVjdGVkfX1zZWxlY3RlZHt7L3NlbGVjdGVkfX1cXFwiPnt7dGl0bGV9fTwvc21hbGw+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICB7ey9lbmFibGVkfX1cXG4gICAgICAgICAgICAgICAge3svbW9udGgubGlzdH19XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICB7ey9tb250aC52aWV3TW9kZX19XFxuICAgIHt7L21vbnRoLmVuYWJsZWR9fVxcbiAgICBcXG4gICAge3sjeWVhci5lbmFibGVkIH19XFxuICAgICAgICB7eyN5ZWFyLnZpZXdNb2RlIH19XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZGF0ZXBpY2tlci15ZWFyLXZpZXdcXFwiID5cXG4gICAgICAgICAgICAgICAge3sjeWVhci5saXN0fX1cXG4gICAgICAgICAgICAgICAgICAgIHt7I2VuYWJsZWR9fVxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgZGF0YS15ZWFyPVxcXCJ7e2RhdGFZZWFyfX1cXFwiIGNsYXNzPVxcXCJ5ZWFyLWl0ZW0ge3sjc2VsZWN0ZWR9fXNlbGVjdGVke3svc2VsZWN0ZWR9fVxcXCI+e3t0aXRsZX19PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICB7ey9lbmFibGVkfX1cXG4gICAgICAgICAgICAgICAgICAgIHt7XmVuYWJsZWR9fVxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgZGF0YS15ZWFyPVxcXCJ7e2RhdGFZZWFyfX1cXFwiIGNsYXNzPVxcXCJ5ZWFyLWl0ZW0geWVhci1pdGVtLWRpc2FibGUge3sjc2VsZWN0ZWR9fXNlbGVjdGVke3svc2VsZWN0ZWR9fVxcXCI+e3t0aXRsZX19PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICB7ey9lbmFibGVkfX0gICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICB7ey95ZWFyLmxpc3R9fVxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAge3sveWVhci52aWV3TW9kZSB9fVxcbiAgICB7ey95ZWFyLmVuYWJsZWQgfX1cXG4gICAgXFxuICAgIDwvZGl2PlxcbiAgICB7eyN0aW1lfX1cXG4gICAge3sjZW5hYmxlZH19XFxuICAgIDxkaXYgY2xhc3M9XFxcImRhdGVwaWNrZXItdGltZS12aWV3XFxcIj5cXG4gICAgICAgIHt7I2hvdXIuZW5hYmxlZH19XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaG91ciB0aW1lLXNlZ21lbnRcXFwiIGRhdGEtdGltZS1rZXk9XFxcImhvdXJcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1cC1idG5cXFwiIGRhdGEtdGltZS1rZXk9XFxcImhvdXJcXFwiPlxcdTI1QjI8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGlucHV0IGRpc2FibGVkIHZhbHVlPVxcXCJ7e2hvdXIudGl0bGV9fVxcXCIgdHlwZT1cXFwidGV4dFxcXCIgcGxhY2Vob2xkZXI9XFxcImhvdXJcXFwiIGNsYXNzPVxcXCJob3VyLWlucHV0XFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZG93bi1idG5cXFwiIGRhdGEtdGltZS1rZXk9XFxcImhvdXJcXFwiPlxcdTI1QkM8L2Rpdj4gICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgIDwvZGl2PiAgICAgICBcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJkaXZpZGVyXFxcIj5cXG4gICAgICAgICAgICAgICAgPHNwYW4+Ojwvc3Bhbj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIHt7L2hvdXIuZW5hYmxlZH19XFxuICAgICAgICB7eyNtaW51dGUuZW5hYmxlZH19XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibWludXRlIHRpbWUtc2VnbWVudFxcXCIgZGF0YS10aW1lLWtleT1cXFwibWludXRlXFxcIiA+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVwLWJ0blxcXCIgZGF0YS10aW1lLWtleT1cXFwibWludXRlXFxcIj5cXHUyNUIyPC9kaXY+XFxuICAgICAgICAgICAgICAgIDxpbnB1dCBkaXNhYmxlZCB2YWx1ZT1cXFwie3ttaW51dGUudGl0bGV9fVxcXCIgdHlwZT1cXFwidGV4dFxcXCIgcGxhY2Vob2xkZXI9XFxcIm1pbnV0ZVxcXCIgY2xhc3M9XFxcIm1pbnV0ZS1pbnB1dFxcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImRvd24tYnRuXFxcIiBkYXRhLXRpbWUta2V5PVxcXCJtaW51dGVcXFwiPlxcdTI1QkM8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj4gICAgICAgIFxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImRpdmlkZXIgc2Vjb25kLWRpdmlkZXJcXFwiPlxcbiAgICAgICAgICAgICAgICA8c3Bhbj46PC9zcGFuPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAge3svbWludXRlLmVuYWJsZWR9fVxcbiAgICAgICAge3sjc2Vjb25kLmVuYWJsZWR9fVxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNlY29uZCB0aW1lLXNlZ21lbnRcXFwiIGRhdGEtdGltZS1rZXk9XFxcInNlY29uZFxcXCIgID5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidXAtYnRuXFxcIiBkYXRhLXRpbWUta2V5PVxcXCJzZWNvbmRcXFwiID5cXHUyNUIyPC9kaXY+XFxuICAgICAgICAgICAgICAgIDxpbnB1dCBkaXNhYmxlZCB2YWx1ZT1cXFwie3tzZWNvbmQudGl0bGV9fVxcXCIgIHR5cGU9XFxcInRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCJzZWNvbmRcXFwiIGNsYXNzPVxcXCJzZWNvbmQtaW5wdXRcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJkb3duLWJ0blxcXCIgZGF0YS10aW1lLWtleT1cXFwic2Vjb25kXFxcIiA+XFx1MjVCQzwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImRpdmlkZXIgbWVyaWRpYW4tZGl2aWRlclxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZGl2aWRlciBtZXJpZGlhbi1kaXZpZGVyXFxcIj48L2Rpdj5cXG4gICAgICAgIHt7L3NlY29uZC5lbmFibGVkfX1cXG4gICAgICAgIHt7I21lcmlkaWFuLmVuYWJsZWR9fVxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm1lcmlkaWFuIHRpbWUtc2VnbWVudFxcXCIgZGF0YS10aW1lLWtleT1cXFwibWVyaWRpYW5cXFwiID5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidXAtYnRuXFxcIiBkYXRhLXRpbWUta2V5PVxcXCJtZXJpZGlhblxcXCI+XFx1MjVCMjwvZGl2PlxcbiAgICAgICAgICAgICAgICA8aW5wdXQgZGlzYWJsZWQgdmFsdWU9XFxcInt7bWVyaWRpYW4udGl0bGV9fVxcXCIgdHlwZT1cXFwidGV4dFxcXCIgY2xhc3M9XFxcIm1lcmlkaWFuLWlucHV0XFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZG93bi1idG5cXFwiIGRhdGEtdGltZS1rZXk9XFxcIm1lcmlkaWFuXFxcIj5cXHUyNUJDPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICB7ey9tZXJpZGlhbi5lbmFibGVkfX1cXG4gICAgPC9kaXY+XFxuICAgIHt7L2VuYWJsZWR9fVxcbiAgICB7ey90aW1lfX1cXG4gICAgXFxuICAgIHt7I3Rvb2xib3h9fVxcbiAgICB7eyNlbmFibGVkfX1cXG4gICAgPGRpdiBjbGFzcz1cXFwidG9vbGJveFxcXCI+XFxuICAgICAgICB7eyN0b29sYm94LnN1Ym1pdEJ1dHRvbi5lbmFibGVkfX1cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwd3QtYnRuLXN1Ym1pdFxcXCI+e3tzdWJtaXRCdXR0b25UZXh0fX08L2Rpdj5cXG4gICAgICAgIHt7L3Rvb2xib3guc3VibWl0QnV0dG9uLmVuYWJsZWR9fSAgICAgICAgXFxuICAgICAgICB7eyN0b29sYm94LnRvZGF5QnV0dG9uLmVuYWJsZWR9fVxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInB3dC1idG4tdG9kYXlcXFwiPnt7dG9kYXlCdXR0b25UZXh0fX08L2Rpdj5cXG4gICAgICAgIHt7L3Rvb2xib3gudG9kYXlCdXR0b24uZW5hYmxlZH19ICAgICAgICBcXG4gICAgICAgIHt7I3Rvb2xib3guY2FsZW5kYXJTd2l0Y2guZW5hYmxlZH19XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicHd0LWJ0bi1jYWxlbmRhclxcXCI+e3tjYWxlbmRhclN3aXRjaFRleHR9fTwvZGl2PlxcbiAgICAgICAge3svdG9vbGJveC5jYWxlbmRhclN3aXRjaC5lbmFibGVkfX1cXG4gICAgPC9kaXY+XFxuICAgIHt7L2VuYWJsZWR9fVxcbiAgICB7e15lbmFibGVkfX1cXG4gICAgICAgIHt7I29ubHlUaW1lUGlja2VyfX1cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInRvb2xib3hcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInB3dC1idG4tc3VibWl0XFxcIj57e3N1Ym1pdEJ1dHRvblRleHR9fTwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICB7ey9vbmx5VGltZVBpY2tlcn19XFxuICAgIHt7L2VuYWJsZWR9fVxcbiAgICB7ey90b29sYm94fX1cXG48L2Rpdj5cXG5cIjtcblxubW9kdWxlLmV4cG9ydHMgPSBUZW1wbGF0ZTtcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBTdGF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xudmFyIFRvb2xib3ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbnZhciBWaWV3ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG52YXIgSW5wdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIEFQSSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgTmF2aWdhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbnZhciBPcHRpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbnZhciBQZXJzaWFuRGF0ZVdyYXBwZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxuLyoqXG4gKiBNYWluIGRhdGVwaWNrZXIgb2JqZWN0LCBtYW5hZ2UgZXZlcnkgdGhpbmdzXG4gKi9cblxudmFyIE1vZGVsID0gZnVuY3Rpb24gKCkge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gaW5wdXRFbGVtZW50XG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBNb2RlbChpbnB1dEVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9kZWwpO1xuXG4gICAgcmV0dXJuIHRoaXMuY29tcG9uZW50cyhpbnB1dEVsZW1lbnQsIG9wdGlvbnMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1vZGVsLCBbe1xuICAgIGtleTogJ2NvbXBvbmVudHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRzKGlucHV0RWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgLyoqXG4gICAgICAgKiBAZGVzYyBbaW5pdGlhbFVuaXg9bnVsbF1cbiAgICAgICAqIEB0eXBlIHt1bml4fVxuICAgICAgICovXG4gICAgICB0aGlzLmluaXRpYWxVbml4ID0gbnVsbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAZGVzYyBpbnB1dEVsZW1lbnQ9aW5wdXRFbGVtZW50XG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICB0aGlzLmlucHV0RWxlbWVudCA9IGlucHV0RWxlbWVudDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAZGVzYyBoYW5kbGUgd29ya3MgYWJvdXQgY29uZmlnXG4gICAgICAgKiBAdHlwZSB7T3B0aW9uc31cbiAgICAgICAqL1xuICAgICAgdGhpcy5vcHRpb25zID0gbmV3IE9wdGlvbnMob3B0aW9ucywgdGhpcyk7XG5cbiAgICAgIC8qKlxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHtQZXJzaWFuRGF0ZVdyYXBwZXJ9XG4gICAgICAgKi9cbiAgICAgIHRoaXMuUGVyc2lhbkRhdGUgPSBuZXcgUGVyc2lhbkRhdGVXcmFwcGVyKHRoaXMpO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBkZXNjIHNldCBhbmQgZ2V0IHNlbGVjdGVkIGFuZCB2aWV3IGFuZCBvdGhlciBzdGF0ZVxuICAgICAgICogQHR5cGUge1N0YXRlfVxuICAgICAgICovXG4gICAgICB0aGlzLnN0YXRlID0gbmV3IFN0YXRlKHRoaXMpO1xuXG4gICAgICB0aGlzLmFwaSA9IG5ldyBBUEkodGhpcyk7XG5cbiAgICAgIC8qKlxuICAgICAgICogQGRlc2MgaGFuZGxlIHdvcmtzIGFib3V0IGlucHV0IGFuZCBhbHQgZmllbGQgaW5wdXQgZWxlbWVudFxuICAgICAgICogQHR5cGUge0lucHV0fVxuICAgICAgICovXG4gICAgICB0aGlzLmlucHV0ID0gbmV3IElucHV0KHRoaXMsIGlucHV0RWxlbWVudCk7XG5cbiAgICAgIC8qKlxuICAgICAgICogQGRlc2MgcmVuZGVyIGRhdGVwaWNrZXIgdmlldyBiYXNlIG9uIFN0YXRlXG4gICAgICAgKiBAdHlwZSB7Vmlld31cbiAgICAgICAqL1xuICAgICAgdGhpcy52aWV3ID0gbmV3IFZpZXcodGhpcyk7XG5cbiAgICAgIC8qKlxuICAgICAgICogQGRlc2MgaGFuZGxlIHdvcmtzIGFib3V0IHRvb2xib3hcbiAgICAgICAqIEB0eXBlIHtUb29sYm94fVxuICAgICAgICovXG4gICAgICB0aGlzLnRvb2xib3ggPSBuZXcgVG9vbGJveCh0aGlzKTtcblxuICAgICAgLyoqXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHVuaXhcbiAgICAgICAqL1xuICAgICAgdGhpcy51cGRhdGVJbnB1dCA9IGZ1bmN0aW9uICh1bml4KSB7XG4gICAgICAgIHRoaXMuaW5wdXQudXBkYXRlKHVuaXgpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5zdGF0ZS5zZXRWaWV3RGF0ZVRpbWUoJ3VuaXgnLCB0aGlzLmlucHV0LmdldE9uSW5pdFN0YXRlKCkpO1xuICAgICAgdGhpcy5zdGF0ZS5zZXRTZWxlY3RlZERhdGVUaW1lKCd1bml4JywgdGhpcy5pbnB1dC5nZXRPbkluaXRTdGF0ZSgpKTtcbiAgICAgIHRoaXMudmlldy5yZW5kZXIoKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAZGVzYyBoYW5kbGUgbmF2aWdhdGlvbiBhbmQgZGF0ZW9pY2tlciBlbGVtZW50IGV2ZW50c1xuICAgICAgICogQHR5cGUge05hdmlnYXRvcn1cbiAgICAgICAqL1xuICAgICAgdGhpcy5uYXZpZ2F0b3IgPSBuZXcgTmF2aWdhdG9yKHRoaXMpO1xuXG4gICAgICByZXR1cm4gdGhpcy5hcGk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1vZGVsO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVsO1xuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBBUEkgZG9jdW1lbnRhdGlvbiBmb3IgcGVyc2lhbi1kYXRlcGlja2VyXG4gKi9cbnZhciBBUEkgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQVBJKG1vZGVsKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBUEkpO1xuXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gZ2V0IGN1cnJlbnQgb3B0aW9uIG9iamVjdFxuICAgICAqIEBleGFtcGxlIHZhciBwZCA9ICQoJy5zZWxlY3RvcicpLnBlcnNpYW5EYXRlcGlja2VyKCk7XG4gICAgICogY29uc29sZS5sb2cocGQub3B0aW9ucyk7XG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhBUEksIFt7XG4gICAgICAgIGtleTogJ3Nob3cnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBtYWtlIGRhdGVwaWNrZXIgdmlzaWJsZVxuICAgICAgICAgKiBAZXhhbXBsZSB2YXIgcGQgPSAkKCcuc2VsZWN0b3InKS5wZXJzaWFuRGF0ZXBpY2tlcigpO1xuICAgICAgICAgKiBwZC5zaG93KCk7XG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgICAgICAgIHRoaXMubW9kZWwudmlldy5zaG93KCk7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLm9wdGlvbnMub25TaG93KHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWw7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIHJldHVybiBkYXRlcGlja2VyIGN1cnJlbnQgc3RhdGVcbiAgICAgICAgICogQHNpbmNlIDEuMC4wXG4gICAgICAgICAqIEBleGFtcGxlIHZhciBwZCA9ICQoJy5zZWxlY3RvcicpLnBlcnNpYW5EYXRlcGlja2VyKCk7XG4gICAgICAgICAqIHZhciBzdGF0ZSA9IHBkLmdldFN0YXRlKCk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKHN0YXRlLnNlbGVjdGVkKTtcbiAgICAgICAgICogY29uc29sZS5sb2coc3RhdGUudmlldyk7XG4gICAgICAgICAqICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldFN0YXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuc3RhdGU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIG1ha2UgZGF0ZXBpY2tlciBpbnZpc2libGVcbiAgICAgICAgICogQGV4YW1wbGUgdmFyIHBkID0gJCgnLnNlbGVjdG9yJykucGVyc2lhbkRhdGVwaWNrZXIoKTtcbiAgICAgICAgICogcGQuc2hvdygpO1xuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGlkZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgICAgICAgdGhpcy5tb2RlbC52aWV3LmhpZGUoKTtcbiAgICAgICAgICAgIHRoaXMubW9kZWwub3B0aW9ucy5vbkhpZGUodGhpcy5tb2RlbCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gdG9nZ2xlIGRhdGVwaWNrZXIgdmlzaWJpbGl0eSBzdGF0ZVxuICAgICAgICAgKiBAZXhhbXBsZSB2YXIgcGQgPSAkKCcuc2VsZWN0b3InKS5wZXJzaWFuRGF0ZXBpY2tlcigpO1xuICAgICAgICAgKiBwZC50b2dnbGUoKTtcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvZ2dsZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGUoKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnZpZXcudG9nZ2xlKCk7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLm9wdGlvbnMub25Ub2dnbGUodGhpcy5tb2RlbCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gZGVzdHJveSBldmVyeSB0aGluZyBjbGVhbiBkb20gYW5kXG4gICAgICAgICAqIEBleGFtcGxlIHZhciBwZCA9ICQoJy5zZWxlY3RvcicpLnBlcnNpYW5EYXRlcGlja2VyKCk7XG4gICAgICAgICAqIHBkLmRlc3Ryb3koKTtcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC52aWV3LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLm9wdGlvbnMub25EZXN0cm95KHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm1vZGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBzZXQgc2VsZWN0ZWQgZGF0ZSBvZiBkYXRlcGlja2VyIGFjY2VwdCB1bml4IHRpbWVzdGFtcFxuICAgICAgICAgKiBAcGFyYW0gdW5peFxuICAgICAgICAgKiBAZXhhbXBsZSB2YXIgcGQgPSAkKCcuc2VsZWN0b3InKS5wZXJzaWFuRGF0ZXBpY2tlcigpO1xuICAgICAgICAgKiBwZC5zZXREYXRlKDEzODIyNzYwOTExMDApXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZXREYXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldERhdGUodW5peCkge1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5zdGF0ZS5zZXRTZWxlY3RlZERhdGVUaW1lKCd1bml4JywgdW5peCk7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnN0YXRlLnNldFZpZXdEYXRlVGltZSgndW5peCcsIHVuaXgpO1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5zdGF0ZS5zZXRTZWxlY3RlZERhdGVUaW1lKCd1bml4JywgdW5peCk7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnZpZXcucmVuZGVyKHRoaXMudmlldyk7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLm9wdGlvbnMub25TZXQodW5peCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlbDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnb3B0aW9ucycsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwub3B0aW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gc2V0IG9wdGlvbnMgbGl2ZVxuICAgICAgICAgKiBAZXhhbXBsZSB2YXIgcGQgPSAkKCcuc2VsZWN0b3InKS5wZXJzaWFuRGF0ZXBpY2tlcigpO1xuICAgICAgICAgKiBwZC5vcHRpb25zO1xuICAgICAgICAgKiAvL3JldHVybiBjdXJyZW50IG9wdGlvbnNcbiAgICAgICAgICogcGQub3B0aW9ucyA9IHt9O1xuICAgICAgICAgKiAvLyBzZXQgb3B0aW9ucyBhbmQgcmVuZGVyIGRhdGVwaWNrZXIgd2l0aCBuZXcgb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChpbnB1dE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBvcHQgPSAkLmV4dGVuZCh0cnVlLCB0aGlzLm1vZGVsLm9wdGlvbnMsIGlucHV0T3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnZpZXcuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5jb21wb25lbnRzKHRoaXMubW9kZWwuaW5wdXRFbGVtZW50LCBvcHQpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEFQSTtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBUEk7XG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgSGVscGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gcGVyc2lhbi1kYXRlcGlja2VyIGNvbmZpZ3VyYXRpb24gZG9jdW1lbnRcbiAqL1xudmFyIENvbmZpZyA9IHtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIHNldCBkZWZhdWx0IGNhbGVuZGFyIG1vZGUgb2YgZGF0ZXBpY2tlciwgYXZhaWxhYmxlIG9wdGlvbnM6ICdwZXJzaWFuJywgJ2dyZWdvcmlhbidcbiAgICogQGRlZmF1bHQgJ3BlcnNpYW4nXG4gICAqIEB0eXBlIHN0cmluZ1xuICAgKiBAc2luY2UgMS4wLjBcbiAgICovXG4gICdjYWxlbmRhclR5cGUnOiAncGVyc2lhbicsXG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBjYWxlbmRhciB0eXBlIGFuZCBsb2NhbGl6YXRpb24gY29uZmlndXJhdGlvblxuICAgKiBAdHlwZSBvYmplY3RcbiAgICogQHNpbmNlIDEuMC4wXG4gICAqIEBleGFtcGxlXG4gICAqIHtcbiAgICogICAgICdwZXJzaWFuJzoge1xuICAgKiAgICAgICAgICdsb2NhbGUnOiAnZmEnLFxuICAgKiAgICAgICAgICdzaG93SGludCc6IGZhbHNlLFxuICAgKiAgICAgICAgICdsZWFwWWVhck1vZGUnOiAnYWxnb3JpdGhtaWMnIC8vIFwiYXN0cm9ub21pY2FsXCJcbiAgICogICAgIH0sXG4gICAqXG4gICAqICAgICAnZ3JlZ29yaWFuJzoge1xuICAgKiAgICAgICAgICdsb2NhbGUnOiAnZW4nLFxuICAgKiAgICAgICAgICdzaG93SGludCc6IGZhbHNlXG4gICAqICAgICB9XG4gICAqIH1cbiAgICpcbiAgICpcbiAgICpcbiAgICovXG4gICdjYWxlbmRhcic6IHtcblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBQZXJzaWFuIGNhbGVuZGFyIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAdHlwZSBvYmplY3RcbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKi9cbiAgICAncGVyc2lhbic6IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBAZGVzY3JpcHRpb24gc2V0IGxvY2FsZSBvZiBQZXJzaWFuIGNhbGVuZGFyIGF2YWlsYWJsZSBvcHRpb25zOiAnZmEnLCAnZW4nXG4gICAgICAgKiBAZGVmYXVsdCAnZmEnXG4gICAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAgICovXG4gICAgICAnbG9jYWxlJzogJ2ZhJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBAZGVzY3JpcHRpb24gaWYgc2V0IHRydWUsIHNtYWxsIGRhdGUgaGludCBvZiB0aGlzIGNhbGVuZGFyIHdpbGwgYmUgc2hvd24gb24gYW5vdGhlciBjYWxlbmRhclxuICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAgICovXG4gICAgICAnc2hvd0hpbnQnOiBmYWxzZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAZGVzY3JpcHRpb24gUGVyc2lhbiBjYWxlbmRhciBsZWFwIHllYXIgY2FsY3VsYXRpb24gbW9kZSwgYXZhaWxhYmxlIG9wdGlvbnM6ICdhbGdvcml0aG1pYycsICdhc3Ryb25vbWljYWwnXG4gICAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgICAqIEBsaW5rIGh0dHA6Ly9iYWJha2hhbmkuZ2l0aHViLmlvL1BlcnNpYW5XZWJUb29sa2l0L2RvYy9wZXJzaWFuLWRhdGUvbGVhcHllYXJcbiAgICAgICAqIEBkZWZhdWx0ICdhbGdvcml0aG1pYydcbiAgICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAgICovXG4gICAgICAnbGVhcFllYXJNb2RlJzogJ2FsZ29yaXRobWljJyAvLyBcImFzdHJvbm9taWNhbFwiXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBHcmVnb3JpYW4gY2FsZW5kYXIgY29uZmlndXJhdGlvblxuICAgICAqIEB0eXBlIG9iamVjdFxuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqL1xuICAgICdncmVnb3JpYW4nOiB7XG5cbiAgICAgIC8qKlxuICAgICAgICogQGRlc2NyaXB0aW9uIHNldCBsb2NhbGUgb2YgR3JlZ29yaWFuIGNhbGVuZGFyIGF2YWlsYWJsZSBvcHRpb25zOiAnZmEnLCAnZW4nXG4gICAgICAgKiBAZGVmYXVsdCAnZW4nXG4gICAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAgICovXG4gICAgICAnbG9jYWxlJzogJ2VuJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBAZGVzY3JpcHRpb24gaWYgc2V0IHRydWUsIHNtYWxsIGRhdGUgaGludCBvZiB0aGlzIGNhbGVuZGFyIHdpbGwgYmUgc2hvd24gb24gYW5vdGhlciBjYWxlbmRhclxuICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAgICovXG4gICAgICAnc2hvd0hpbnQnOiBmYWxzZVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIGlmIHNldCB0cnVlIG1ha2UgZW5hYmxlIHJlc3BvbnNpdmUgdmlldyBvbiBtb2JpbGUgZGV2aWNlc1xuICAgKiBAdHlwZSBib29sZWFuXG4gICAqIEBzaW5jZSAxLjAuMFxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICAncmVzcG9uc2l2ZSc6IHRydWUsXG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBpZiB0cnVlIGRhdGVwaWNrZXIgcmVuZGVyIGlubGluZVxuICAgKiBAdHlwZSBib29sZWFuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICAnaW5saW5lJzogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBJZiBzZXQgdHJ1ZSBkYXRlcGlja2VyIGluaXQgd2l0aCBpbnB1dCB2YWx1ZSBkYXRlLCB1c2UgZGF0YS1kYXRlIHByb3BlcnR5IHdoZW4geW91IHdhbnQgc2V0IGlubGluZSBkYXRlcGlja2VyIGluaXRpYWwgdmFsdWVcbiAgICogQHR5cGUgYm9vbGVhblxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICAnaW5pdGlhbFZhbHVlJzogdHJ1ZSxcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIEluaXRpYWwgdmFsdWUgY2FsZW5kYXIgdHlwZSwgYWNjZXB0OiAncGVyc2lhbicsICdncmVnb3JpYW4nXG4gICAqIEB0eXBlIGJvb2xlYW5cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgJ2luaXRpYWxWYWx1ZVR5cGUnOiAnZ3JlZ29yaWFuJyxcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIGZyb20gdjEuMC4wIHRoaXMgb3B0aW9ucyBpcyBkZXByZWNhdGVkLCB1c2UgY2FsZW5kYXIucGVyc2lhbi5sb2NhbGUgaW5zdGVhZFxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAdHlwZSBib29sZWFuXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gICdwZXJzaWFuRGlnaXQnOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gZGVmYXVsdCB2aWV3IG1vZGUsIEFjY2VwdGFibGUgdmFsdWUgOiBkYXksbW9udGgseWVhclxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnZGF5J1xuICAgKi9cbiAgJ3ZpZXdNb2RlJzogJ2RheScsXG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiB0aGUgZGF0ZSBmb3JtYXQsIGNvbWJpbmF0aW9uIG9mIGQsIGRkLCBtLCBtbSwgeXksIHl5eS5cbiAgICogQGxpbmsgaHR0cDovL2JhYmFraGFuaS5naXRodWIuaW8vUGVyc2lhbldlYlRvb2xraXQvZG9jL3BlcnNpYW4tZGF0ZS8jZm9ybWF0XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCAnTExMTCdcbiAgICovXG4gICdmb3JtYXQnOiAnTExMTCcsXG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBmb3JtYXQgdmFsdWUgb2YgaW5wdXRcbiAgICogQHBhcmFtIHVuaXhEYXRlXG4gICAqIEBkZWZhdWx0IGZ1bmN0aW9uXG4gICAqIEBleGFtcGxlIGZ1bmN0aW9uICh1bml4RGF0ZSkge1xuICAgKiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICogICAgICB2YXIgcGRhdGUgPSBuZXcgcGVyc2lhbkRhdGUodW5peERhdGUpO1xuICAgKiAgICAgIHBkYXRlLmZvcm1hdFBlcnNpYW4gPSB0aGlzLnBlcnNpYW5EaWdpdDtcbiAgICogICAgICByZXR1cm4gcGRhdGUuZm9ybWF0KHNlbGYuZm9ybWF0KTtcbiAgICogIH1cbiAgICovXG4gICdmb3JtYXR0ZXInOiBmdW5jdGlvbiBmb3JtYXR0ZXIodW5peERhdGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIHBkYXRlID0gdGhpcy5tb2RlbC5QZXJzaWFuRGF0ZS5kYXRlKHVuaXhEYXRlKTtcbiAgICByZXR1cm4gcGRhdGUuZm9ybWF0KHNlbGYuZm9ybWF0KTtcbiAgfSxcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIEFuIGlucHV0IGVsZW1lbnQgdGhhdCBpcyB0byBiZSB1cGRhdGVkIHdpdGggdGhlIHNlbGVjdGVkIGRhdGUgZnJvbSB0aGUgZGF0ZXBpY2tlci4gVXNlIHRoZSBhbHRGb3JtYXQgb3B0aW9uIHRvIGNoYW5nZSB0aGUgZm9ybWF0IG9mIHRoZSBkYXRlIHdpdGhpbiB0aGlzIGZpZWxkLiBMZWF2ZSBhcyBibGFuayBmb3Igbm8gYWx0ZXJuYXRlIGZpZWxkLiBhY2NlcHRhYmxlIHZhbHVlOiA6ICcjZWxlbWVudElkJywnLmVsZW1lbnQtY2xhc3MnXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKiBAZXhhbXBsZVxuICAgKiBhbHRGaWVsZDogJyNpbnB1dEFsdEZpcmxkJ1xuICAgKlxuICAgKiBhbHRGaWVsZDogJy5pbnB1dC1hbHQtZmllbGQnXG4gICAqL1xuICAnYWx0RmllbGQnOiBmYWxzZSxcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIHRoZSBkYXRlIGZvcm1hdCwgY29tYmluYXRpb24gb2YgZCwgZGQsIG0sIG1tLCB5eSwgeXl5LlxuICAgKiBAbGluayBodHRwOi8vYmFiYWtoYW5pLmdpdGh1Yi5pby9QZXJzaWFuV2ViVG9vbGtpdC9kb2MvcGVyc2lhbi1kYXRlLyNmb3JtYXRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJ3VuaXgnXG4gICAqL1xuICAnYWx0Rm9ybWF0JzogJ3VuaXgnLFxuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gZm9ybWF0IHZhbHVlIG9mICdhbHRGaWVsZCcgaW5wdXRcbiAgICogQHBhcmFtIHVuaXhEYXRlXG4gICAqIEBkZWZhdWx0IGZ1bmN0aW9uXG4gICAqIEBleGFtcGxlIGZ1bmN0aW9uICh1bml4RGF0ZSkge1xuICAgKiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICogICAgICB2YXIgdGhpc0FsdEZvcm1hdCA9IHNlbGYuYWx0Rm9ybWF0LnRvTG93ZXJDYXNlKCk7XG4gICAqICAgICAgaWYgKHRoaXNBbHRGb3JtYXQgPT09ICdncmVnb3JpYW4nIHx8IHRoaXNBbHRGb3JtYXQgPT09ICdnJykge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IERhdGUodW5peERhdGUpO1xuICAgKiAgICAgIH1cbiAgICogICAgICBpZiAodGhpc0FsdEZvcm1hdCA9PT0gJ3VuaXgnIHx8IHRoaXNBbHRGb3JtYXQgPT09ICd1Jykge1xuICAgKiAgICAgICAgICByZXR1cm4gdW5peERhdGU7XG4gICAqICAgICAgfVxuICAgKiAgICAgIGVsc2Uge1xuICAgKiAgICAgICAgICB2YXIgcGQgPSBuZXcgcGVyc2lhbkRhdGUodW5peERhdGUpO1xuICAgKiAgICAgICAgICBwZC5mb3JtYXRQZXJzaWFuID0gdGhpcy5wZXJzaWFuRGlnaXQ7XG4gICAqICAgICAgICAgIHJldHVybiBwZC5mb3JtYXQoc2VsZi5hbHRGb3JtYXQpO1xuICAgKiAgICAgIH1cbiAgICogIH1cbiAgICovXG4gICdhbHRGaWVsZEZvcm1hdHRlcic6IGZ1bmN0aW9uIGFsdEZpZWxkRm9ybWF0dGVyKHVuaXhEYXRlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICB0aGlzQWx0Rm9ybWF0ID0gc2VsZi5hbHRGb3JtYXQudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgcGQgPSB2b2lkIDA7XG4gICAgaWYgKHRoaXNBbHRGb3JtYXQgPT09ICdncmVnb3JpYW4nIHx8IHRoaXNBbHRGb3JtYXQgPT09ICdnJykge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKHVuaXhEYXRlKTtcbiAgICB9XG4gICAgaWYgKHRoaXNBbHRGb3JtYXQgPT09ICd1bml4JyB8fCB0aGlzQWx0Rm9ybWF0ID09PSAndScpIHtcbiAgICAgIHJldHVybiB1bml4RGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGQgPSB0aGlzLm1vZGVsLlBlcnNpYW5EYXRlLmRhdGUodW5peERhdGUpO1xuICAgICAgcmV0dXJuIHBkLmZvcm1hdChzZWxmLmFsdEZvcm1hdCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gU2V0IG1pbiBkYXRlIG9uIGRhdGVwaWNrZXIsIHByZXZlbnQgdXNlciBzZWxlY3QgZGF0ZSBiZWZvcmUgZ2l2ZW4gdW5peCB0aW1lXG4gICAqIEBwcm9wZXJ0eSBtaW5EYXRlXG4gICAqIEB0eXBlIERhdGVcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKi9cbiAgJ21pbkRhdGUnOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gU2V0IG1heCBkYXRlIG9uIGRhdGVwaWNrZXIsIHByZXZlbnQgdXNlciBzZWxlY3QgZGF0ZSBhZnRlciBnaXZlbiB1bml4IHRpbWVcbiAgICogQHByb3BlcnR5IG1heERhdGVcbiAgICogQHR5cGUgRGF0ZVxuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqL1xuICAnbWF4RGF0ZSc6IG51bGwsXG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBuYXZpZ2F0b3IgY29uZmlnIG9iamVjdFxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICAnbmF2aWdhdG9yJzoge1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBtYWtlIG5hdmlnYXRvciBlbmFibGUgb3IgZGlzYWJsZVxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgJ2VuYWJsZWQnOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIG5hdmlnYXRlIGJ5IHNjcm9sbCBjb25maWd1cmF0aW9uXG4gICAgICogQHR5cGUgb2JqZWN0XG4gICAgICogQGRlc2NyaXB0aW9uIHNjcm9sbCBuYXZpZ2F0aW9uIG9wdGlvbnNcbiAgICAgKi9cbiAgICAnc2Nyb2xsJzoge1xuXG4gICAgICAvKipcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBpZiB5b3Ugd2FudCBtYWtlIGRpc2FibGUgc2Nyb2xsIG5hdmlnYXRpb24gc2V0IHRoaXMgb3B0aW9uIGZhbHNlXG4gICAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgKi9cbiAgICAgICdlbmFibGVkJzogdHJ1ZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gbmF2aWdhdG9yIHRleHQgY29uZmlnIG9iamVjdFxuICAgICAqL1xuICAgICd0ZXh0Jzoge1xuICAgICAgLyoqXG4gICAgICAgKiBAZGVzY3JpcHRpb24gdGV4dCBvZiBuZXh0IGJ1dHRvblxuICAgICAgICogQGRlZmF1bHQgJzwnXG4gICAgICAgKi9cbiAgICAgICdidG5OZXh0VGV4dCc6ICc8JyxcblxuICAgICAgLyoqXG4gICAgICAgKiBAZGVzY3JpcHRpb24gdGV4dCBvZiBwcmV2IGJ1dHRvblxuICAgICAgICogQGRlZmF1bHQ6ICc+J1xuICAgICAgICovXG4gICAgICAnYnRuUHJldlRleHQnOiAnPidcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIENhbGxlZCB3aGVuIG5hdmlnYXRvciBnb2VzIHRvIG5leHQgc3RhdGVcbiAgICAgKiBAZXZlbnRcbiAgICAgKiBAZXhhbXBsZSBmdW5jdGlvbiAobmF2aWdhdG9yKSB7XG4gICAgICogICAgICAvL2xvZygnbmF2aWdhdG9yIG5leHQgJyk7XG4gICAgICogIH1cbiAgICAgKi9cbiAgICAnb25OZXh0JzogZnVuY3Rpb24gb25OZXh0KGRhdGVwaWNrZXJPYmplY3QpIHtcbiAgICAgIEhlbHBlci5kZWJ1ZyhkYXRlcGlja2VyT2JqZWN0LCAnRXZlbnQ6IG9uTmV4dCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FsbGVkIHdoZW4gbmF2aWdhdG9yIGdvZXMgdG8gcHJldmlld3Mgc3RhdGVcbiAgICAgKiBAZXZlbnRcbiAgICAgKiBAZXhhbXBsZSBmdW5jdGlvbiAobmF2aWdhdG9yKSB7XG4gICAgICogICAgICAvL2xvZygnbmF2aWdhdG9yIHByZXYgJyk7XG4gICAgICogIH1cbiAgICAgKi9cbiAgICAnb25QcmV2JzogZnVuY3Rpb24gb25QcmV2KGRhdGVwaWNrZXJPYmplY3QpIHtcbiAgICAgIEhlbHBlci5kZWJ1ZyhkYXRlcGlja2VyT2JqZWN0LCAnRXZlbnQ6IG9uUHJldicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FsbGVkIHdoZW4gbmF2aWdhdG9yIHN3aXRjaFxuICAgICAqIEBldmVudFxuICAgICAqIEBleGFtcGxlIGZ1bmN0aW9uIChkYXRlcGlja2VyT2JqZWN0KSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnbmF2aWdhdG9yIHN3aXRjaCAnKTtcbiAgICAgKiAgfVxuICAgICAqL1xuICAgICdvblN3aXRjaCc6IGZ1bmN0aW9uIG9uU3dpdGNoKGRhdGVwaWNrZXJPYmplY3QpIHtcbiAgICAgIEhlbHBlci5kZWJ1ZyhkYXRlcGlja2VyT2JqZWN0LCAnZGF5UGlja2VyIEV2ZW50OiBvblN3aXRjaCcpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIHRvb2xib3ggY29uZmlnIG9iamVjdFxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICAndG9vbGJveCc6IHtcblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBib29sZWFuIG9wdGlvbiB0aGF0IG1ha2UgdG9vbGJhciBlbmFibGUgb3IgZGlzYWJsZVxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgJ2VuYWJsZWQnOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIHRvb2xib3ggYnV0dG9uIHRleHQgY29uZmlndXJhdGlvblxuICAgICAqIEB0eXBlIG9iamVjdFxuICAgICAqIEBkZXByZWNhdGVkIGZyb20gMS4wLjBcbiAgICAgKi9cbiAgICAndGV4dCc6IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBAZGVzY3JpcHRpb24gdGV4dCBvZiB0b2RheSBidXR0b24sIGRlcHJlY2F0ZWQgZnJvbSAxLjAuMFxuICAgICAgICogQHR5cGUgc3RyaW5nXG4gICAgICAgKiBAZGVmYXVsdCAn2KfZhdix2YjYsidcbiAgICAgICAqIEBkZXByZWNhdGVkIGZyb20gMS4wLjBcbiAgICAgICAqL1xuICAgICAgYnRuVG9kYXk6ICfYp9mF2LHZiNiyJ1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBzdWJtaXQgYnV0dG9uIGNvbmZpZ3VyYXRpb24gKG9ubHkgc2hvd24gb24gbW9iaWxlKVxuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqL1xuICAgIHN1Ym1pdEJ1dHRvbjoge1xuXG4gICAgICAvKipcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBtYWtlIHN1Ym1pdCBidXR0b24gZW5hYmxlIG9yIGRpc2FibGVcbiAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgICAqL1xuICAgICAgZW5hYmxlZDogSGVscGVyLmlzTW9iaWxlLFxuXG4gICAgICAvKipcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBzdWJtaXQgYnV0dG9uIHRleHRcbiAgICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAgICogQHR5cGUgb2JqZWN0XG4gICAgICAgKi9cbiAgICAgIHRleHQ6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIHNob3cgd2hlbiBjdXJyZW50IGNhbGVuZGFyIGlzIFBlcnNpYW5cbiAgICAgICAgICogQHNpbmNlIDEuMC4wXG4gICAgICAgICAqIEB0eXBlIG9iamVjdFxuICAgICAgICAgKiBAZGVmYXVsdCDYqtin24zbjNivXG4gICAgICAgICAqL1xuICAgICAgICBmYTogJ9iq2KfbjNuM2K8nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gc2hvdyB3aGVuIGN1cnJlbnQgY2FsZW5kYXIgaXMgR3JlZ29yaWFuXG4gICAgICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAgICAgKiBAdHlwZSBvYmplY3RcbiAgICAgICAgICogQGRlZmF1bHQgc3VibWl0XG4gICAgICAgICAqL1xuICAgICAgICBlbjogJ3N1Ym1pdCdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQGRlc2NyaXB0aW9uIENhbGxlZCB3aGVuIHN1Ym1pdCBidXR0b24gY2xpY2tlZFxuICAgICAgICogQHNpbmNlIDEuMC4wXG4gICAgICAgKiBAdHlwZSBmdW5jdGlvblxuICAgICAgICogQGV2ZW50XG4gICAgICAgKi9cbiAgICAgIG9uU3VibWl0OiBmdW5jdGlvbiBvblN1Ym1pdChkYXRlcGlja2VyT2JqZWN0KSB7XG4gICAgICAgIEhlbHBlci5kZWJ1ZyhkYXRlcGlja2VyT2JqZWN0LCAnZGF5UGlja2VyIEV2ZW50OiBvblN1Ym1pdCcpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gdG9vbGJveCB0b2RheSBidXR0b24gY29uZmlndXJhdGlvblxuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqL1xuICAgIHRvZGF5QnV0dG9uOiB7XG5cbiAgICAgIC8qKlxuICAgICAgICogQGRlc2NyaXB0aW9uIG1ha2UgdG9vbGJveCB0b2RheSBidXR0b24gZW5hYmxlIG9yIGRpc2FibGVcbiAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAgICovXG4gICAgICBlbmFibGVkOiB0cnVlLFxuXG4gICAgICAvKipcbiAgICAgICAqIEBkZXNjcmlwdGlvbiB0b2RheSBidXR0b24gdGV4dFxuICAgICAgICogQHNpbmNlIDEuMC4wXG4gICAgICAgKiBAdHlwZSBvYmplY3RcbiAgICAgICAqL1xuICAgICAgdGV4dDoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gc2hvdyB3aGVuIGN1cnJlbnQgY2FsZW5kYXIgaXMgUGVyc2lhblxuICAgICAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgICAgICogQHR5cGUgb2JqZWN0XG4gICAgICAgICAqIEBkZWZhdWx0INin2YXYsdmI2LJcbiAgICAgICAgICovXG4gICAgICAgIGZhOiAn2KfZhdix2YjYsicsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBzaG93IHdoZW4gY3VycmVudCBjYWxlbmRhciBpcyBHcmVnb3JpYW5cbiAgICAgICAgICogQHNpbmNlIDEuMC4wXG4gICAgICAgICAqIEB0eXBlIG9iamVjdFxuICAgICAgICAgKiBAZGVmYXVsdCB0b2RheVxuICAgICAgICAgKi9cbiAgICAgICAgZW46ICd0b2RheSdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQGRlc2NyaXB0aW9uIENhbGxlZCB3aGVuIHRvZGF5IGJ1dHRvbiBjbGlja2VkXG4gICAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgICAqIEB0eXBlIGZ1bmN0aW9uXG4gICAgICAgKiBAZXZlbnRcbiAgICAgICAqL1xuICAgICAgb25Ub2RheTogZnVuY3Rpb24gb25Ub2RheShkYXRlcGlja2VyT2JqZWN0KSB7XG4gICAgICAgIEhlbHBlci5kZWJ1ZyhkYXRlcGlja2VyT2JqZWN0LCAnZGF5UGlja2VyIEV2ZW50OiBvblRvZGF5Jyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiB0b29sYm94IGNhbGVuZGFyIHN3aXRjaCBjb25maWd1cmF0aW9uXG4gICAgICogQHR5cGUgb2JqZWN0XG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICovXG4gICAgY2FsZW5kYXJTd2l0Y2g6IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBAZGVzY3JpcHRpb24gbWFrZSBjYWxlbmRhciBzd2l0Y2ggZW5hYmxlIG9yIGRpc2FibGVcbiAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICovXG4gICAgICBlbmFibGVkOiB0cnVlLFxuXG4gICAgICAvKipcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBjYWxlbmRhciBzd2l0Y2ggdGV4dCBmb3JtYXQgc3RyaW5nXG4gICAgICAgKiBAbGluayBodHRwOi8vYmFiYWtoYW5pLmdpdGh1Yi5pby9QZXJzaWFuV2ViVG9vbGtpdC9kb2MvcGVyc2lhbi1kYXRlLyNmb3JtYXRcbiAgICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAgICogQHNpbmNlIDEuMC4wXG4gICAgICAgKiBAZGVmYXVsdCBNTU1NXG4gICAgICAgKi9cbiAgICAgIGZvcm1hdDogJ01NTU0nLFxuXG4gICAgICAvKipcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBDYWxsZWQgd2hlbiBjYWxlbmRhciBzd2l0Y2ggY2xpY2tlZFxuICAgICAgICogQHNpbmNlIDEuMC4wXG4gICAgICAgKiBAdHlwZSBmdW5jdGlvblxuICAgICAgICogQGV2ZW50XG4gICAgICAgKi9cbiAgICAgIG9uU3dpdGNoOiBmdW5jdGlvbiBvblN3aXRjaChkYXRlcGlja2VyT2JqZWN0KSB7XG4gICAgICAgIEhlbHBlci5kZWJ1ZyhkYXRlcGlja2VyT2JqZWN0LCAnZGF5UGlja2VyIEV2ZW50OiBvblN3aXRjaCcpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnRcbiAgICAgKiBAcGFyYW0gdG9vbGJveFxuICAgICAqIEBleGFtcGxlIGZ1bmN0aW9uICh0b29sYm94KSB7XG4gICAgICogICAgICAvL2xvZygndG9vbGJveCB0b2RheSBidG4nKTtcbiAgICAgKiAgfVxuICAgICAqICBAZGVwcmVjYXRlZCAxLjAuMFxuICAgICAqL1xuICAgIG9uVG9kYXk6IGZ1bmN0aW9uIG9uVG9kYXkoZGF0ZXBpY2tlck9iamVjdCkge1xuICAgICAgSGVscGVyLmRlYnVnKGRhdGVwaWNrZXJPYmplY3QsICdkYXlQaWNrZXIgRXZlbnQ6IG9uVG9kYXknKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBpZiB0cnVlIGFsbCBwaWNrZXJzIGhpZGUgYW5kIGp1c3Qgc2hvdyB0aW1lcGlja2VyXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqIEB0eXBlIGJvb2xlYW5cbiAgICovXG4gICdvbmx5VGltZVBpY2tlcic6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gIGlmIHRydWUgZGF0ZSBzZWxlY3QganVzdCBieSBjbGljayBvbiBkYXkgaW4gbW9udGggZ3JpZCwgYW5kIHdoZW4gdXNlciBzZWxlY3QgbW9udGggb3IgeWVhciBzZWxlY3RlZCBkYXRlIGRvZXNudCBjaGFuZ2VcbiAgICogQHByb3BlcnR5IGp1c3RTZWxlY3RPbkRhdGVcbiAgICogQHR5cGUgYm9vbGVhblxuICAgKiBAZGVmYXVsdDogdHJ1ZVxuICAgKi9cbiAgJ29ubHlTZWxlY3RPbkRhdGUnOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gVmFsaWRhdGUgZGF0ZSBhY2Nlc3MgYmVmb3JlIHJlbmRlclxuICAgKiBAdHlwZSBmdW5jdGlvblxuICAgKi9cbiAgJ2NoZWNrRGF0ZSc6IGZ1bmN0aW9uIGNoZWNrRGF0ZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIFZhbGlkYXRlIG1vbnRoIGFjY2VzcyBiZWZvcmUgcmVuZGVyXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICovXG4gICdjaGVja01vbnRoJzogZnVuY3Rpb24gY2hlY2tNb250aCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIFZhbGlkYXRlIHllYXIgYWNjZXNzIGJlZm9yZSByZW5kZXJcbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKi9cbiAgJ2NoZWNrWWVhcic6IGZ1bmN0aW9uIGNoZWNrWWVhcigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIHRpbWVQaWNrZXIgY29uZmlndXJhdGlvblxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKi9cbiAgJ3RpbWVQaWNrZXInOiB7XG5cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gbWFrZSB0aW1lUGlja2VyIGVuYWJsZSBvciBkaXNhYmxlXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqL1xuICAgICdlbmFibGVkJzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gVGhlIGFtb3VudCB0aGF0IGluY3JlYXNlcyBvciBkZWNyZWFzZXMgYnkgcHJlc3NpbmcgdGhlIGJ1dHRvblxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqL1xuICAgICdzdGVwJzogMSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBob3VyIHNlbGVjdG9yIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAdHlwZSBvYmplY3RcbiAgICAgKi9cbiAgICAnaG91cic6IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBAZGVzY3JpcHRpb24gbWFrZSBob3VyIHNlbGVjdG9yIGVuYWJsZSBvciBkaXNhYmxlXG4gICAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICAgKi9cbiAgICAgICdlbmFibGVkJzogdHJ1ZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAZGVzY3JpcHRpb24gVGhlIGFtb3VudCB0aGF0IGluY3JlYXNlcyBvciBkZWNyZWFzZXMgaG91ciwgYnkgcHJlc3NpbmcgdGhlIGJ1dHRvbi4gb3ZlcndyaXRlIGJ5IHRpbWVwaWNrZXIuc3RlcFxuICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICovXG4gICAgICAnc3RlcCc6IG51bGxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIG1pbnV0ZSBzZWxlY3RvciBjb25maWd1cmF0aW9uXG4gICAgICogQHR5cGUgb2JqZWN0XG4gICAgICovXG4gICAgJ21pbnV0ZSc6IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBAZGVzY3JpcHRpb24gbWFrZSBtaW51dGUgc2VsZWN0b3IgZW5hYmxlIG9yIGRpc2FibGVcbiAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAqL1xuICAgICAgJ2VuYWJsZWQnOiB0cnVlLFxuXG4gICAgICAvKipcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgYW1vdW50IHRoYXQgaW5jcmVhc2VzIG9yIGRlY3JlYXNlcyBtaW51dGUsIGJ5IHByZXNzaW5nIHRoZSBidXR0b24uIG92ZXJ3cml0ZSBieSB0aW1lcGlja2VyLnN0ZXBcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBvdmVyd3JpdGUgYnkgcGFyZW50IHN0ZXBcbiAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAqL1xuICAgICAgJ3N0ZXAnOiBudWxsXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBzZWNvbmQgc2VsZWN0b3IgY29uZmlndXJhdGlvblxuICAgICAqIEB0eXBlIG9iamVjdFxuICAgICAqL1xuICAgICdzZWNvbmQnOiB7XG5cbiAgICAgIC8qKlxuICAgICAgICogQGRlc2NyaXB0aW9uIG1ha2Ugc2Vjb25kIHNlbGVjdG9yIGVuYWJsZSBvciBkaXNhYmxlXG4gICAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICAgKi9cbiAgICAgICdlbmFibGVkJzogdHJ1ZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAZGVzY3JpcHRpb24gVGhlIGFtb3VudCB0aGF0IGluY3JlYXNlcyBvciBkZWNyZWFzZXMgc2Vjb25kLCBieSBwcmVzc2luZyB0aGUgYnV0dG9uLiBvdmVyd3JpdGUgYnkgdGltZXBpY2tlci5zdGVwXG4gICAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICAgKi9cbiAgICAgICdzdGVwJzogbnVsbFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gbWVyaWRpYW4gc2VsZWN0b3IgY29uZmlndXJhdGlvblxuICAgICAqIEB0eXBlIG9iamVjdFxuICAgICAqL1xuICAgICdtZXJpZGlhbic6IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBAZGVzY3JpcHRpb24gaWYgeW91IHNldCB0aGlzIGFzIGZhbHNlLCBkYXRlcGlja2VyIHRpbWVwaWNrZXIgc3lzdGVtIG1vdmVkIHRvIDI0LWhvdXIgc3lzdGVtXG4gICAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICAgKi9cbiAgICAgICdlbmFibGVkJzogZmFsc2VcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBkYXlQaWNrZXIgY29uZmlndXJhdGlvblxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKi9cbiAgJ2RheVBpY2tlcic6IHtcblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBtYWtlIGRheXBpY2tlciBlbmFibGUgb3IgZGlzYWJsZVxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgJ2VuYWJsZWQnOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIGRheXBpY2tlciB0aXRsZSBmb3JtYXQgc3RyaW5nXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICogQGRlZmF1bHQgJ1lZWVkgTU1NTSdcbiAgICAgKiBAbGluayBodHRwOi8vYmFiYWtoYW5pLmdpdGh1Yi5pby9QZXJzaWFuV2ViVG9vbGtpdC9kb2MvcGVyc2lhbi1kYXRlLyNmb3JtYXRcbiAgICAgKi9cbiAgICAndGl0bGVGb3JtYXQnOiAnWVlZWSBNTU1NJyxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBkYXlwaWNrZXIgdGl0bGUgZm9ybWF0dGVyIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHllYXJcbiAgICAgKiBAcGFyYW0gbW9udGhcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqL1xuICAgICd0aXRsZUZvcm1hdHRlcic6IGZ1bmN0aW9uIHRpdGxlRm9ybWF0dGVyKHllYXIsIG1vbnRoKSB7XG4gICAgICB2YXIgdGl0bGVEYXRlID0gdGhpcy5tb2RlbC5QZXJzaWFuRGF0ZS5kYXRlKFt5ZWFyLCBtb250aF0pO1xuICAgICAgcmV0dXJuIHRpdGxlRGF0ZS5mb3JtYXQodGhpcy5tb2RlbC5vcHRpb25zLmRheVBpY2tlci50aXRsZUZvcm1hdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBmaXJlZCB3aGVuIHVzZXIgc2VsZWN0IGRhdGVcbiAgICAgKiBAZXZlbnRcbiAgICAgKiBAcGFyYW0gc2VsZWN0ZWREYXlVbml4XG4gICAgICovXG4gICAgJ29uU2VsZWN0JzogZnVuY3Rpb24gb25TZWxlY3Qoc2VsZWN0ZWREYXlVbml4KSB7XG4gICAgICBIZWxwZXIuZGVidWcodGhpcywgJ2RheVBpY2tlciBFdmVudDogb25TZWxlY3QgOiAnICsgc2VsZWN0ZWREYXlVbml4KTtcbiAgICB9XG5cbiAgfSxcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIG1vbnRoUGlja2VyIGNvbmZpZ3VyYXRpb25cbiAgICogQHR5cGUge29iamVjdH1cbiAgICovXG4gICdtb250aFBpY2tlcic6IHtcblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBtYWtlIG1vbnRoUGlja2VyIGVuYWJsZSBvciBkaXNhYmxlXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICAnZW5hYmxlZCc6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gbW9udGhQaWNrZXIgdGl0bGUgZm9ybWF0IHN0cmluZ1xuICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAqIEBkZWZhdWx0ICdZWVlZJ1xuICAgICAqL1xuICAgICd0aXRsZUZvcm1hdCc6ICdZWVlZJyxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBtb250aFBpY2tlciB0aXRsZSBmb3JtYXR0ZXIgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gdW5peFxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICovXG4gICAgJ3RpdGxlRm9ybWF0dGVyJzogZnVuY3Rpb24gdGl0bGVGb3JtYXR0ZXIodW5peCkge1xuICAgICAgdmFyIHRpdGxlRGF0ZSA9IHRoaXMubW9kZWwuUGVyc2lhbkRhdGUuZGF0ZSh1bml4KTtcbiAgICAgIHJldHVybiB0aXRsZURhdGUuZm9ybWF0KHRoaXMubW9kZWwub3B0aW9ucy5tb250aFBpY2tlci50aXRsZUZvcm1hdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBmaXJlZCB3aGVuIHVzZXIgc2VsZWN0IG1vbnRoXG4gICAgICogQGV2ZW50XG4gICAgICogQHBhcmFtIG1vbnRoSW5kZXhcbiAgICAgKi9cbiAgICAnb25TZWxlY3QnOiBmdW5jdGlvbiBvblNlbGVjdChtb250aEluZGV4KSB7XG4gICAgICBIZWxwZXIuZGVidWcodGhpcywgJ21vbnRoUGlja2VyIEV2ZW50OiBvblNlbGVjdCA6ICcgKyBtb250aEluZGV4KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiB5ZWFyUGlja2VyIGNvbmZpZ3VyYXRpb25cbiAgICogQHR5cGUge29iamVjdH1cbiAgICovXG4gICd5ZWFyUGlja2VyJzoge1xuXG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIG1ha2UgeWVhclBpY2tlciBlbmFibGUgb3IgZGlzYWJsZVxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgJ2VuYWJsZWQnOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIHllYXJQaWNrZXIgdGl0bGUgZm9ybWF0IHN0cmluZ1xuICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAqIEBkZWZhdWx0ICdZWVlZJ1xuICAgICAqL1xuICAgICd0aXRsZUZvcm1hdCc6ICdZWVlZJyxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiB5ZWFyUGlja2VyIHRpdGxlIGZvcm1hdHRlciBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB5ZWFyXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgICd0aXRsZUZvcm1hdHRlcic6IGZ1bmN0aW9uIHRpdGxlRm9ybWF0dGVyKHllYXIpIHtcbiAgICAgIHZhciByZW1haW5pbmcgPSBwYXJzZUludCh5ZWFyIC8gMTIsIDEwKSAqIDEyO1xuICAgICAgdmFyIHN0YXJ0WWVhciA9IHRoaXMubW9kZWwuUGVyc2lhbkRhdGUuZGF0ZShbcmVtYWluaW5nXSk7XG4gICAgICB2YXIgZW5kWWVhciA9IHRoaXMubW9kZWwuUGVyc2lhbkRhdGUuZGF0ZShbcmVtYWluaW5nICsgMTFdKTtcbiAgICAgIHJldHVybiBzdGFydFllYXIuZm9ybWF0KHRoaXMubW9kZWwub3B0aW9ucy55ZWFyUGlja2VyLnRpdGxlRm9ybWF0KSArICctJyArIGVuZFllYXIuZm9ybWF0KHRoaXMubW9kZWwub3B0aW9ucy55ZWFyUGlja2VyLnRpdGxlRm9ybWF0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIGZpcmVkIHdoZW4gdXNlciBzZWxlY3QgeWVhclxuICAgICAqIEBldmVudFxuICAgICAqIEBwYXJhbSB5ZWFyXG4gICAgICovXG4gICAgJ29uU2VsZWN0JzogZnVuY3Rpb24gb25TZWxlY3QoeWVhcikge1xuICAgICAgSGVscGVyLmRlYnVnKHRoaXMsICd5ZWFyUGlja2VyIEV2ZW50OiBvblNlbGVjdCA6ICcgKyB5ZWFyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBDYWxsZWQgd2hlbiBkYXRlIFNlbGVjdCBieSB1c2VyLlxuICAgKiBAZXZlbnRcbiAgICogQHBhcmFtIHVuaXhEYXRlXG4gICAqL1xuICAnb25TZWxlY3QnOiBmdW5jdGlvbiBvblNlbGVjdCh1bml4RGF0ZSkge1xuICAgIEhlbHBlci5kZWJ1Zyh0aGlzLCAnZGF0ZXBpY2tlciBFdmVudDogb25TZWxlY3QgOiAnICsgdW5peERhdGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gQ2FsbGVkIHdoZW4gZGF0ZSBTZWxlY3QgYnkgYXBpLlxuICAgKiBAZXZlbnRcbiAgICogQHBhcmFtIHVuaXhEYXRlXG4gICAqL1xuICAnb25TZXQnOiBmdW5jdGlvbiBvblNldCh1bml4RGF0ZSkge1xuICAgIEhlbHBlci5kZWJ1Zyh0aGlzLCAnZGF0ZXBpY2tlciBFdmVudDogb25TZXQgOiAnICsgdW5peERhdGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gcG9zaXRpb24gb2YgZGF0ZXBpY2tlciByZWxhdGl2ZSB0byBpbnB1dCBlbGVtZW50XG4gICAqIEB0eXBlIHN0cmluZyB8IGFycmF5XG4gICAqIEBkZWZhdWx0ICdhdXRvJ1xuICAgKiBAZXhhbXBsZVxuICAgKiAgJ3Bvc2l0aW9uJzogJ2F1dG8nXG4gICAqJ3Bvc2l0aW9uJzogWzEwLDEwXVxuICAgKi9cbiAgJ3Bvc2l0aW9uJzogJ2F1dG8nLFxuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gQSBmdW5jdGlvbiB0aGF0IHRha2VzIGN1cnJlbnQgZGF0ZXBpY2tlciBpbnN0YW5jZS4gSXQgaXMgY2FsbGVkIGp1c3QgYmVmb3JlIHRoZSBkYXRlcGlja2VyIGlzIGRpc3BsYXllZC5cbiAgICogQGV2ZW50XG4gICAqL1xuICAnb25TaG93JzogZnVuY3Rpb24gb25TaG93KGRhdGVwaWNrZXJPYmplY3QpIHtcbiAgICBIZWxwZXIuZGVidWcoZGF0ZXBpY2tlck9iamVjdCwgJ0V2ZW50OiBvblNob3cgJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgY3VycmVudCBkYXRlcGlja2VyIGluc3RhbmNlLiBJdCBpcyBjYWxsZWQganVzdCBiZWZvcmUgdGhlIGRhdGVwaWNrZXIgSGlkZS5cbiAgICogQGV2ZW50XG4gICAqL1xuICAnb25IaWRlJzogZnVuY3Rpb24gb25IaWRlKGRhdGVwaWNrZXJPYmplY3QpIHtcbiAgICBIZWxwZXIuZGVidWcoZGF0ZXBpY2tlck9iamVjdCwgJ0V2ZW50OiBvbkhpZGUgJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBvbiB0b2dnbGUgZGF0ZXBpY2tlciBldmVudFxuICAgKiBAZXZlbnRcbiAgICovXG4gICdvblRvZ2dsZSc6IGZ1bmN0aW9uIG9uVG9nZ2xlKGRhdGVwaWNrZXJPYmplY3QpIHtcbiAgICBIZWxwZXIuZGVidWcoZGF0ZXBpY2tlck9iamVjdCwgJ0V2ZW50OiBvblRvZ2dsZSAnKTtcbiAgfSxcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIG9uIGRlc3Ryb3kgZGF0ZXBpY2tlciBldmVudFxuICAgKiBAZXZlbnRcbiAgICovXG4gICdvbkRlc3Ryb3knOiBmdW5jdGlvbiBvbkRlc3Ryb3koZGF0ZXBpY2tlck9iamVjdCkge1xuICAgIEhlbHBlci5kZWJ1ZyhkYXRlcGlja2VyT2JqZWN0LCAnRXZlbnQ6IG9uRGVzdHJveSAnKTtcbiAgfSxcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIElmIHRydWUgZGF0ZXBpY2tlciBjbG9zZSBXaGVuIHNlbGVjdCBhIGRhdGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICAnYXV0b0Nsb3NlJzogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBieSBkZWZhdWx0IGRhdGVwaWNrZXIgaGF2ZSBhIHRlbXBsYXRlIHN0cmluZywgYW5kIHlvdSBjYW4gb3ZlcndyaXRlIGl0IHNpbXBseSBieSByZXBsYWNlIHN0cmluZyBpbiBjb25maWcuXG4gICAqIEB0eXBlIHN0cmluZ1xuICAgKiBAZXhhbXBsZVxuICAgKiA8ZGl2IGlkPVwicGxvdElkXCIgY2xhc3M9XCJkYXRlcGlja2VyLXBsb3QtYXJlYSBkYXRlcGlja2VyLXBsb3QtYXJlYS1pbmxpbmUtdmlld1wiPlxuICAge3sjbmF2aWdhdG9yLmVuYWJsZWR9fVxuICAgPGRpdiBjbGFzcz1cIm5hdmlnYXRvclwiPlxuICAgPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItaGVhZGVyXCI+XG4gICA8ZGl2IGNsYXNzPVwiYnRuIGJ0bi1uZXh0XCI+e3tuYXZpZ2F0b3IudGV4dC5idG5OZXh0VGV4dH19PC9kaXY+XG4gICA8ZGl2IGNsYXNzPVwiYnRuIGJ0bi1zd2l0Y2hcIj57eyBuYXZpZ2F0b3Iuc3dpdGNoLnRleHQgfX08L2Rpdj5cbiAgIDxkaXYgY2xhc3M9XCJidG4gYnRuLXByZXZcIj57e25hdmlnYXRvci50ZXh0LmJ0blByZXZUZXh0fX08L2Rpdj5cbiAgIDwvZGl2PlxuICAgPC9kaXY+XG4gICB7ey9uYXZpZ2F0b3IuZW5hYmxlZH19XG4gICA8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci1ncmlkLXZpZXdcIiA+XG4gICB7eyNkYXlzLmVuYWJsZWR9fVxuICAge3sjZGF5cy52aWV3TW9kZX19XG4gICA8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci1kYXktdmlld1wiID5cbiAgIDxkaXYgY2xhc3M9XCJtb250aC1ncmlkLWJveFwiPlxuICAgPGRpdiBjbGFzcz1cImhlYWRlclwiPlxuICAgPGRpdiBjbGFzcz1cInRpdGxlXCI+PC9kaXY+XG4gICA8ZGl2IGNsYXNzPVwiaGVhZGVyLXJvd1wiPlxuICAgPGRpdiBjbGFzcz1cImhlYWRlci1yb3ctY2VsbFwiPti0PC9kaXY+XG4gICA8ZGl2IGNsYXNzPVwiaGVhZGVyLXJvdy1jZWxsXCI+24w8L2Rpdj5cbiAgIDxkaXYgY2xhc3M9XCJoZWFkZXItcm93LWNlbGxcIj7YrzwvZGl2PlxuICAgPGRpdiBjbGFzcz1cImhlYWRlci1yb3ctY2VsbFwiPtizPC9kaXY+XG4gICA8ZGl2IGNsYXNzPVwiaGVhZGVyLXJvdy1jZWxsXCI+2oY8L2Rpdj5cbiAgIDxkaXYgY2xhc3M9XCJoZWFkZXItcm93LWNlbGxcIj7ZvjwvZGl2PlxuICAgPGRpdiBjbGFzcz1cImhlYWRlci1yb3ctY2VsbFwiPtisPC9kaXY+XG4gICA8L2Rpdj5cbiAgIDwvZGl2PlxuICAgPHRhYmxlIGNlbGxzcGFjaW5nPVwiMFwiIGNsYXNzPVwidGFibGUtZGF5c1wiPlxuICAgPHRib2R5PlxuICAge3sjZGF5cy5saXN0fX1cbiAgICA8dHI+XG4gICB7eyMufX1cbiAgICB7eyNlbmFibGVkfX1cbiAgIDx0ZCBkYXRhLXVuaXg9XCJ7e2RhdGFVbml4fX1cIiA+PHNwYW4gIGNsYXNzPVwie3sjb3RoZXJNb250aH19b3RoZXItbW9udGh7ey9vdGhlck1vbnRofX0ge3sjc2VsZWN0ZWR9fXNlbGVjdGVke3svc2VsZWN0ZWR9fVwiPnt7dGl0bGV9fTwvc3Bhbj48L3RkPlxuICAge3svZW5hYmxlZH19XG4gICB7e15lbmFibGVkfX1cbiAgIDx0ZCBkYXRhLXVuaXg9XCJ7e2RhdGFVbml4fX1cIiBjbGFzcz1cImRpc2FibGVkXCI+PHNwYW4gY2xhc3M9XCJ7eyNvdGhlck1vbnRofX1vdGhlci1tb250aHt7L290aGVyTW9udGh9fVwiPnt7dGl0bGV9fTwvc3Bhbj48L3RkPlxuICAge3svZW5hYmxlZH19XG4gICAge3svLn19XG4gICA8L3RyPlxuICAge3svZGF5cy5saXN0fX1cbiAgIDwvdGJvZHk+XG4gICA8L3RhYmxlPlxuICAgPC9kaXY+XG4gICA8L2Rpdj5cbiAgIHt7L2RheXMudmlld01vZGV9fVxuICAge3svZGF5cy5lbmFibGVkfX1cbiAgICB7eyNtb250aC5lbmFibGVkfX1cbiAgIHt7I21vbnRoLnZpZXdNb2RlfX1cbiAgIDxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLW1vbnRoLXZpZXdcIj5cbiAgIHt7I21vbnRoLmxpc3R9fVxuICAge3sjZW5hYmxlZH19XG4gICA8ZGl2IGRhdGEtbW9udGg9XCJ7e2RhdGFNb250aH19XCIgY2xhc3M9XCJtb250aC1pdGVtIHt7I3NlbGVjdGVkfX1zZWxlY3RlZHt7L3NlbGVjdGVkfX1cIj57e3RpdGxlfX08L3NtYWxsPjwvZGl2PlxuICAge3svZW5hYmxlZH19XG4gICB7e15lbmFibGVkfX1cbiAgIDxkaXYgZGF0YS1tb250aD1cInt7ZGF0YU1vbnRofX1cIiBjbGFzcz1cIm1vbnRoLWl0ZW0gbW9udGgtaXRlbS1kaXNhYmxlIHt7I3NlbGVjdGVkfX1zZWxlY3RlZHt7L3NlbGVjdGVkfX1cIj57e3RpdGxlfX08L3NtYWxsPjwvZGl2PlxuICAge3svZW5hYmxlZH19XG4gICB7ey9tb250aC5saXN0fX1cbiAgIDwvZGl2PlxuICAge3svbW9udGgudmlld01vZGV9fVxuICAge3svbW9udGguZW5hYmxlZH19XG4gICAge3sjeWVhci5lbmFibGVkIH19XG4gICB7eyN5ZWFyLnZpZXdNb2RlIH19XG4gICA8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci15ZWFyLXZpZXdcIiA+XG4gICB7eyN5ZWFyLmxpc3R9fVxuICAge3sjZW5hYmxlZH19XG4gICA8ZGl2IGRhdGEteWVhcj1cInt7ZGF0YVllYXJ9fVwiIGNsYXNzPVwieWVhci1pdGVtIHt7I3NlbGVjdGVkfX1zZWxlY3RlZHt7L3NlbGVjdGVkfX1cIj57e3RpdGxlfX08L2Rpdj5cbiAgIHt7L2VuYWJsZWR9fVxuICAge3teZW5hYmxlZH19XG4gICA8ZGl2IGRhdGEteWVhcj1cInt7ZGF0YVllYXJ9fVwiIGNsYXNzPVwieWVhci1pdGVtIHllYXItaXRlbS1kaXNhYmxlIHt7I3NlbGVjdGVkfX1zZWxlY3RlZHt7L3NlbGVjdGVkfX1cIj57e3RpdGxlfX08L2Rpdj5cbiAgIHt7L2VuYWJsZWR9fVxuICAge3sveWVhci5saXN0fX1cbiAgIDwvZGl2PlxuICAge3sveWVhci52aWV3TW9kZSB9fVxuICAge3sveWVhci5lbmFibGVkIH19XG4gICAgPC9kaXY+XG4gICB7eyN0aW1lfX1cbiAgIHt7I2VuYWJsZWR9fVxuICAgPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItdGltZS12aWV3XCI+XG4gICB7eyNob3VyLmVuYWJsZWR9fVxuICAgPGRpdiBjbGFzcz1cImhvdXIgdGltZS1zZWdtZW50XCIgZGF0YS10aW1lLWtleT1cImhvdXJcIj5cbiAgIDxkaXYgY2xhc3M9XCJ1cC1idG5cIiBkYXRhLXRpbWUta2V5PVwiaG91clwiPuKWsjwvZGl2PlxuICAgPGlucHV0IHZhbHVlPVwie3tob3VyLnRpdGxlfX1cIiB0eXBlPVwidGV4dFwiIHBsYWNlaG9sZGVyPVwiaG91clwiIGNsYXNzPVwiaG91ci1pbnB1dFwiPlxuICAgPGRpdiBjbGFzcz1cImRvd24tYnRuXCIgZGF0YS10aW1lLWtleT1cImhvdXJcIj7ilrw8L2Rpdj5cbiAgIDwvZGl2PlxuICAgPGRpdiBjbGFzcz1cImRpdmlkZXJcIj46PC9kaXY+XG4gICB7ey9ob3VyLmVuYWJsZWR9fVxuICAge3sjbWludXRlLmVuYWJsZWR9fVxuICAgPGRpdiBjbGFzcz1cIm1pbnV0ZSB0aW1lLXNlZ21lbnRcIiBkYXRhLXRpbWUta2V5PVwibWludXRlXCIgPlxuICAgPGRpdiBjbGFzcz1cInVwLWJ0blwiIGRhdGEtdGltZS1rZXk9XCJtaW51dGVcIj7ilrI8L2Rpdj5cbiAgIDxpbnB1dCB2YWx1ZT1cInt7bWludXRlLnRpdGxlfX1cIiB0eXBlPVwidGV4dFwiIHBsYWNlaG9sZGVyPVwibWludXRlXCIgY2xhc3M9XCJtaW51dGUtaW5wdXRcIj5cbiAgIDxkaXYgY2xhc3M9XCJkb3duLWJ0blwiIGRhdGEtdGltZS1rZXk9XCJtaW51dGVcIj7ilrw8L2Rpdj5cbiAgIDwvZGl2PlxuICAgPGRpdiBjbGFzcz1cImRpdmlkZXIgc2Vjb25kLWRpdmlkZXJcIj46PC9kaXY+XG4gICB7ey9taW51dGUuZW5hYmxlZH19XG4gICB7eyNzZWNvbmQuZW5hYmxlZH19XG4gICA8ZGl2IGNsYXNzPVwic2Vjb25kIHRpbWUtc2VnbWVudFwiIGRhdGEtdGltZS1rZXk9XCJzZWNvbmRcIiAgPlxuICAgPGRpdiBjbGFzcz1cInVwLWJ0blwiIGRhdGEtdGltZS1rZXk9XCJzZWNvbmRcIiA+4payPC9kaXY+XG4gICA8aW5wdXQgdmFsdWU9XCJ7e3NlY29uZC50aXRsZX19XCIgIHR5cGU9XCJ0ZXh0XCIgcGxhY2Vob2xkZXI9XCJzZWNvbmRcIiBjbGFzcz1cInNlY29uZC1pbnB1dFwiPlxuICAgPGRpdiBjbGFzcz1cImRvd24tYnRuXCIgZGF0YS10aW1lLWtleT1cInNlY29uZFwiID7ilrw8L2Rpdj5cbiAgIDwvZGl2PlxuICAgPGRpdiBjbGFzcz1cImRpdmlkZXIgbWVyaWRpYW4tZGl2aWRlclwiPjwvZGl2PlxuICAgPGRpdiBjbGFzcz1cImRpdmlkZXIgbWVyaWRpYW4tZGl2aWRlclwiPjwvZGl2PlxuICAge3svc2Vjb25kLmVuYWJsZWR9fVxuICAge3sjbWVyaWRpYW4uZW5hYmxlZH19XG4gICA8ZGl2IGNsYXNzPVwibWVyaWRpYW4gdGltZS1zZWdtZW50XCIgZGF0YS10aW1lLWtleT1cIm1lcmlkaWFuXCIgPlxuICAgPGRpdiBjbGFzcz1cInVwLWJ0blwiIGRhdGEtdGltZS1rZXk9XCJtZXJpZGlhblwiPuKWsjwvZGl2PlxuICAgPGlucHV0IHZhbHVlPVwie3ttZXJpZGlhbi50aXRsZX19XCIgdHlwZT1cInRleHRcIiBjbGFzcz1cIm1lcmlkaWFuLWlucHV0XCI+XG4gICA8ZGl2IGNsYXNzPVwiZG93bi1idG5cIiBkYXRhLXRpbWUta2V5PVwibWVyaWRpYW5cIj7ilrw8L2Rpdj5cbiAgIDwvZGl2PlxuICAge3svbWVyaWRpYW4uZW5hYmxlZH19XG4gICA8L2Rpdj5cbiAgIHt7L2VuYWJsZWR9fVxuICAge3svdGltZX19XG4gICAge3sjdG9vbGJveH19XG4gICB7eyNlbmFibGVkfX1cbiAgIDxkaXYgY2xhc3M9XCJ0b29sYm94IFwiPlxuICAgPGRpdiBjbGFzcz1cImJ0bi10b2RheVwiPnt7dGV4dC5idG5Ub2RheX19PC9kaXY+XG4gICA8L2Rpdj5cbiAgIHt7L2VuYWJsZWR9fVxuICAge3svdG9vbGJveH19XG4gICA8L2Rpdj5cbiAgICovXG4gICd0ZW1wbGF0ZSc6IG51bGwsXG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLy8vLy8vLy8vLyBVbmRlciBJbXBsZW1lbnQgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIGlmIHRydWUgZGF0ZXBpY2tlciB1cGRhdGUgc2VsZiBieSB1c2VyIGlucHV0dGVkIGRhdGUgc3RyaW5nLCBhY2NlcHQgJ3l5eXkvbW0vZGQnXG4gICAqIEBleGFtcGxlICcxMzk2LzEwLzInLCAnJ1xuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gICdvYnNlcnZlcic6IGZhbHNlLFxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8vLy8vLy8vLy8gVW4gIGltcGxlbWVudGVkIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIHdhaXRlIHRpbWUgZm9yIGxhc3QgdXNlciBrZXktZG93biBldmVudCwgYWNjZXB0IG1pbGxpc2Vjb25kXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDgwMFxuICAgKi9cbiAgJ2lucHV0RGVsYXknOiA4MDBcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29uZmlnO1xuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIE1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuLyoqXG4gKiBAYXV0aG9yIGJhYmFraGFuaS5yZXphQGdtYWlsLmNvbVxuICogQGRlc2NyaXB0aW9uIGpxdWVyeSBwbHVnaW4gaW5pdGlhbGl6ZXJcbiAqL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgICQuZm4ucGVyc2lhbkRhdGVwaWNrZXIgPSAkLmZuLnBEYXRlcGlja2VyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICAgICAgb3V0cHV0ID0gbnVsbCxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMpIHtcbiAgICAgICAgICAgICQuZXJyb3IoJ0ludmFsaWQgc2VsZWN0b3InKTtcbiAgICAgICAgfVxuICAgICAgICAkKHRoaXMpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gZW5jYXBzdWxhdGlvbiBBcmdzXG4gICAgICAgICAgICB2YXIgZW1wdHlBcnIgPSBbXSxcbiAgICAgICAgICAgICAgICB0ZW1wQXJnID0gYXJncy5jb25jYXQoZW1wdHlBcnIpLFxuICAgICAgICAgICAgICAgIGRwID0gJCh0aGlzKS5kYXRhKCdkYXRlcGlja2VyJyksXG4gICAgICAgICAgICAgICAgZnVuY05hbWUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGRwICYmIHR5cGVvZiB0ZW1wQXJnWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGZ1bmNOYW1lID0gdGVtcEFyZ1swXTtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBkcFtmdW5jTmFtZV0odGVtcEFyZ1swXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYucERhdGVQaWNrZXIgPSBuZXcgTW9kZWwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAkKHRoaXMpLmRhdGEoJ2RhdGVwaWNrZXInLCBzZWxmLnBEYXRlUGlja2VyKTtcbiAgICAgICAgcmV0dXJuIHNlbGYucERhdGVQaWNrZXI7XG4gICAgfTtcbiAgICAvKmVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cbn0pKGpRdWVyeSk7XG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgSGVscGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBQZXJzaWFuRGF0ZVBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG4vKipcbiAqIERvIGV2ZXJ5IHRoaW5nIGFib3V0IGlucHV0IGVsZW1lbnQgbGlrZSBnZXQgZGVmYXVsdCB2YWx1ZSwgc2V0IG5ldyB2YWx1ZSwgc2V0IGFsdCBmaWVsZCBpbnB1dCBhbmQgZXRjLlxuICovXG5cbnZhciBJbnB1dCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TW9kZWx9IG1vZGVsXG4gICAgICogQHBhcmFtIHtFbGVtZW50fVxuICAgICAqIEByZXR1cm4ge0lucHV0fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIElucHV0KG1vZGVsLCBpbnB1dEVsZW1lbnQpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElucHV0KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9maXJzdFVwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbGVtID0gaW5wdXRFbGVtZW50O1xuXG4gICAgICAgIGlmICh0aGlzLm1vZGVsLm9wdGlvbnMub2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hZGRJbml0aWFsQ2xhc3MoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5pdGlhbFVuaXggPSBudWxsO1xuXG4gICAgICAgIGlmICh0aGlzLm1vZGVsLm9wdGlvbnMuaW5saW5lID09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLl9hdHRhY2hJbnB1dEVsZW1lbnRFdmVudHMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhJbnB1dCwgW3tcbiAgICAgICAga2V5OiAnYWRkSW5pdGlhbENsYXNzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEluaXRpYWxDbGFzcygpIHtcbiAgICAgICAgICAgICQodGhpcy5lbGVtKS5hZGRDbGFzcygncHd0LWRhdGVwaWNrZXItaW5wdXQtZWxlbWVudCcpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdwYXJzZUlucHV0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlSW5wdXQoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciBwYXJzZSA9IG5ldyBQZXJzaWFuRGF0ZVBhcnNlcigpLFxuICAgICAgICAgICAgICAgIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHBhcnNlLnBhcnNlKGlucHV0U3RyaW5nKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBkID0gdGhpcy5tb2RlbC5QZXJzaWFuRGF0ZS5kYXRlKHBhcnNlLnBhcnNlKGlucHV0U3RyaW5nKSkudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRoYXQubW9kZWwuc3RhdGUuc2V0U2VsZWN0ZWREYXRlVGltZSgndW5peCcsIHBkKTtcbiAgICAgICAgICAgICAgICB0aGF0Lm1vZGVsLnN0YXRlLnNldFZpZXdEYXRlVGltZSgndW5peCcsIHBkKTtcbiAgICAgICAgICAgICAgICB0aGF0Lm1vZGVsLnZpZXcucmVuZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ29ic2VydmUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb2JzZXJ2ZSgpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vICAgTWFuaXB1bGF0ZSBieSBDb3B5IEFuZCBwYXN0ZVxuICAgICAgICAgICAgJCh0aGF0LmVsZW0pLmJpbmQoJ3Bhc3RlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBIZWxwZXIuZGVsYXkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LnBhcnNlSW5wdXQoZS50YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH0sIDYwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHR5cGluZ1RpbWVyID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGRvbmVUeXBpbmdJbnRlcnZhbCA9IHRoYXQubW9kZWwub3B0aW9ucy5pbnB1dERlbGF5LFxuICAgICAgICAgICAgICAgIGN0cmxEb3duID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgY3RybEtleSA9IFsxNywgOTFdLFxuICAgICAgICAgICAgICAgIHZLZXkgPSA4NjtcblxuICAgICAgICAgICAgJChkb2N1bWVudCkua2V5ZG93bihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmICgkLmluQXJyYXkoZS5rZXlDb2RlLCBjdHJsS2V5KSA+IDApIGN0cmxEb3duID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pLmtleXVwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCQuaW5BcnJheShlLmtleUNvZGUsIGN0cmxLZXkpID4gMCkgY3RybERvd24gPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAkKHRoYXQuZWxlbSkuYmluZCgna2V5dXAnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciAkc2VsZiA9ICQodGhpcyk7XG4gICAgICAgICAgICAgICAgdmFyIHRydWVLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSA4IHx8IGUua2V5Q29kZSA8IDEwNSAmJiBlLmtleUNvZGUgPiA5NiB8fCBlLmtleUNvZGUgPCA1OCAmJiBlLmtleUNvZGUgPiA0NyB8fCBjdHJsRG93biAmJiAoZS5rZXlDb2RlID09IHZLZXkgfHwgJC5pbkFycmF5KGUua2V5Q29kZSwgY3RybEtleSkgPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICB0cnVlS2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRydWVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHR5cGluZ1RpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgdHlwaW5nVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmVUeXBpbmcoJHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICB9LCBkb25lVHlwaW5nSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAkKHRoYXQuZWxlbSkub24oJ2tleWRvd24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHR5cGluZ1RpbWVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZnVuY3Rpb24gZG9uZVR5cGluZygkc2VsZikge1xuICAgICAgICAgICAgICAgIHRoYXQucGFyc2VJbnB1dCgkc2VsZi52YWwoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vICAgTWFuaXB1bGF0ZSBieSBhbHQgY2hhbmdlc1xuICAgICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgICAgLy8gc2VsZi5tb2RlbC5vcHRpb25zLmFsdEZpZWxkLmJpbmQoXCJjaGFuZ2VcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gICAgIC8vaWYgKCFzZWxmLl9mbGFnU2VsZk1hbmlwdWxhdGUpIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgbGV0IG5ld0RhdGUgPSBuZXcgRGF0ZSgkKHRoaXMpLnZhbCgpKTtcbiAgICAgICAgICAgIC8vICAgICAgICAgaWYgKG5ld0RhdGUgIT09IFwiSW52YWxpZCBEYXRlXCIpIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIGxldCBuZXdQZXJzYWluRGF0ZSA9IHRoaXMubW9kZWwuUGVyc2lhbkRhdGUuZGF0ZShuZXdEYXRlKTtcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIHNlbGYuc2VsZWN0RGF0ZShuZXdQZXJzYWluRGF0ZS52YWx1ZU9mKCkpO1xuICAgICAgICAgICAgLy8gICAgICAgICB9XG4gICAgICAgICAgICAvLyAgIC8vICB9XG4gICAgICAgICAgICAvLyB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAZGVzYyBhdHRhY2ggZXZlbnRzIHRvIGlucHV0IGZpZWxkXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfYXR0YWNoSW5wdXRFbGVtZW50RXZlbnRzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hdHRhY2hJbnB1dEVsZW1lbnRFdmVudHMoKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY2xvc2VQaWNrZXJIYW5kbGVyID0gZnVuY3Rpb24gY2xvc2VQaWNrZXJIYW5kbGVyKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoISQoZS50YXJnZXQpLmlzKHRoYXQuZWxlbSkgJiYgISQoZS50YXJnZXQpLmlzKHRoYXQubW9kZWwudmlldy4kY29udGFpbmVyKSAmJiAkKGUudGFyZ2V0KS5jbG9zZXN0KCcjJyArIHRoYXQubW9kZWwudmlldy4kY29udGFpbmVyLmF0dHIoJ2lkJykpLmxlbmd0aCA9PSAwICYmICEkKGUudGFyZ2V0KS5pcygkKHRoYXQuZWxlbSkuY2hpbGRyZW4oKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5tb2RlbC5hcGkuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAkKCdib2R5JykudW5iaW5kKCdjbGljaycsIGNsb3NlUGlja2VySGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgJCh0aGlzLmVsZW0pLm9uKCdmb2N1cyBjbGljaycsIEhlbHBlci5kZWJvdW5jZShmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgdGhhdC5tb2RlbC5hcGkuc2hvdygpO1xuICAgICAgICAgICAgICAgIGlmICh0aGF0Lm1vZGVsLnN0YXRlLnVpLmlzSW5saW5lID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAkKCdib2R5JykudW5iaW5kKCdjbGljaycsIGNsb3NlUGlja2VySGFuZGxlcikuYmluZCgnY2xpY2snLCBjbG9zZVBpY2tlckhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoSGVscGVyLmlzTW9iaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcykuYmx1cigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSwgMjAwKSk7XG5cbiAgICAgICAgICAgICQodGhpcy5lbGVtKS5vbigna2V5ZG93bicsIEhlbHBlci5kZWJvdW5jZShmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2dC53aGljaCA9PT0gOSkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0Lm1vZGVsLmFwaS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAyMDApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyBnZXQgPGlucHV0Lz4gZWxlbWVudCBwb3NpdGlvblxuICAgICAgICAgKiBAcmV0dXJuIHt7dG9wOiBOdW1iZXIsIGxlZnQ6IE51bWJlcn19XG4gICAgICAgICAqIEB0b2RvIHJlbW92ZSBqcXVlcnlcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldElucHV0UG9zaXRpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5wdXRQb3NpdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMuZWxlbSkub2Zmc2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgZ2V0IDxpbnB1dC8+IGVsZW1lbnQgc2l6ZVxuICAgICAgICAgKiBAcmV0dXJuIHt7d2lkdGg6IE51bWJlciwgaGVpZ2h0OiBOdW1iZXJ9fVxuICAgICAgICAgKiBAdG9kbyByZW1vdmUganF1ZXJ5XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRJbnB1dFNpemUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5wdXRTaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogJCh0aGlzLmVsZW0pLm91dGVyV2lkdGgoKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICQodGhpcy5lbGVtKS5vdXRlckhlaWdodCgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjIHVwZGF0ZSA8aW5wdXQvPiBlbGVtZW50IHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB1bml4XG4gICAgICAgICAqIEB0b2RvIHJlbW92ZSBqcXVlcnlcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ191cGRhdGVBbHRGaWVsZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlQWx0RmllbGQodW5peCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5tb2RlbC5vcHRpb25zLmFsdEZpZWxkRm9ybWF0dGVyKHVuaXgpO1xuICAgICAgICAgICAgJCh0aGlzLm1vZGVsLm9wdGlvbnMuYWx0RmllbGQpLnZhbCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgdXBkYXRlIDxpbnB1dC8+IGVsZW1lbnQgdmFsdWVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHVuaXhcbiAgICAgICAgICogQHRvZG8gcmVtb3ZlIGpxdWVyeVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3VwZGF0ZUlucHV0RmllbGQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUlucHV0RmllbGQodW5peCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5tb2RlbC5vcHRpb25zLmZvcm1hdHRlcih1bml4KTtcbiAgICAgICAgICAgIGlmICgkKHRoaXMuZWxlbSkudmFsKCkgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMuZWxlbSkudmFsKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gdW5peFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndXBkYXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSh1bml4KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlbC5vcHRpb25zLmluaXRpYWxWYWx1ZSA9PSBmYWxzZSAmJiB0aGlzLl9maXJzdFVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcnN0VXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUlucHV0RmllbGQodW5peCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlQWx0RmllbGQodW5peCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgcmV0dXJuIGluaXRpYWwgdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7TnVtYmVyfSAtIHVuaXhcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldE9uSW5pdFN0YXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9uSW5pdFN0YXRlKCkge1xuICAgICAgICAgICAgdmFyIHBlcnNpYW5EYXRlUGlja2VyVGltZVJlZ2V4ID0gJ14oWzAtMV1bMC05XXwyWzAtM10pOihbMC01XVswLTldKSg/OjooWzAtNV1bMC05XSkpPyQnO1xuICAgICAgICAgICAgdmFyIGdhcmVndXJpYW5EYXRlID0gbnVsbCxcbiAgICAgICAgICAgICAgICAkaW5wdXRFbGVtID0gJCh0aGlzLmVsZW0pLFxuICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIC8vIERlZmluZSBpbnB1dCB2YWx1ZSBieSBjaGVjayBpbmxpbmUgbW9kZSBhbmQgaW5wdXQgbW9kZVxuXG4gICAgICAgICAgICBpZiAoJGlucHV0RWxlbVswXS5ub2RlTmFtZSA9PT0gJ0lOUFVUJykge1xuICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSAkaW5wdXRFbGVtWzBdLmdldEF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9ICRpbnB1dEVsZW0uZGF0YSgnZGF0ZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayB0aW1lIHN0cmluZyBieSByZWdleFxuICAgICAgICAgICAgaWYgKGlucHV0VmFsdWUgJiYgaW5wdXRWYWx1ZS5tYXRjaChwZXJzaWFuRGF0ZVBpY2tlclRpbWVSZWdleCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGltZUFycmF5ID0gaW5wdXRWYWx1ZS5zcGxpdCgnOicpLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wRGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgdGVtcERhdGUuc2V0SG91cnModGltZUFycmF5WzBdKTtcbiAgICAgICAgICAgICAgICB0ZW1wRGF0ZS5zZXRNaW51dGVzKHRpbWVBcnJheVsxXSk7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVBcnJheVsyXSkge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wRGF0ZS5zZXRTZWNvbmRzKHRpbWVBcnJheVsyXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcERhdGUuc2V0U2Vjb25kcygwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsVW5peCA9IHRlbXBEYXRlLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubW9kZWwub3B0aW9ucy5pbml0aWFsVmFsdWVUeXBlID09PSAncGVyc2lhbicgJiYgaW5wdXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2UgPSBuZXcgUGVyc2lhbkRhdGVQYXJzZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBkID0gbmV3IHBlcnNpYW5EYXRlKHBhcnNlLnBhcnNlKGlucHV0VmFsdWUpKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgICAgIGdhcmVndXJpYW5EYXRlID0gbmV3IERhdGUocGQpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubW9kZWwub3B0aW9ucy5pbml0aWFsVmFsdWVUeXBlID09PSAndW5peCcgJiYgaW5wdXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBnYXJlZ3VyaWFuRGF0ZSA9IHBhcnNlSW50KGlucHV0VmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBnYXJlZ3VyaWFuRGF0ZSA9IG5ldyBEYXRlKGlucHV0VmFsdWUpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdhcmVndXJpYW5EYXRlICYmIGdhcmVndXJpYW5EYXRlICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbFVuaXggPSBnYXJlZ3VyaWFuRGF0ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxVbml4ID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbFVuaXg7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSW5wdXQ7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gSW5wdXQ7XG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgSGFtc3RlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG4vKipcbiAqIFRoaXMgbmF2aWdhdG9yIGNsYXNzIGRvIGV2ZXJ5IHRoaW5nIGFib3V0IG5hdmlnYXRlIGFuZCBzZWxlY3QgZGF0ZVxuICogQHB1YmxpY1xuICovXG5cbnZhciBOYXZpZ2F0b3IgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0ZXBpY2tlclxuICAgICAqIEByZXR1cm4ge05hdmlnYXRvcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBOYXZpZ2F0b3IobW9kZWwpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5hdmlnYXRvcik7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtEYXRlcGlja2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgICAgICB0aGlzLmxpdmVBdHRhY2goKTtcbiAgICAgICAgdGhpcy5fYXR0YWNoRXZlbnRzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXNjIGF0dGFjaCBldmVudHMgdGhhdCBuZWVkZWQgYXR0YWNoIGFmdGVyIGV2ZXJ5IHJlbmRlclxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdG9kbyBhdHRhY2ggYXMgYSBsaXZlIHdheVxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoTmF2aWdhdG9yLCBbe1xuICAgICAgICBrZXk6ICdsaXZlQXR0YWNoJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxpdmVBdHRhY2goKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBvcHRpb25zXG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlbC5vcHRpb25zLm5hdmlnYXRvci5zY3JvbGwuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgZ3JpZFBsb3QgPSAkKCcjJyArIHRoYXQubW9kZWwudmlldy5pZCArICcgLmRhdGVwaWNrZXItZ3JpZC12aWV3JylbMF07XG4gICAgICAgICAgICAgICAgSGFtc3RlcihncmlkUGxvdCkud2hlZWwoZnVuY3Rpb24gKGV2ZW50LCBkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVsdGEgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Lm1vZGVsLnN0YXRlLm5hdmlnYXRlKCduZXh0Jyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Lm1vZGVsLnN0YXRlLm5hdmlnYXRlKCdwcmV2Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhhdC5tb2RlbC52aWV3LnJlbmRlcigpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubW9kZWwub3B0aW9ucy50aW1lUGlja2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgJCgnIycgKyB0aGF0Lm1vZGVsLnZpZXcuaWQgKyAnIC50aW1lLXNlZ21lbnQnKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEhhbXN0ZXIodGhpcykud2hlZWwoZnVuY3Rpb24gKGV2ZW50LCBkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkdGFyZ2V0ID0gJChldmVudC50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSAkdGFyZ2V0LmRhdGEoJ3RpbWUta2V5JykgPyAkdGFyZ2V0LmRhdGEoJ3RpbWUta2V5JykgOiAkdGFyZ2V0LnBhcmVudHMoJ1tkYXRhLXRpbWUta2V5XScpLmRhdGEoJ3RpbWUta2V5Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsdGEgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnRpbWVVcChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC50aW1lRG93bihrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQubW9kZWwudmlldy5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyBzZXQgdGltZSB1cCBkZXBlbmQgdG8gdGltZWtleVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGltZWtleSAtIGFjY2VwdCBob3VyLCBtaW51dGUsc2Vjb25kXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RpbWVVcCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0aW1lVXAodGltZWtleSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kZWwub3B0aW9ucy50aW1lUGlja2VyW3RpbWVrZXldID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdGVwID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIHQgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGltZWtleSA9PSAnbWVyaWRpYW4nKSB7XG4gICAgICAgICAgICAgICAgc3RlcCA9IDEyO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1vZGVsLnN0YXRlLnZpZXcubWVyaWRpYW4gPT0gJ1BNJykge1xuICAgICAgICAgICAgICAgICAgICB0ID0gdGhpcy5tb2RlbC5QZXJzaWFuRGF0ZS5kYXRlKHRoaXMubW9kZWwuc3RhdGUuc2VsZWN0ZWQudW5peERhdGUpLmFkZCgnaG91cicsIHN0ZXApLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ID0gdGhpcy5tb2RlbC5QZXJzaWFuRGF0ZS5kYXRlKHRoaXMubW9kZWwuc3RhdGUuc2VsZWN0ZWQudW5peERhdGUpLnN1YnRyYWN0KCdob3VyJywgc3RlcCkudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnN0YXRlLm1lcmlkaWFuVG9nZ2xlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0ZXAgPSB0aGlzLm1vZGVsLm9wdGlvbnMudGltZVBpY2tlclt0aW1la2V5XS5zdGVwO1xuICAgICAgICAgICAgICAgIHQgPSB0aGlzLm1vZGVsLlBlcnNpYW5EYXRlLmRhdGUodGhpcy5tb2RlbC5zdGF0ZS5zZWxlY3RlZC51bml4RGF0ZSkuYWRkKHRpbWVrZXksIHN0ZXApLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubW9kZWwuc3RhdGUuc2V0Vmlld0RhdGVUaW1lKCd1bml4JywgdCk7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnN0YXRlLnNldFNlbGVjdGVkRGF0ZVRpbWUoJ3VuaXgnLCB0KTtcbiAgICAgICAgICAgIHRoaXMubW9kZWwudmlldy5yZW5kZXJUaW1lUGFydGlhbCgpO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2Nyb2xsRGVsYXlUaW1lRG93bik7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbERlbGF5VGltZVVwID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5tb2RlbC52aWV3Lm1hcmtTZWxlY3RlZERheSgpO1xuICAgICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyBzZXQgdGltZSBkb3duIGRlcGVuZCB0byB0aW1la2V5XG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0aW1la2V5IC0gYWNjZXB0IGhvdXIsIG1pbnV0ZSxzZWNvbmRcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndGltZURvd24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdGltZURvd24odGltZWtleSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kZWwub3B0aW9ucy50aW1lUGlja2VyW3RpbWVrZXldID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdGVwID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIHQgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGltZWtleSA9PSAnbWVyaWRpYW4nKSB7XG4gICAgICAgICAgICAgICAgc3RlcCA9IDEyO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1vZGVsLnN0YXRlLnZpZXcubWVyaWRpYW4gPT0gJ0FNJykge1xuICAgICAgICAgICAgICAgICAgICB0ID0gdGhpcy5tb2RlbC5QZXJzaWFuRGF0ZS5kYXRlKHRoaXMubW9kZWwuc3RhdGUuc2VsZWN0ZWQudW5peERhdGUpLmFkZCgnaG91cicsIHN0ZXApLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ID0gdGhpcy5tb2RlbC5QZXJzaWFuRGF0ZS5kYXRlKHRoaXMubW9kZWwuc3RhdGUuc2VsZWN0ZWQudW5peERhdGUpLnN1YnRyYWN0KCdob3VyJywgc3RlcCkudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnN0YXRlLm1lcmlkaWFuVG9nZ2xlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0ZXAgPSB0aGlzLm1vZGVsLm9wdGlvbnMudGltZVBpY2tlclt0aW1la2V5XS5zdGVwO1xuICAgICAgICAgICAgICAgIHQgPSB0aGlzLm1vZGVsLlBlcnNpYW5EYXRlLmRhdGUodGhpcy5tb2RlbC5zdGF0ZS5zZWxlY3RlZC51bml4RGF0ZSkuc3VidHJhY3QodGltZWtleSwgc3RlcCkudmFsdWVPZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tb2RlbC5zdGF0ZS5zZXRWaWV3RGF0ZVRpbWUoJ3VuaXgnLCB0KTtcbiAgICAgICAgICAgIHRoaXMubW9kZWwuc3RhdGUuc2V0U2VsZWN0ZWREYXRlVGltZSgndW5peCcsIHQpO1xuICAgICAgICAgICAgdGhpcy5tb2RlbC52aWV3LnJlbmRlclRpbWVQYXJ0aWFsKCk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zY3JvbGxEZWxheVRpbWVEb3duKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRGVsYXlUaW1lRG93biA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoYXQubW9kZWwudmlldy5tYXJrU2VsZWN0ZWREYXkoKTtcbiAgICAgICAgICAgIH0sIDMwMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgYXR0YWNoIGRvbSBldmVudHNcbiAgICAgICAgICogQHRvZG8gcmVtb3ZlIGpxdWVyeVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2F0dGFjaEV2ZW50cycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYXR0YWNoRXZlbnRzKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlbC5vcHRpb25zLm5hdmlnYXRvci5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIG5hdmlnYXRvciBjbGljayBldmVudFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICQoZG9jdW1lbnQpLm9uKCdjbGljaycsICcjJyArIHRoYXQubW9kZWwudmlldy5pZCArICcgLnB3dC1idG4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkKHRoaXMpLmlzKCcucHd0LWJ0bi1uZXh0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQubW9kZWwuc3RhdGUubmF2aWdhdGUoJ25leHQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQubW9kZWwudmlldy5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQubW9kZWwub3B0aW9ucy5uYXZpZ2F0b3Iub25OZXh0KHRoYXQubW9kZWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCQodGhpcykuaXMoJy5wd3QtYnRuLXN3aXRjaCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Lm1vZGVsLnN0YXRlLnN3aXRjaFZpZXdNb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Lm1vZGVsLnZpZXcucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Lm1vZGVsLm9wdGlvbnMubmF2aWdhdG9yLm9uU3dpdGNoKHRoYXQubW9kZWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCQodGhpcykuaXMoJy5wd3QtYnRuLXByZXYnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5tb2RlbC5zdGF0ZS5uYXZpZ2F0ZSgncHJldicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5tb2RlbC52aWV3LnJlbmRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5tb2RlbC5vcHRpb25zLm5hdmlnYXRvci5vblByZXYodGhhdC5tb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gY2hlY2sgaWYgdGltZVBpY2tlciBlbmFibGVkIGF0dGFjaCBFdmVudHNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kZWwub3B0aW9ucy50aW1lUGlja2VyLmVuYWJsZWQpIHtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiB0aW1lIHVwIGJ0biBjbGljayBldmVudFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICQoZG9jdW1lbnQpLm9uKCdjbGljaycsICcjJyArIHRoYXQubW9kZWwudmlldy5pZCArICcgLnVwLWJ0bicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVrZXkgPSAkKHRoaXMpLmRhdGEoJ3RpbWUta2V5Jyk7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQudGltZVVwKHRpbWVrZXkpO1xuICAgICAgICAgICAgICAgICAgICB0aGF0Lm1vZGVsLm9wdGlvbnMub25TZWxlY3QodGhhdC5tb2RlbC5zdGF0ZS5zZWxlY3RlZC51bml4RGF0ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gdGltZSBkb3duIGJ0biBjbGljayBldmVudFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICQoZG9jdW1lbnQpLm9uKCdjbGljaycsICcjJyArIHRoYXQubW9kZWwudmlldy5pZCArICcgLmRvd24tYnRuJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWtleSA9ICQodGhpcykuZGF0YSgndGltZS1rZXknKTtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC50aW1lRG93bih0aW1la2V5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5tb2RlbC5vcHRpb25zLm9uU2VsZWN0KHRoYXQubW9kZWwuc3RhdGUuc2VsZWN0ZWQudW5peERhdGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBjaGVjayBpZiBkYXlQaWNrZXIgZW5hYmxlZCBhdHRhY2ggRXZlbnRzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGVsLm9wdGlvbnMuZGF5UGlja2VyLmVuYWJsZWQpIHtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBkYXlzIGNsaWNrIGV2ZW50XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgJChkb2N1bWVudCkub24oJ2NsaWNrJywgJyMnICsgdGhhdC5tb2RlbC52aWV3LmlkICsgJyAuZGF0ZXBpY2tlci1kYXktdmlldyB0ZDpub3QoLmRpc2FibGVkKScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoaXNVbml4ID0gJCh0aGlzKS5kYXRhKCd1bml4JyksXG4gICAgICAgICAgICAgICAgICAgICAgICBtdXN0UmVuZGVyID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICB0aGF0Lm1vZGVsLnN0YXRlLnNldFNlbGVjdGVkRGF0ZVRpbWUoJ3VuaXgnLCB0aGlzVW5peCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGF0Lm1vZGVsLnN0YXRlLnNlbGVjdGVkLm1vbnRoICE9PSB0aGF0Lm1vZGVsLnN0YXRlLnZpZXcubW9udGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11c3RSZW5kZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVzdFJlbmRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoYXQubW9kZWwuc3RhdGUuc2V0Vmlld0RhdGVUaW1lKCd1bml4JywgdGhhdC5tb2RlbC5zdGF0ZS5zZWxlY3RlZC51bml4RGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGF0Lm1vZGVsLm9wdGlvbnMuYXV0b0Nsb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Lm1vZGVsLnZpZXcuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5tb2RlbC5vcHRpb25zLm9uSGlkZSh0aGF0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobXVzdFJlbmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5tb2RlbC52aWV3LnJlbmRlcigpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5tb2RlbC52aWV3Lm1hcmtTZWxlY3RlZERheSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoYXQubW9kZWwub3B0aW9ucy5kYXlQaWNrZXIub25TZWxlY3QodGhpc1VuaXgpO1xuICAgICAgICAgICAgICAgICAgICB0aGF0Lm1vZGVsLm9wdGlvbnMub25TZWxlY3QodGhpc1VuaXgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBjaGVjayBpZiBtb250aFBpY2tlciBlbmFibGVkIGF0dGFjaCBFdmVudHNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kZWwub3B0aW9ucy5tb250aFBpY2tlci5lbmFibGVkKSB7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gbW9udGggY2xpY2sgZXZlbnRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAkKGRvY3VtZW50KS5vbignY2xpY2snLCAnIycgKyB0aGF0Lm1vZGVsLnZpZXcuaWQgKyAnIC5kYXRlcGlja2VyLW1vbnRoLXZpZXcgLm1vbnRoLWl0ZW06bm90KC5tb250aC1pdGVtLWRpc2FibGUpJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW9udGggPSAkKHRoaXMpLmRhdGEoJ21vbnRoJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5ZWFyID0gJCh0aGlzKS5kYXRhKCd5ZWFyJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQubW9kZWwuc3RhdGUuc3dpdGNoVmlld01vZGVUbygnZGF5Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhhdC5tb2RlbC5vcHRpb25zLm9ubHlTZWxlY3RPbkRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQubW9kZWwuc3RhdGUuc2V0U2VsZWN0ZWREYXRlVGltZSgneWVhcicsIHllYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5tb2RlbC5zdGF0ZS5zZXRTZWxlY3RlZERhdGVUaW1lKCdtb250aCcsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0Lm1vZGVsLm9wdGlvbnMuYXV0b0Nsb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5tb2RlbC52aWV3LmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0Lm1vZGVsLm9wdGlvbnMub25IaWRlKHRoYXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoYXQubW9kZWwuc3RhdGUuc2V0Vmlld0RhdGVUaW1lKCdtb250aCcsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5tb2RlbC52aWV3LnJlbmRlcigpO1xuICAgICAgICAgICAgICAgICAgICB0aGF0Lm1vZGVsLm9wdGlvbnMubW9udGhQaWNrZXIub25TZWxlY3QobW9udGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGF0Lm1vZGVsLm9wdGlvbnMub25TZWxlY3QodGhhdC5tb2RlbC5zdGF0ZS5zZWxlY3RlZC51bml4RGF0ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIGNoZWNrIGlmIHllYXJQaWNrZXIgZW5hYmxlZCBhdHRhY2ggRXZlbnRzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGVsLm9wdGlvbnMueWVhclBpY2tlci5lbmFibGVkKSB7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24geWVhciBjbGljayBldmVudFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICQoZG9jdW1lbnQpLm9uKCdjbGljaycsICcjJyArIHRoYXQubW9kZWwudmlldy5pZCArICcgLmRhdGVwaWNrZXIteWVhci12aWV3IC55ZWFyLWl0ZW06bm90KC55ZWFyLWl0ZW0tZGlzYWJsZSknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5ZWFyID0gJCh0aGlzKS5kYXRhKCd5ZWFyJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQubW9kZWwuc3RhdGUuc3dpdGNoVmlld01vZGVUbygnbW9udGgnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGF0Lm1vZGVsLm9wdGlvbnMub25seVNlbGVjdE9uRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5tb2RlbC5zdGF0ZS5zZXRTZWxlY3RlZERhdGVUaW1lKCd5ZWFyJywgeWVhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5tb2RlbC5vcHRpb25zLmF1dG9DbG9zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQubW9kZWwudmlldy5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5tb2RlbC5vcHRpb25zLm9uSGlkZSh0aGF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGF0Lm1vZGVsLnN0YXRlLnNldFZpZXdEYXRlVGltZSgneWVhcicsIHllYXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGF0Lm1vZGVsLnZpZXcucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQubW9kZWwub3B0aW9ucy55ZWFyUGlja2VyLm9uU2VsZWN0KHllYXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGF0Lm1vZGVsLm9wdGlvbnMub25TZWxlY3QodGhhdC5tb2RlbC5zdGF0ZS5zZWxlY3RlZC51bml4RGF0ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTmF2aWdhdG9yO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5hdmlnYXRvcjtcblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBDb25maWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xudmFyIFRlbXBsYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qKlxuICogRXh0ZW5kIGRlZmF1bHQgY29uZmlnIGZyb20gdXNlciBpbnRlcnJlZCBhbmQgZG8gY29tcGF0aWJpbGl0eSB3b3Jrc1xuICogQHB1YmxpY1xuICovXG5cbnZhciBPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgY29uZmlnIHBhc3NlZCB3aGVuIGluaXRpYWxpemVcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAgICogQHRvZG8gcmVtb3ZlIGpxdWVyeVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE9wdGlvbnMob3B0aW9ucywgbW9kZWwpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBhdGliaWxpdHkoJC5leHRlbmQodHJ1ZSwgdGhpcywgQ29uZmlnLCBvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoT3B0aW9ucywgW3tcbiAgICAgICAga2V5OiAnX2NvbXBhdGliaWxpdHknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbXBhdGliaWxpdHkob3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pbmxpbmUpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnRvb2xib3guc3VibWl0QnV0dG9uLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy50ZW1wbGF0ZSA9IFRlbXBsYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGVyc2lhbkRhdGUudG9DYWxlbmRhcihvcHRpb25zLmNhbGVuZGFyVHlwZSk7XG4gICAgICAgICAgICBwZXJzaWFuRGF0ZS50b0xvY2FsZShvcHRpb25zLmNhbGVuZGFyW29wdGlvbnMuY2FsZW5kYXJUeXBlXS5sb2NhbGUpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25seVRpbWVQaWNrZXIpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRheVBpY2tlci5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tb250aFBpY2tlci5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy55ZWFyUGlja2VyLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm5hdmlnYXRvci5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy50b29sYm94LmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnRpbWVQaWNrZXIuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRpbWVQaWNrZXIuaG91ci5zdGVwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy50aW1lUGlja2VyLmhvdXIuc3RlcCA9IG9wdGlvbnMudGltZVBpY2tlci5zdGVwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGltZVBpY2tlci5taW51dGUuc3RlcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudGltZVBpY2tlci5taW51dGUuc3RlcCA9IG9wdGlvbnMudGltZVBpY2tlci5zdGVwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGltZVBpY2tlci5zZWNvbmQuc3RlcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudGltZVBpY2tlci5zZWNvbmQuc3RlcCA9IG9wdGlvbnMudGltZVBpY2tlci5zdGVwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kYXlQaWNrZXIuZW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9ubHlTZWxlY3RPbkRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3B0aW9ucy5fdmlld01vZGVMaXN0ID0gW107XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kYXlQaWNrZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuX3ZpZXdNb2RlTGlzdC5wdXNoKCdkYXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1vbnRoUGlja2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLl92aWV3TW9kZUxpc3QucHVzaCgnbW9udGgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnllYXJQaWNrZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuX3ZpZXdNb2RlTGlzdC5wdXNoKCd5ZWFyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gT3B0aW9ucztcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPcHRpb25zO1xuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFBlcnNpYW5EYXRlUGFyc2VyID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBlcnNpYW5EYXRlUGFyc2VyKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGVyc2lhbkRhdGVQYXJzZXIpO1xuXG4gICAgICAgIHRoaXMucGF0dGVybiA9IHtcbiAgICAgICAgICAgIGlzbzogL14oLT8oPzpbMS05XVswLTldKik/WzAtOV17NH0pLSgxWzAtMl18MFsxLTldKS0oM1swMV18MFsxLTldfFsxMl1bMC05XSlUKDJbMC0zXXxbMDFdWzAtOV0pOihbMC01XVswLTldKTooWzAtNV1bMC05XSkoXFxcXC5bMC05XSspPyhaKT8kL2csXG4gICAgICAgICAgICBqYWxhbGk6IC9eWzEtNF1cXGR7M30oXFwvfC18XFwuKSgoMD9bMS02XShcXC98LXxcXC4pKCgzWzAtMV0pfChbMS0yXVswLTldKXwoMD9bMS05XSkpKXwoKDFbMC0yXXwoMD9bNy05XSkpKFxcL3wtfFxcLikoMzB8KFsxLTJdWzAtOV0pfCgwP1sxLTldKSkpKSQvZ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhQZXJzaWFuRGF0ZVBhcnNlciwgW3tcbiAgICAgICAga2V5OiAncGFyc2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBwZXJzaWFuRGF0ZUFycmF5ID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGlzb1BhdCA9IG5ldyBSZWdFeHAodGhhdC5wYXR0ZXJuLmlzbyksXG4gICAgICAgICAgICAgICAgamFsYWxpUGF0ID0gbmV3IFJlZ0V4cCh0aGF0LnBhdHRlcm4uamFsYWxpKTtcblxuICAgICAgICAgICAgU3RyaW5nLnByb3RvdHlwZS50b0VuZ2xpc2hEaWdpdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYXJDb2RlWmVybyA9ICfbsCcuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKC9b27At27ldL2csIGZ1bmN0aW9uICh3KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3LmNoYXJDb2RlQXQoMCkgLSBjaGFyQ29kZVplcm87XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpbnB1dFN0cmluZyA9IGlucHV0U3RyaW5nLnRvRW5nbGlzaERpZ2l0cygpO1xuICAgICAgICAgICAgaWYgKGphbGFsaVBhdC50ZXN0KGlucHV0U3RyaW5nKSkge1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVzZWxlc3MtZXNjYXBlICovXG4gICAgICAgICAgICAgICAgcGVyc2lhbkRhdGVBcnJheSA9IGlucHV0U3RyaW5nLnNwbGl0KC9cXC98LXxcXCx8XFwuLykubWFwKE51bWJlcik7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11c2VsZXNzLWVzY2FwZSAqL1xuICAgICAgICAgICAgICAgIHJldHVybiBwZXJzaWFuRGF0ZUFycmF5O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc29QYXQudGVzdChpbnB1dFN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11c2VsZXNzLWVzY2FwZSAqL1xuICAgICAgICAgICAgICAgIHBlcnNpYW5EYXRlQXJyYXkgPSBpbnB1dFN0cmluZy5zcGxpdCgvXFwvfC18XFwsfFxcOnxcXFR8XFxaL2cpLm1hcChOdW1iZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwZXJzaWFuRGF0ZUFycmF5O1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tdXNlbGVzcy1lc2NhcGUgKi9cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBQZXJzaWFuRGF0ZVBhcnNlcjtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQZXJzaWFuRGF0ZVBhcnNlcjtcblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgUGVyc2lhbkRhdGVXcmFwcGVyID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBlcnNpYW5EYXRlV3JhcHBlcihtb2RlbCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGVyc2lhbkRhdGVXcmFwcGVyKTtcblxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgICAgIHRoaXMubW9kZWwub3B0aW9ucy5jYWxlbmRhcl8gPSB0aGlzLm1vZGVsLm9wdGlvbnMuY2FsZW5kYXJUeXBlO1xuICAgICAgICB0aGlzLm1vZGVsLm9wdGlvbnMubG9jYWxlXyA9IHRoaXMubW9kZWwub3B0aW9ucy5jYWxlbmRhclt0aGlzLm1vZGVsLm9wdGlvbnMuY2FsZW5kYXJUeXBlXS5sb2NhbGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhQZXJzaWFuRGF0ZVdyYXBwZXIsIFt7XG4gICAgICAgIGtleTogXCJkYXRlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkYXRlKGlucHV0KSB7XG4gICAgICAgICAgICBpZiAod2luZG93Lmluc3BkQ291bnQgfHwgd2luZG93Lmluc3BkQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuaW5zcGRDb3VudCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuaW5zcGRDb3VudCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGNwID0gdm9pZCAwO1xuICAgICAgICAgICAgY3AgPSBwZXJzaWFuRGF0ZS50b0NhbGVuZGFyKHRoYXQubW9kZWwub3B0aW9ucy5jYWxlbmRhcl8pO1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kZWwub3B0aW9ucy5jYWxlbmRhclt0aGlzLm1vZGVsLm9wdGlvbnMuY2FsZW5kYXJUeXBlXS5sZWFwWWVhck1vZGUpIHtcbiAgICAgICAgICAgICAgICBjcC50b0xlYXBZZWFyTW9kZSh0aGlzLm1vZGVsLm9wdGlvbnMuY2FsZW5kYXJbdGhpcy5tb2RlbC5vcHRpb25zLmNhbGVuZGFyVHlwZV0ubGVhcFllYXJNb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dCA9IG5ldyBjcChpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0LnRvTG9jYWxlKHRoYXQubW9kZWwub3B0aW9ucy5sb2NhbGVfKTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBQZXJzaWFuRGF0ZVdyYXBwZXI7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGVyc2lhbkRhdGVXcmFwcGVyO1xuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogQWxsIHN0YXRlIHNldCBpbiBoaXMgb2JqZWN0IGFuZCBnZXQgZnJvbSB0aGlzXG4gKiBhbHNvIHRoaXMgb2JqZWN0IG5vdGlmeSBvdGhlciBvYmplY3QgdG8gdXBkYXRlIHNlbGYgb3IgdXBkYXRlIHZpZXcgb3IgZXRjLlxuICovXG52YXIgU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge21vZGVsfSBtb2RlbFxuICAgICAqIEByZXR1cm4ge1N0YXRlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN0YXRlKG1vZGVsKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGF0ZSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWxldHJlZERhdGUgPSB0aGlzLm1vZGVsLm9wdGlvbnMubWluRGF0ZSB8fCB0aGlzLm1vZGVsLm9wdGlvbnMubWF4RGF0ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgZ2V0IGdlbmVyYXRlZCB2aWV3IG1vZGUgbGlzdCBmcm9tIG9wdGlvbnMgb2JqZWN0XG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlld01vZGVMaXN0ID0gdGhpcy5tb2RlbC5vcHRpb25zLl92aWV3TW9kZUxpc3Q7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjIHZpZXcgbW9kZSBzdHJpbmcgZGF5LCBtb250aCwgeWVhclxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCBkYXlcbiAgICAgICAgICogQHRvZG8gYWRkIHRpbWUgdG8gdmlldyBtb2Rlc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52aWV3TW9kZSA9IHRoaXMudmlld01vZGVMaXN0LmluZGV4T2YobW9kZWwub3B0aW9ucy52aWV3TW9kZSkgPiAwID8gbW9kZWwub3B0aW9ucy52aWV3TW9kZSA6IHRoaXMudmlld01vZGVMaXN0WzBdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyB2aWV3IG1vZGUgc3RyaW5nIGluZGV4IGluIHZpZXcgbW9kZSBsaXN0XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZpZXdNb2RlSW5kZXggPSB0aGlzLnZpZXdNb2RlTGlzdC5pbmRleE9mKG1vZGVsLm9wdGlvbnMudmlld01vZGUpID4gMCA/IHRoaXMudmlld01vZGVMaXN0LmluZGV4T2YobW9kZWwub3B0aW9ucy52aWV3TW9kZSkgOiAwOyAvLyBkZWZhdWwgJ2RheSdcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyBjb250YWluIGZpbHRlcmVkIGRhdGUgb2JqZWN0c1xuICAgICAgICAgKiBAdHlwZSB7e3N0YXJ0OiB7eWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCBkYXRlOiBudW1iZXIsIGhvdXI6IG51bWJlciwgbWludXRlOiBudW1iZXIsIHNlY29uZDogbnVtYmVyLCB1bml4RGF0ZTogbnVtYmVyfSwgZW5kOiB7eWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCBkYXRlOiBudW1iZXIsIGhvdXI6IG51bWJlciwgbWludXRlOiBudW1iZXIsIHNlY29uZDogbnVtYmVyLCB1bml4RGF0ZTogbnVtYmVyfX19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbHRlckRhdGUgPSB7XG4gICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgIHllYXI6IDAsXG4gICAgICAgICAgICAgICAgbW9udGg6IDAsXG4gICAgICAgICAgICAgICAgZGF0ZTogMCxcbiAgICAgICAgICAgICAgICBob3VyOiAwLFxuICAgICAgICAgICAgICAgIG1pbnV0ZTogMCxcbiAgICAgICAgICAgICAgICBzZWNvbmQ6IDAsXG4gICAgICAgICAgICAgICAgdW5peERhdGU6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgICAgICB5ZWFyOiAwLFxuICAgICAgICAgICAgICAgIG1vbnRoOiAwLFxuICAgICAgICAgICAgICAgIGRhdGU6IDAsXG4gICAgICAgICAgICAgICAgaG91cjogMCxcbiAgICAgICAgICAgICAgICBtaW51dGU6IDAsXG4gICAgICAgICAgICAgICAgc2Vjb25kOiAwLFxuICAgICAgICAgICAgICAgIHVuaXhEYXRlOiAwXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjIGNvbnRhaW4gdmlldyBkYXRlIG9iamVjdFxuICAgICAgICAgKiBAdHlwZSB7e3llYXI6IG51bWJlciwgbW9udGg6IG51bWJlciwgZGF0ZTogbnVtYmVyLCBob3VyOiBudW1iZXIsIG1pbnV0ZTogbnVtYmVyLCBzZWNvbmQ6IG51bWJlciwgdW5peERhdGU6IG51bWJlciwgZGF0ZU9iamVjdDogbnVsbCwgbWVyaWRpYW46IHN0cmluZ319XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZpZXcgPSB7XG4gICAgICAgICAgICB5ZWFyOiAwLFxuICAgICAgICAgICAgbW9udGg6IDAsXG4gICAgICAgICAgICBkYXRlOiAwLFxuICAgICAgICAgICAgaG91cjogMCxcbiAgICAgICAgICAgIG1pbnV0ZTogMCxcbiAgICAgICAgICAgIHNlY29uZDogMCxcbiAgICAgICAgICAgIHVuaXhEYXRlOiAwLFxuICAgICAgICAgICAgZGF0ZU9iamVjdDogbnVsbCxcbiAgICAgICAgICAgIG1lcmlkaWFuOiAnQU0nXG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjIGNvbnRhaW4gc2VsZWN0ZWQgZGF0ZSBvYmplY3RcbiAgICAgICAgICogQHR5cGUge3t5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIsIGRhdGU6IG51bWJlciwgaG91cjogbnVtYmVyLCBtaW51dGU6IG51bWJlciwgc2Vjb25kOiBudW1iZXIsIHVuaXhEYXRlOiBudW1iZXIsIGRhdGVPYmplY3Q6IG51bGx9fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHtcbiAgICAgICAgICAgIHllYXI6IDAsXG4gICAgICAgICAgICBtb250aDogMCxcbiAgICAgICAgICAgIGRhdGU6IDAsXG4gICAgICAgICAgICBob3VyOiAwLFxuICAgICAgICAgICAgaG91cjEyOiAwLFxuICAgICAgICAgICAgbWludXRlOiAwLFxuICAgICAgICAgICAgc2Vjb25kOiAwLFxuICAgICAgICAgICAgdW5peERhdGU6IDAsXG4gICAgICAgICAgICBkYXRlT2JqZWN0OiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy51aSA9IHtcbiAgICAgICAgICAgIGlzT3BlbjogZmFsc2UsXG4gICAgICAgICAgICBpc0lubGluZTogdGhpcy5tb2RlbC5vcHRpb25zLmlubGluZVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX3NldEZpbHRlckRhdGUodGhpcy5tb2RlbC5vcHRpb25zLm1pbkRhdGUsIHRoaXMubW9kZWwub3B0aW9ucy5tYXhEYXRlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gbWluRGF0ZVxuICAgICAqIEBwYXJhbSBtYXhEYXRlXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhTdGF0ZSwgW3tcbiAgICAgICAga2V5OiAnX3NldEZpbHRlckRhdGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEZpbHRlckRhdGUobWluRGF0ZSwgbWF4RGF0ZSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCFtaW5EYXRlKSB7XG4gICAgICAgICAgICAgICAgbWluRGF0ZSA9IC0yMDAwMDAwMDAwMDAwMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtYXhEYXRlKSB7XG4gICAgICAgICAgICAgICAgbWF4RGF0ZSA9IDIwMDAwMDAwMDAwMDAwMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGQgPSBzZWxmLm1vZGVsLlBlcnNpYW5EYXRlLmRhdGUobWluRGF0ZSk7XG4gICAgICAgICAgICBzZWxmLmZpbHRlckRhdGUuc3RhcnQudW5peERhdGUgPSBtaW5EYXRlO1xuICAgICAgICAgICAgc2VsZi5maWx0ZXJEYXRlLnN0YXJ0LmhvdXIgPSBwZC5ob3VyKCk7XG4gICAgICAgICAgICBzZWxmLmZpbHRlckRhdGUuc3RhcnQubWludXRlID0gcGQubWludXRlKCk7XG4gICAgICAgICAgICBzZWxmLmZpbHRlckRhdGUuc3RhcnQuc2Vjb25kID0gcGQuc2Vjb25kKCk7XG4gICAgICAgICAgICBzZWxmLmZpbHRlckRhdGUuc3RhcnQubW9udGggPSBwZC5tb250aCgpO1xuICAgICAgICAgICAgc2VsZi5maWx0ZXJEYXRlLnN0YXJ0LmRhdGUgPSBwZC5kYXRlKCk7XG4gICAgICAgICAgICBzZWxmLmZpbHRlckRhdGUuc3RhcnQueWVhciA9IHBkLnllYXIoKTtcblxuICAgICAgICAgICAgdmFyIHBkRW5kID0gc2VsZi5tb2RlbC5QZXJzaWFuRGF0ZS5kYXRlKG1heERhdGUpO1xuICAgICAgICAgICAgc2VsZi5maWx0ZXJEYXRlLmVuZC51bml4RGF0ZSA9IG1heERhdGU7XG4gICAgICAgICAgICBzZWxmLmZpbHRlckRhdGUuZW5kLmhvdXIgPSBwZEVuZC5ob3VyKCk7XG4gICAgICAgICAgICBzZWxmLmZpbHRlckRhdGUuZW5kLm1pbnV0ZSA9IHBkRW5kLm1pbnV0ZSgpO1xuICAgICAgICAgICAgc2VsZi5maWx0ZXJEYXRlLmVuZC5zZWNvbmQgPSBwZEVuZC5zZWNvbmQoKTtcbiAgICAgICAgICAgIHNlbGYuZmlsdGVyRGF0ZS5lbmQubW9udGggPSBwZEVuZC5tb250aCgpO1xuICAgICAgICAgICAgc2VsZi5maWx0ZXJEYXRlLmVuZC5kYXRlID0gcGRFbmQuZGF0ZSgpO1xuICAgICAgICAgICAgc2VsZi5maWx0ZXJEYXRlLmVuZC55ZWFyID0gcGRFbmQueWVhcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjIGNoYW5nZSB2aWV3IHN0YXRlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYXYgLSBhY2NlcHQgbmV4dCwgcHJldlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbmF2aWdhdGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbmF2aWdhdGUobmF2KSB7XG4gICAgICAgICAgICBpZiAobmF2ID09ICduZXh0Jykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXdNb2RlID09ICd5ZWFyJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFZpZXdEYXRlVGltZSgneWVhcicsIHRoaXMudmlldy55ZWFyICsgMTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3TW9kZSA9PSAnbW9udGgnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdZZWFyID0gdGhpcy52aWV3LnllYXIgKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3WWVhciA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3WWVhciA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRWaWV3RGF0ZVRpbWUoJ3llYXInLCBuZXdZZWFyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmlld01vZGUgPT0gJ2RheScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9uZXdZZWFyID0gdGhpcy52aWV3LnllYXIgKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX25ld1llYXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9uZXdZZWFyID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3Lm1vbnRoICsgMSA9PSAxMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRWaWV3RGF0ZVRpbWUoJ3llYXInLCBfbmV3WWVhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFZpZXdEYXRlVGltZSgnbW9udGgnLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Vmlld0RhdGVUaW1lKCdtb250aCcsIHRoaXMudmlldy5tb250aCArIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3TW9kZSA9PSAneWVhcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRWaWV3RGF0ZVRpbWUoJ3llYXInLCB0aGlzLnZpZXcueWVhciAtIDEyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmlld01vZGUgPT0gJ21vbnRoJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX25ld1llYXIyID0gdGhpcy52aWV3LnllYXIgLSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX25ld1llYXIyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfbmV3WWVhcjIgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFZpZXdEYXRlVGltZSgneWVhcicsIF9uZXdZZWFyMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXdNb2RlID09ICdkYXknKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXcubW9udGggLSAxIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfbmV3WWVhcjMgPSB0aGlzLnZpZXcueWVhciAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX25ld1llYXIzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX25ld1llYXIzID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFZpZXdEYXRlVGltZSgneWVhcicsIF9uZXdZZWFyMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFZpZXdEYXRlVGltZSgnbW9udGgnLCAxMik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFZpZXdEYXRlVGltZSgnbW9udGgnLCB0aGlzLnZpZXcubW9udGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBkZXNjIGV2ZXJ5IHRpbWUgY2FsbGVkIHZpZXcgc3RhdGUgY2hhbmdlZCB0byBuZXh0IGluIHF1ZXVlXG4gICAgICAgICAqIEByZXR1cm4ge1N0YXRlfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc3dpdGNoVmlld01vZGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3dpdGNoVmlld01vZGUoKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdNb2RlSW5kZXggPSB0aGlzLnZpZXdNb2RlSW5kZXggKyAxID49IHRoaXMudmlld01vZGVMaXN0Lmxlbmd0aCA/IDAgOiB0aGlzLnZpZXdNb2RlSW5kZXggKyAxO1xuICAgICAgICAgICAgdGhpcy52aWV3TW9kZSA9IHRoaXMudmlld01vZGVMaXN0W3RoaXMudmlld01vZGVJbmRleF0gPyB0aGlzLnZpZXdNb2RlTGlzdFt0aGlzLnZpZXdNb2RlSW5kZXhdIDogdGhpcy52aWV3TW9kZUxpc3RbMF07XG4gICAgICAgICAgICB0aGlzLl9zZXRWaWV3RGF0ZVRpbWVVbml4KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyBzd2l0Y2ggdG8gc3BlY2lmaWVkIHZpZXcgbW9kZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmlld01vZGUgLSBhY2NlcHQgZGF0ZSwgbW9udGgsIHllYXJcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3N3aXRjaFZpZXdNb2RlVG8nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3dpdGNoVmlld01vZGVUbyh2aWV3TW9kZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmlld01vZGVMaXN0LmluZGV4T2Yodmlld01vZGUpID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlID0gdmlld01vZGU7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZUluZGV4ID0gdGhpcy52aWV3TW9kZUxpc3QuaW5kZXhPZih2aWV3TW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgY2FsbGVkIG9uIGRhdGUgc2VsZWN0XG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBhY2NlcHQgZGF0ZSwgbW9udGgsIHllYXIsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEByZXR1cm4ge1N0YXRlfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2V0U2VsZWN0ZWREYXRlVGltZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTZWxlY3RlZERhdGVUaW1lKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndW5peCc6XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2VsZWN0ZWQudW5peERhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBkID0gdGhpcy5tb2RlbC5QZXJzaWFuRGF0ZS5kYXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zZWxlY3RlZC55ZWFyID0gcGQueWVhcigpO1xuICAgICAgICAgICAgICAgICAgICB0aGF0LnNlbGVjdGVkLm1vbnRoID0gcGQubW9udGgoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zZWxlY3RlZC5kYXRlID0gcGQuZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGF0LnNlbGVjdGVkLmhvdXIgPSBwZC5ob3VyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2VsZWN0ZWQuaG91cjEyID0gcGQuZm9ybWF0KCdoaCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGF0LnNlbGVjdGVkLm1pbnV0ZSA9IHBkLm1pbnV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGF0LnNlbGVjdGVkLnNlY29uZCA9IHBkLnNlY29uZCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZC55ZWFyID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZC5tb250aCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZC5kYXRlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkLmhvdXIgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZC5taW51dGUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZC5zZWNvbmQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGF0Ll91cGRhdGVTZWxlY3RlZFVuaXgoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge1N0YXRlfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3VwZGF0ZVNlbGVjdGVkVW5peCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlU2VsZWN0ZWRVbml4KCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZC5kYXRlT2JqZWN0ID0gdGhpcy5tb2RlbC5QZXJzaWFuRGF0ZS5kYXRlKFt0aGlzLnNlbGVjdGVkLnllYXIsIHRoaXMuc2VsZWN0ZWQubW9udGgsIHRoaXMuc2VsZWN0ZWQuZGF0ZSwgdGhpcy52aWV3LmhvdXIsIHRoaXMudmlldy5taW51dGUsIHRoaXMudmlldy5zZWNvbmRdKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQudW5peERhdGUgPSB0aGlzLnNlbGVjdGVkLmRhdGVPYmplY3QudmFsdWVPZigpO1xuICAgICAgICAgICAgdGhpcy5tb2RlbC51cGRhdGVJbnB1dCh0aGlzLnNlbGVjdGVkLnVuaXhEYXRlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1N0YXRlfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3NldFZpZXdEYXRlVGltZVVuaXgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFZpZXdEYXRlVGltZVVuaXgoKSB7XG4gICAgICAgICAgICB2YXIgZGF5c0luTW9udGggPSBuZXcgcGVyc2lhbkRhdGUoKS5kYXlzSW5Nb250aCh0aGlzLnZpZXcueWVhciwgdGhpcy52aWV3Lm1vbnRoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuZGF0ZSA+IGRheXNJbk1vbnRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LmRhdGUgPSBkYXlzSW5Nb250aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudmlldy5kYXRlT2JqZWN0ID0gdGhpcy5tb2RlbC5QZXJzaWFuRGF0ZS5kYXRlKFt0aGlzLnZpZXcueWVhciwgdGhpcy52aWV3Lm1vbnRoLCB0aGlzLnZpZXcuZGF0ZSwgdGhpcy52aWV3LmhvdXIsIHRoaXMudmlldy5taW51dGUsIHRoaXMudmlldy5zZWNvbmRdKTtcbiAgICAgICAgICAgIHRoaXMudmlldy55ZWFyID0gdGhpcy52aWV3LmRhdGVPYmplY3QueWVhcigpO1xuICAgICAgICAgICAgdGhpcy52aWV3Lm1vbnRoID0gdGhpcy52aWV3LmRhdGVPYmplY3QubW9udGgoKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5kYXRlID0gdGhpcy52aWV3LmRhdGVPYmplY3QuZGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy52aWV3LmhvdXIgPSB0aGlzLnZpZXcuZGF0ZU9iamVjdC5ob3VyKCk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuaG91cjEyID0gdGhpcy52aWV3LmRhdGVPYmplY3QuZm9ybWF0KCdoaCcpO1xuICAgICAgICAgICAgdGhpcy52aWV3Lm1pbnV0ZSA9IHRoaXMudmlldy5kYXRlT2JqZWN0Lm1pbnV0ZSgpO1xuICAgICAgICAgICAgdGhpcy52aWV3LnNlY29uZCA9IHRoaXMudmlldy5kYXRlT2JqZWN0LnNlY29uZCgpO1xuICAgICAgICAgICAgdGhpcy52aWV3LnVuaXhEYXRlID0gdGhpcy52aWV3LmRhdGVPYmplY3QudmFsdWVPZigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSAtICBhY2NlcHQgZGF0ZSwgbW9udGgsIHllYXIsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHtTdGF0ZX1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NldFZpZXdEYXRlVGltZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWaWV3RGF0ZVRpbWUoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd1bml4JzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBkID0gdGhpcy5tb2RlbC5QZXJzaWFuRGF0ZS5kYXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi52aWV3LnllYXIgPSBwZC55ZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYudmlldy5tb250aCA9IHBkLm1vbnRoKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYudmlldy5kYXRlID0gcGQuZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnZpZXcuaG91ciA9IHBkLmhvdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi52aWV3Lm1pbnV0ZSA9IHBkLm1pbnV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnZpZXcuc2Vjb25kID0gcGQuc2Vjb25kKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcueWVhciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlldy5tb250aCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LmRhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlldy5ob3VyID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlldy5taW51dGUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LnNlY29uZCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NldFZpZXdEYXRlVGltZVVuaXgoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRlc2MgY2hhbmdlIG1lcmlkaWFuIHN0YXRlXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdtZXJpZGlhblRvZ2dsZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJpZGlhblRvZ2dsZSgpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGlmIChzZWxmLnZpZXcubWVyaWRpYW4gPT09ICdBTScpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnZpZXcubWVyaWRpYW4gPSAnUE0nO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLnZpZXcubWVyaWRpYW4gPT09ICdQTScpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnZpZXcubWVyaWRpYW4gPSAnQU0nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFN0YXRlO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlO1xuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogRG8gZXZlcnkgdGhpbmdzIGFib3V0IHRvb2xib3gsIGxpa2UgYXR0YWNoIGV2ZW50cyB0byB0b29sYm94IGVsZW1lbnRzXG4gKi9cbnZhciBUb29sYm94ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtEYXRlcGlja2VyfSBkYXRlcGlja2VyXG4gICAgICogQHJldHVybiB7VG9vbGJveH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUb29sYm94KG1vZGVsKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb29sYm94KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0RhdGVwaWNrZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgICAgIHRoaXMuX2F0dGFjaEV2ZW50cygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoVG9vbGJveCwgW3tcbiAgICAgICAga2V5OiAnX3RvZ2dsZUNhbGVuZGFydHlwZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdG9nZ2xlQ2FsZW5kYXJ0eXBlKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoYXQubW9kZWwub3B0aW9ucy5jYWxlbmRhcl8gPT0gJ3BlcnNpYW4nKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5tb2RlbC5vcHRpb25zLmNhbGVuZGFyXyA9ICdncmVnb3JpYW4nO1xuICAgICAgICAgICAgICAgIHRoYXQubW9kZWwub3B0aW9ucy5sb2NhbGVfID0gdGhpcy5tb2RlbC5vcHRpb25zLmNhbGVuZGFyLmdyZWdvcmlhbi5sb2NhbGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoYXQubW9kZWwub3B0aW9ucy5jYWxlbmRhcl8gPSAncGVyc2lhbic7XG4gICAgICAgICAgICAgICAgdGhhdC5tb2RlbC5vcHRpb25zLmxvY2FsZV8gPSB0aGlzLm1vZGVsLm9wdGlvbnMuY2FsZW5kYXIucGVyc2lhbi5sb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogYXR0YWNoIGFsbCBldmVudHMgYWJvdXQgdG9vbGJveFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2F0dGFjaEV2ZW50cycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYXR0YWNoRXZlbnRzKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgJChkb2N1bWVudCkub24oJ2NsaWNrJywgJyMnICsgdGhhdC5tb2RlbC52aWV3LmlkICsgJyAucHd0LWJ0bi10b2RheScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGF0Lm1vZGVsLnN0YXRlLnNldFNlbGVjdGVkRGF0ZVRpbWUoJ3VuaXgnLCBuZXcgRGF0ZSgpLnZhbHVlT2YoKSk7XG4gICAgICAgICAgICAgICAgdGhhdC5tb2RlbC5zdGF0ZS5zZXRWaWV3RGF0ZVRpbWUoJ3VuaXgnLCBuZXcgRGF0ZSgpLnZhbHVlT2YoKSk7XG4gICAgICAgICAgICAgICAgdGhhdC5tb2RlbC52aWV3LnJlUmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQGRlcHJlY2F0ZWRcbiAgICAgICAgICAgICAgICAgKiBAdG9kbyByZW1vdmUgdGhpc1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoYXQubW9kZWwub3B0aW9ucy50b29sYm94Lm9uVG9kYXkodGhhdC5tb2RlbCk7XG4gICAgICAgICAgICAgICAgdGhhdC5tb2RlbC5vcHRpb25zLnRvb2xib3gudG9kYXlCdXR0b24ub25Ub2RheSh0aGF0Lm1vZGVsKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAkKGRvY3VtZW50KS5vbignY2xpY2snLCAnIycgKyB0aGF0Lm1vZGVsLnZpZXcuaWQgKyAnIC5wd3QtYnRuLWNhbGVuZGFyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoYXQuX3RvZ2dsZUNhbGVuZGFydHlwZSgpO1xuICAgICAgICAgICAgICAgIHRoYXQubW9kZWwuc3RhdGUuc2V0U2VsZWN0ZWREYXRlVGltZSgndW5peCcsIHRoYXQubW9kZWwuc3RhdGUuc2VsZWN0ZWQudW5peERhdGUpO1xuICAgICAgICAgICAgICAgIHRoYXQubW9kZWwuc3RhdGUuc2V0Vmlld0RhdGVUaW1lKCd1bml4JywgdGhhdC5tb2RlbC5zdGF0ZS52aWV3LnVuaXhEYXRlKTtcbiAgICAgICAgICAgICAgICB0aGF0Lm1vZGVsLnZpZXcucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgdGhhdC5tb2RlbC5vcHRpb25zLnRvb2xib3guY2FsZW5kYXJTd2l0Y2gub25Td2l0Y2godGhhdC5tb2RlbCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgJChkb2N1bWVudCkub24oJ2NsaWNrJywgJyMnICsgdGhhdC5tb2RlbC52aWV3LmlkICsgJyAucHd0LWJ0bi1zdWJtaXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5tb2RlbC52aWV3LmhpZGUoKTtcbiAgICAgICAgICAgICAgICB0aGF0Lm1vZGVsLm9wdGlvbnMudG9vbGJveC5zdWJtaXRCdXR0b24ub25TdWJtaXQodGhhdC5tb2RlbCk7XG4gICAgICAgICAgICAgICAgdGhhdC5tb2RlbC5vcHRpb25zLm9uSGlkZSh0aGlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRvb2xib3g7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gVG9vbGJveDtcblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgVGVtcGxhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIEhlbHBlciA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgTXVzdGFjaGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxuLyoqXG4gKiBBcyBpdHMgbmFtZSBzdWdnZXN0cywgYWxsIHJlbmRlcmluZyB3b3JrcyBkbyBpbiB0aGlzIG9iamVjdFxuICovXG5cbnZhciBWaWV3ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0RhdGVwaWNrZXJ9IG1vZGVsXG4gICAgICogQHJldHVybiB7Vmlld31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBWaWV3KG1vZGVsKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWaWV3KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueWVhcnNWaWV3Q291bnQgPSAxMjtcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0RhdGVwaWNrZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtudWxsfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW5kZXJlZCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtudWxsfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy4kY29udGFpbmVyID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSAncGVyc2lhbkRhdGVJbnN0YW5jZS0nICsgcGFyc2VJbnQoTWF0aC5yYW5kb20oMTAwKSAqIDEwMDApO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMubW9kZWwuc3RhdGUudWkuaXNJbmxpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lciA9ICQoJzxkaXYgIGlkPVwiJyArIHRoaXMuaWQgKyAnXCIgY2xhc3M9XCJkYXRlcGlja2VyLWNvbnRhaW5lci1pbmxpbmVcIj48L2Rpdj4nKS5hcHBlbmRUbyh0aGF0Lm1vZGVsLmlucHV0RWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiRjb250YWluZXIgPSAkKCc8ZGl2ICBpZD1cIicgKyB0aGlzLmlkICsgJ1wiIGNsYXNzPVwiZGF0ZXBpY2tlci1jb250YWluZXJcIj48L2Rpdj4nKS5hcHBlbmRUbygnYm9keScpO1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICB0aGlzLnNldFBpY2tlckJveFBvc2l0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLmFkZENvbXBhdGliaWxpdHlDbGFzcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXNjIGFkZCBjc3MgY2xhc3MgdG8gaGFuZGxlIGNvbXBhdGliaWxpdHkgdWkgdGhpbmdzXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhWaWV3LCBbe1xuICAgICAgICBrZXk6ICdhZGRDb21wYXRpYmlsaXR5Q2xhc3MnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQ29tcGF0aWJpbGl0eUNsYXNzKCkge1xuICAgICAgICAgICAgaWYgKEhlbHBlci5pc01vYmlsZSAmJiB0aGlzLm1vZGVsLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci5hZGRDbGFzcygncHd0LW1vYmlsZS12aWV3Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgcmVtb3ZlIGRhdGVwaWNrZXIgY29udGFpbmVyIGVsZW1lbnQgZnJvbSBkb21cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyBzZXQgZGF0ZXBpY2tlciBjb250YWluZXIgZWxlbWVudCBiYXNlZCBvbiA8aW5wdXQvPiBlbGVtZW50IHBvc2l0aW9uXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZXRQaWNrZXJCb3hQb3NpdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQaWNrZXJCb3hQb3NpdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFBvc2l0aW9uID0gdGhpcy5tb2RlbC5pbnB1dC5nZXRJbnB1dFBvc2l0aW9uKCksXG4gICAgICAgICAgICAgICAgaW5wdXRTaXplID0gdGhpcy5tb2RlbC5pbnB1dC5nZXRJbnB1dFNpemUoKTtcblxuICAgICAgICAgICAgaWYgKEhlbHBlci5pc01vYmlsZSAmJiB0aGlzLm1vZGVsLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMubW9kZWwub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGlucHV0UG9zaXRpb24ubGVmdCArICdweCcsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogaW5wdXRTaXplLmhlaWdodCArIGlucHV0UG9zaXRpb24udG9wICsgJ3B4J1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRjb250YWluZXIuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogdGhpcy5tb2RlbC5vcHRpb25zLnBvc2l0aW9uWzFdICsgaW5wdXRQb3NpdGlvbi5sZWZ0ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiB0aGlzLm1vZGVsLm9wdGlvbnMucG9zaXRpb25bMF0gKyBpbnB1dFBvc2l0aW9uLnRvcCArICdweCdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyBzaG93IGRhdGVwaWNrZXIgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3Nob3cnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci5yZW1vdmVDbGFzcygncHd0LWhpZGUnKTtcbiAgICAgICAgICAgIHRoaXMuc2V0UGlja2VyQm94UG9zaXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyBoaWRlIGRhdGVwaWNrZXIgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2hpZGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci5hZGRDbGFzcygncHd0LWhpZGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyB0b2dnbGUgZGF0ZXBpY2tlciBjb250YWluZXIgZWxlbWVudFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9nZ2xlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci50b2dnbGVDbGFzcygncHd0LWhpZGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyByZXR1cm4gbmF2aWdhdG9yIHN3aXRjaCB0ZXh0XG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIC0gIGFjY2VwdCBkYXksIG1vbnRoLCB5ZWFyXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19nZXROYXZTd2l0Y2hUZXh0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXROYXZTd2l0Y2hUZXh0KGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlbC5zdGF0ZS52aWV3TW9kZSA9PSAnZGF5Jykge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IHRoaXMubW9kZWwub3B0aW9ucy5kYXlQaWNrZXIudGl0bGVGb3JtYXR0ZXIuY2FsbCh0aGlzLCBkYXRhLnllYXIsIGRhdGEubW9udGgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1vZGVsLnN0YXRlLnZpZXdNb2RlID09ICdtb250aCcpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzLm1vZGVsLm9wdGlvbnMubW9udGhQaWNrZXIudGl0bGVGb3JtYXR0ZXIuY2FsbCh0aGlzLCBkYXRhLmRhdGVPYmplY3QudmFsdWVPZigpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlbC5zdGF0ZS52aWV3TW9kZSA9PSAneWVhcicpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzLm1vZGVsLm9wdGlvbnMueWVhclBpY2tlci50aXRsZUZvcm1hdHRlci5jYWxsKHRoaXMsIGRhdGEueWVhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjIGNoZWNrIHllYXIgaXMgYWNjZXNzaWJsZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0geWVhciAtIHllYXIgbnVtYmVyXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGVja1llYXJBY2Nlc3MnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tZZWFyQWNjZXNzKHllYXIpIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kZWwuc3RhdGUuZmlsZXRyZWREYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0WWVhciA9IHRoaXMubW9kZWwuc3RhdGUuZmlsdGVyRGF0ZS5zdGFydC55ZWFyLFxuICAgICAgICAgICAgICAgICAgICBlbmRZZWFyID0gdGhpcy5tb2RlbC5zdGF0ZS5maWx0ZXJEYXRlLmVuZC55ZWFyO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydFllYXIgJiYgeWVhciA8IHN0YXJ0WWVhcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbmRZZWFyICYmIHllYXIgPiBlbmRZZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwub3B0aW9ucy5jaGVja1llYXIoeWVhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIHZpZXdTdGF0ZVxuICAgICAgICAgKiBAcmV0dXJuIHt7ZW5hYmxlZDogYm9vbGVhbiwgdmlld01vZGU6IGJvb2xlYW4sIGxpc3Q6IEFycmF5fX1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19nZXRZZWFyVmlld01vZGVsJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRZZWFyVmlld01vZGVsKHZpZXdTdGF0ZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIGlzRW5hYmxlZCA9IHRoaXMubW9kZWwub3B0aW9ucy55ZWFyUGlja2VyLmVuYWJsZWQ7XG4gICAgICAgICAgICAvLyBNYWtlIHBlcmZvcm1hbmNlIGJldHRlclxuICAgICAgICAgICAgaWYgKCFpc0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBHZW5lcmF0ZSB5ZWFycyBsaXN0IGJhc2VkIG9uIHZpZXdTdGF0ZSB5ZWFyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIFsnMTM4MCcsbisxMiwnMTM5MiddXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBsaXN0ID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShBcnJheSh0aGlzLnllYXJzVmlld0NvdW50KS5rZXlzKCkpKS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICsgcGFyc2VJbnQodmlld1N0YXRlLnllYXIgLyBfdGhpcy55ZWFyc1ZpZXdDb3VudCkgKiBfdGhpcy55ZWFyc1ZpZXdDb3VudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBHZW5lcmF0ZSB5ZWFycyBvYmplY3QgYmFzZWQgb24gbGlzdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgeWVhcnNNb2RlbCA9IFtdLFxuICAgICAgICAgICAgICAgIHllYXJTdHIgPSB0aGlzLm1vZGVsLlBlcnNpYW5EYXRlLmRhdGUoKTtcbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGxpc3RbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgeWVhclN0ci55ZWFyKFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIHllYXJzTW9kZWwucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogeWVhclN0ci5mb3JtYXQoJ1lZWVknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRoaXMuY2hlY2tZZWFyQWNjZXNzKGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVllYXI6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZDogdGhpcy5tb2RlbC5zdGF0ZS5zZWxlY3RlZC55ZWFyID09IGlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiBpc0VuYWJsZWQsXG4gICAgICAgICAgICAgICAgdmlld01vZGU6IHRoaXMubW9kZWwuc3RhdGUudmlld01vZGUgPT0gJ3llYXInLFxuICAgICAgICAgICAgICAgIGxpc3Q6IHllYXJzTW9kZWxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgY2hlY2sgbW9udGggaXMgYWNjZXNzaWJsZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbW9udGggLSBtb250aCBudW1iZXJcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoZWNrTW9udGhBY2Nlc3MnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tNb250aEFjY2Vzcyhtb250aCkge1xuICAgICAgICAgICAgbW9udGggPSBtb250aCArIDE7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gdHJ1ZSxcbiAgICAgICAgICAgICAgICB5ID0gdGhpcy5tb2RlbC5zdGF0ZS52aWV3LnllYXI7XG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlbC5zdGF0ZS5maWxldHJlZERhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRNb250aCA9IHRoaXMubW9kZWwuc3RhdGUuZmlsdGVyRGF0ZS5zdGFydC5tb250aCxcbiAgICAgICAgICAgICAgICAgICAgZW5kTW9udGggPSB0aGlzLm1vZGVsLnN0YXRlLmZpbHRlckRhdGUuZW5kLm1vbnRoLFxuICAgICAgICAgICAgICAgICAgICBzdGFydFllYXIgPSB0aGlzLm1vZGVsLnN0YXRlLmZpbHRlckRhdGUuc3RhcnQueWVhcixcbiAgICAgICAgICAgICAgICAgICAgZW5kWWVhciA9IHRoaXMubW9kZWwuc3RhdGUuZmlsdGVyRGF0ZS5lbmQueWVhcjtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRNb250aCAmJiBlbmRNb250aCAmJiAoeSA9PSBlbmRZZWFyICYmIG1vbnRoID4gZW5kTW9udGggfHwgeSA+IGVuZFllYXIpIHx8IHkgPT0gc3RhcnRZZWFyICYmIG1vbnRoIDwgc3RhcnRNb250aCB8fCB5IDwgc3RhcnRZZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVuZE1vbnRoICYmICh5ID09IGVuZFllYXIgJiYgbW9udGggPiBlbmRNb250aCB8fCB5ID4gZW5kWWVhcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnRNb250aCAmJiAoeSA9PSBzdGFydFllYXIgJiYgbW9udGggPCBzdGFydE1vbnRoIHx8IHkgPCBzdGFydFllYXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwub3B0aW9ucy5jaGVja01vbnRoKG1vbnRoLCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcmV0dXJuIHt7ZW5hYmxlZDogYm9vbGVhbiwgdmlld01vZGU6IGJvb2xlYW4sIGxpc3Q6IEFycmF5fX1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19nZXRNb250aFZpZXdNb2RlbCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0TW9udGhWaWV3TW9kZWwoKSB7XG4gICAgICAgICAgICB2YXIgaXNFbmFsZWQgPSB0aGlzLm1vZGVsLm9wdGlvbnMubW9udGhQaWNrZXIuZW5hYmxlZDtcbiAgICAgICAgICAgIC8vIE1ha2UgcGVyZm9ybWFuY2UgYmV0dGVyXG4gICAgICAgICAgICBpZiAoIWlzRW5hbGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbW9udGhNb2RlbCA9IFtdLFxuICAgICAgICAgICAgICAgIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IHRoYXQubW9kZWwuUGVyc2lhbkRhdGUuZGF0ZSgpLnJhbmdlTmFtZSgpLm1vbnRocy5lbnRyaWVzKClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9zdGVwMiR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMi52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IF9zdGVwMiR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoID0gX3N0ZXAyJHZhbHVlWzFdO1xuXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoTW9kZWwucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogbW9udGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0aGlzLmNoZWNrTW9udGhBY2Nlc3MoaW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgeWVhcjogdGhpcy5tb2RlbC5zdGF0ZS52aWV3LnllYXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhTW9udGg6IGluZGV4ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiB0aGlzLm1vZGVsLnN0YXRlLnNlbGVjdGVkLnllYXIgPT0gdGhpcy5tb2RlbC5zdGF0ZS52aWV3LnllYXIgJiYgdGhpcy5tb2RlbC5zdGF0ZS5zZWxlY3RlZC5tb250aCA9PSBpbmRleCArIDFcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZW5hYmxlZDogaXNFbmFsZWQsXG4gICAgICAgICAgICAgICAgdmlld01vZGU6IHRoaXMubW9kZWwuc3RhdGUudmlld01vZGUgPT0gJ21vbnRoJyxcbiAgICAgICAgICAgICAgICBsaXN0OiBtb250aE1vZGVsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjIGNoZWNrIGRheSBpcyBhY2Nlc3NpYmxlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aGlzVW5peCAtIG1vbnRoIG51bWJlclxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hlY2tEYXlBY2Nlc3MnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tEYXlBY2Nlc3ModW5peHRpbWVzcGFuKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlbGYubWluRGF0ZSA9IHRoaXMubW9kZWwub3B0aW9ucy5taW5EYXRlO1xuICAgICAgICAgICAgc2VsZi5tYXhEYXRlID0gdGhpcy5tb2RlbC5vcHRpb25zLm1heERhdGU7XG5cbiAgICAgICAgICAgIGlmIChzZWxmLm1vZGVsLnN0YXRlLmZpbGV0cmVkRGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLm1pbkRhdGUgJiYgc2VsZi5tYXhEYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubWluRGF0ZSA9IHNlbGYubW9kZWwuUGVyc2lhbkRhdGUuZGF0ZShzZWxmLm1pbkRhdGUpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tYXhEYXRlID0gc2VsZi5tb2RlbC5QZXJzaWFuRGF0ZS5kYXRlKHNlbGYubWF4RGF0ZSkuZW5kT2YoJ2RheScpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodW5peHRpbWVzcGFuID49IHNlbGYubWluRGF0ZSAmJiB1bml4dGltZXNwYW4gPD0gc2VsZi5tYXhEYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLm1pbkRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5taW5EYXRlID0gc2VsZi5tb2RlbC5QZXJzaWFuRGF0ZS5kYXRlKHNlbGYubWluRGF0ZSkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodW5peHRpbWVzcGFuIDw9IHNlbGYubWluRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLm1heERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tYXhEYXRlID0gc2VsZi5tb2RlbC5QZXJzaWFuRGF0ZS5kYXRlKHNlbGYubWF4RGF0ZSkuZW5kT2YoJ2RheScpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVuaXh0aW1lc3BhbiA+PSBzZWxmLm1heERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5tb2RlbC5vcHRpb25zLmNoZWNrRGF0ZSh1bml4dGltZXNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEByZXR1cm4ge29iamVjdH1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19nZXREYXlWaWV3TW9kZWwnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERheVZpZXdNb2RlbCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGVsLnN0YXRlLnZpZXdNb2RlICE9ICdkYXknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaXNFbmFibGVkID0gdGhpcy5tb2RlbC5vcHRpb25zLmRheVBpY2tlci5lbmFibGVkO1xuICAgICAgICAgICAgLy8gTWFrZSBwZXJmb3JtYW5jZSBiZXR0ZXJcbiAgICAgICAgICAgIGlmICghaXNFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2xvZygnaWYgeW91IHNlZSB0aGlzIG1hbnkgdGltZSB5b3VyIGNvZGUgaGFzIHBlcmZvcm1hbmNlIGlzc3VlJyk7XG4gICAgICAgICAgICB2YXIgdmlld01vbnRoID0gdGhpcy5tb2RlbC5zdGF0ZS52aWV3Lm1vbnRoLFxuICAgICAgICAgICAgICAgIHZpZXdZZWFyID0gdGhpcy5tb2RlbC5zdGF0ZS52aWV3LnllYXI7XG4gICAgICAgICAgICB2YXIgcGRhdGVJbnN0YW5jZSA9IHRoaXMubW9kZWwuUGVyc2lhbkRhdGUuZGF0ZSgpLFxuICAgICAgICAgICAgICAgIGRheXNDb3VudCA9IHBkYXRlSW5zdGFuY2UuZGF5c0luTW9udGgodmlld1llYXIsIHZpZXdNb250aCksXG4gICAgICAgICAgICAgICAgZmlyc3RXZWVrRGF5T2ZNb250aCA9IHBkYXRlSW5zdGFuY2UuZ2V0Rmlyc3RXZWVrRGF5T2ZNb250aCh2aWV3WWVhciwgdmlld01vbnRoKSAtIDEsXG4gICAgICAgICAgICAgICAgb3V0cHV0TGlzdCA9IFtdLFxuICAgICAgICAgICAgICAgIGRheXNMaXN0aW5kZXggPSAwLFxuICAgICAgICAgICAgICAgIG5leHRNb250aExpc3RJbmRleCA9IDAsXG4gICAgICAgICAgICAgICAgZGF5c01hdHJpeCA9IFtbJ251bGwnLCAnbnVsbCcsICdudWxsJywgJ251bGwnLCAnbnVsbCcsICdudWxsJywgJ251bGwnXSwgWydudWxsJywgJ251bGwnLCAnbnVsbCcsICdudWxsJywgJ251bGwnLCAnbnVsbCcsICdudWxsJ10sIFsnbnVsbCcsICdudWxsJywgJ251bGwnLCAnbnVsbCcsICdudWxsJywgJ251bGwnLCAnbnVsbCddLCBbJ251bGwnLCAnbnVsbCcsICdudWxsJywgJ251bGwnLCAnbnVsbCcsICdudWxsJywgJ251bGwnXSwgWydudWxsJywgJ251bGwnLCAnbnVsbCcsICdudWxsJywgJ251bGwnLCAnbnVsbCcsICdudWxsJ10sIFsnbnVsbCcsICdudWxsJywgJ251bGwnLCAnbnVsbCcsICdudWxsJywgJ251bGwnLCAnbnVsbCddXTtcblxuICAgICAgICAgICAgdmFyIGFub3RoZXJDYWxlbmRhciA9IHRoaXMuX2dldEFub3RoZXJDYWxlbmRhcigpO1xuICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjMgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IGRheXNNYXRyaXguZW50cmllcygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAzOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gKF9zdGVwMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfc3RlcDMkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDMudmFsdWUsIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93SW5kZXggPSBfc3RlcDMkdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXlzUm93ID0gX3N0ZXAzJHZhbHVlWzFdO1xuXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dExpc3Rbcm93SW5kZXhdID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yNCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNCA9IGRheXNSb3cuZW50cmllcygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA0OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gKF9zdGVwNCA9IF9pdGVyYXRvcjQubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9zdGVwNCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNC52YWx1ZSwgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheUluZGV4ID0gX3N0ZXA0JHZhbHVlWzBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGNlZERhdGUgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyTW9udGggPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGhvdXIgMTIgcHJldmVudCBpc3N1ZXMgd2l0aCBEU1QgdGltZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93SW5kZXggPT09IDAgJiYgZGF5SW5kZXggPCBmaXJzdFdlZWtEYXlPZk1vbnRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGNlZERhdGUgPSB0aGlzLm1vZGVsLnN0YXRlLnZpZXcuZGF0ZU9iamVjdC5zdGFydE9mKCdtb250aCcpLmhvdXIoMTIpLnN1YnRyYWN0KCdkYXlzJywgZmlyc3RXZWVrRGF5T2ZNb250aCAtIGRheUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJNb250aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyb3dJbmRleCA9PT0gMCAmJiBkYXlJbmRleCA+PSBmaXJzdFdlZWtEYXlPZk1vbnRoIHx8IHJvd0luZGV4IDw9IDUgJiYgZGF5c0xpc3RpbmRleCA8IGRheXNDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXlzTGlzdGluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGNlZERhdGUgPSBuZXcgcGVyc2lhbkRhdGUoW3RoaXMubW9kZWwuc3RhdGUudmlldy55ZWFyLCB0aGlzLm1vZGVsLnN0YXRlLnZpZXcubW9udGgsIGRheXNMaXN0aW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJNb250aCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRNb250aExpc3RJbmRleCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxjZWREYXRlID0gdGhpcy5tb2RlbC5zdGF0ZS52aWV3LmRhdGVPYmplY3QuZW5kT2YoJ21vbnRoJykuaG91cigxMikuYWRkKCdkYXlzJywgbmV4dE1vbnRoTGlzdEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJNb250aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dExpc3Rbcm93SW5kZXhdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogY2FsY2VkRGF0ZS5mb3JtYXQoJ0QnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0ZXJDYWxUaXRsZTogbmV3IHBlcnNpYW5EYXRlKGNhbGNlZERhdGUudmFsdWVPZigpKS50b0NhbGVuZGFyKGFub3RoZXJDYWxlbmRhclswXSkudG9Mb2NhbGUoYW5vdGhlckNhbGVuZGFyWzFdKS5mb3JtYXQoJ0QnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YURhdGU6IFtjYWxjZWREYXRlLnllYXIoKSwgY2FsY2VkRGF0ZS5tb250aCgpLCBjYWxjZWREYXRlLmRhdGUoKV0uam9pbignLCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVW5peDogY2FsY2VkRGF0ZS5ob3VyKDEyKS52YWx1ZU9mKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyTW9udGg6IG90aGVyTW9udGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IG1ha2UgY29uZmlndXJhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRoaXMuY2hlY2tEYXlBY2Nlc3MoY2FsY2VkRGF0ZS52YWx1ZU9mKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yNCA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCAmJiBfaXRlcmF0b3I0LnJldHVybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3I0LnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjMgPSBlcnI7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjMucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZW5hYmxlZDogaXNFbmFibGVkLFxuICAgICAgICAgICAgICAgIHZpZXdNb2RlOiB0aGlzLm1vZGVsLnN0YXRlLnZpZXdNb2RlID09ICdkYXknLFxuICAgICAgICAgICAgICAgIGxpc3Q6IG91dHB1dExpc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ21hcmtTZWxlY3RlZERheScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtYXJrU2VsZWN0ZWREYXkoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSB0aGlzLm1vZGVsLnN0YXRlLnNlbGVjdGVkO1xuICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLmZpbmQoJy50YWJsZS1kYXlzIHRkJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCQodGhpcykuZGF0YSgnZGF0ZScpID09IFtzZWxlY3RlZC55ZWFyLCBzZWxlY3RlZC5tb250aCwgc2VsZWN0ZWQuZGF0ZV0uam9pbignLCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcykuYWRkQ2xhc3MoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5yZW1vdmVDbGFzcygnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbWFya1RvZGF5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hcmtUb2RheSgpIHtcbiAgICAgICAgICAgIHZhciB0b2RheSA9IG5ldyBwZXJzaWFuRGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLmZpbmQoJy50YWJsZS1kYXlzIHRkJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCQodGhpcykuZGF0YSgnZGF0ZScpID09IFt0b2RheS55ZWFyKCksIHRvZGF5Lm1vbnRoKCksIHRvZGF5LmRhdGUoKV0uam9pbignLCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcykuYWRkQ2xhc3MoJ3RvZGF5Jyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5yZW1vdmVDbGFzcygndG9kYXknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcmV0dXJuIHt7ZW5hYmxlZDogYm9vbGVhbiwgaG91cjoge3RpdGxlLCBlbmFibGVkOiBib29sZWFufSwgbWludXRlOiB7dGl0bGUsIGVuYWJsZWQ6IGJvb2xlYW59LCBzZWNvbmQ6IHt0aXRsZSwgZW5hYmxlZDogYm9vbGVhbn0sIG1lcmlkaWFuOiB7dGl0bGU6IChtZXJpZGlhbnx7dGl0bGUsIGVuYWJsZWR9fENsYXNzRGF0ZXBpY2tlci5DbGFzc0NvbmZpZy50aW1lUGlja2VyLm1lcmlkaWFufHtlbmFibGVkfXxzdHJpbmd8c3RyaW5nKSwgZW5hYmxlZDogYm9vbGVhbn19fVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2dldFRpbWVWaWV3TW9kZWwnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFRpbWVWaWV3TW9kZWwoKSB7XG5cbiAgICAgICAgICAgIHZhciBpc0VuYWJsZWQgPSB0aGlzLm1vZGVsLm9wdGlvbnMudGltZVBpY2tlci5lbmFibGVkO1xuICAgICAgICAgICAgLy8gTWFrZSBwZXJmb3JtYW5jZSBiZXR0ZXJcbiAgICAgICAgICAgIGlmICghaXNFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaG91clRpdGxlID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kZWwub3B0aW9ucy50aW1lUGlja2VyLm1lcmlkaWFuLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBob3VyVGl0bGUgPSB0aGlzLm1vZGVsLnN0YXRlLnZpZXcuZGF0ZU9iamVjdC5mb3JtYXQoJ2hoJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhvdXJUaXRsZSA9IHRoaXMubW9kZWwuc3RhdGUudmlldy5kYXRlT2JqZWN0LmZvcm1hdCgnSEgnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiBpc0VuYWJsZWQsXG4gICAgICAgICAgICAgICAgaG91cjoge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogaG91clRpdGxlLFxuICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0aGlzLm1vZGVsLm9wdGlvbnMudGltZVBpY2tlci5ob3VyLmVuYWJsZWRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1pbnV0ZToge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGhpcy5tb2RlbC5zdGF0ZS52aWV3LmRhdGVPYmplY3QuZm9ybWF0KCdtbScpLFxuICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0aGlzLm1vZGVsLm9wdGlvbnMudGltZVBpY2tlci5taW51dGUuZW5hYmxlZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2Vjb25kOiB7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aGlzLm1vZGVsLnN0YXRlLnZpZXcuZGF0ZU9iamVjdC5mb3JtYXQoJ3NzJyksXG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRoaXMubW9kZWwub3B0aW9ucy50aW1lUGlja2VyLnNlY29uZC5lbmFibGVkXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtZXJpZGlhbjoge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGhpcy5tb2RlbC5zdGF0ZS52aWV3LmRhdGVPYmplY3QuZm9ybWF0KCdhJyksXG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRoaXMubW9kZWwub3B0aW9ucy50aW1lUGlja2VyLm1lcmlkaWFuLmVuYWJsZWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge3tlbmFibGVkOiBib29sZWFuLCBsaXN0OiAoKnxBcnJheSl9fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2dldFdlZWtWaWV3TW9kZWwnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFdlZWtWaWV3TW9kZWwoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgbGlzdDogdGhpcy5tb2RlbC5QZXJzaWFuRGF0ZS5kYXRlKCkucmFuZ2VOYW1lKCkud2Vla2RheXNNaW5cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0Q3NzQ2xhc3MnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q3NzQ2xhc3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMubW9kZWwuc3RhdGUudWkuaXNJbmxpbmUgPyAnZGF0ZXBpY2tlci1wbG90LWFyZWEtaW5saW5lLXZpZXcnIDogJycsICF0aGlzLm1vZGVsLm9wdGlvbnMudGltZVBpY2tlci5tZXJpZGlhbi5lbmFibGVkID8gJ2RhdGVwaWNrZXItc3RhdGUtbm8tbWVyaWRpYW4nIDogJycsIHRoaXMubW9kZWwub3B0aW9ucy5vbmx5VGltZVBpY2tlciA/ICdkYXRlcGlja2VyLXN0YXRlLW9ubHktdGltZScgOiAnJywgIXRoaXMubW9kZWwub3B0aW9ucy50aW1lUGlja2VyLnNlY29uZC5lbmFibGVkID8gJ2RhdGVwaWNrZXItc3RhdGUtbm8tc2Vjb25kJyA6ICcnLCB0aGlzLm1vZGVsLm9wdGlvbnMuY2FsZW5kYXJfID09ICdncmVnb3JpYW4nID8gJ2RhdGVwaWNrZXItZ3JlZ29yaWFuJyA6ICdkYXRlcGlja2VyLXBlcnNpYW4nXS5qb2luKCcgJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGRhdGFcbiAgICAgICAgICogQHJldHVybiB7Kn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldFZpZXdNb2RlbCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWV3TW9kZWwoZGF0YSkge1xuICAgICAgICAgICAgdmFyIGFub3RoZXJDYWxlbmRhciA9IHRoaXMuX2dldEFub3RoZXJDYWxlbmRhcigpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwbG90SWQ6ICcnLFxuICAgICAgICAgICAgICAgIG5hdmlnYXRvcjoge1xuICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0aGlzLm1vZGVsLm9wdGlvbnMubmF2aWdhdG9yLmVuYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuX2dldE5hdlN3aXRjaFRleHQoZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdGhpcy5tb2RlbC5vcHRpb25zLm5hdmlnYXRvci50ZXh0XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZWxlY3RlZDogdGhpcy5tb2RlbC5zdGF0ZS5zZWxlY3RlZCxcbiAgICAgICAgICAgICAgICB0aW1lOiB0aGlzLl9nZXRUaW1lVmlld01vZGVsKGRhdGEpLFxuICAgICAgICAgICAgICAgIGRheXM6IHRoaXMuX2dldERheVZpZXdNb2RlbChkYXRhKSxcbiAgICAgICAgICAgICAgICB3ZWVrZGF5czogdGhpcy5fZ2V0V2Vla1ZpZXdNb2RlbChkYXRhKSxcbiAgICAgICAgICAgICAgICBtb250aDogdGhpcy5fZ2V0TW9udGhWaWV3TW9kZWwoZGF0YSksXG4gICAgICAgICAgICAgICAgeWVhcjogdGhpcy5fZ2V0WWVhclZpZXdNb2RlbChkYXRhKSxcbiAgICAgICAgICAgICAgICB0b29sYm94OiB0aGlzLm1vZGVsLm9wdGlvbnMudG9vbGJveCxcbiAgICAgICAgICAgICAgICBjc3NDbGFzczogdGhpcy5nZXRDc3NDbGFzcygpLFxuICAgICAgICAgICAgICAgIG9ubHlUaW1lUGlja2VyOiB0aGlzLm1vZGVsLm9wdGlvbnMub25seVRpbWVQaWNrZXIsXG4gICAgICAgICAgICAgICAgYWx0Q2FsZW5kYXJTaG93SGludDogdGhpcy5tb2RlbC5vcHRpb25zLmNhbGVuZGFyW2Fub3RoZXJDYWxlbmRhclswXV0uc2hvd0hpbnQsXG4gICAgICAgICAgICAgICAgY2FsZW5kYXJTd2l0Y2hUZXh0OiB0aGlzLm1vZGVsLnN0YXRlLnZpZXcuZGF0ZU9iamVjdC50b0NhbGVuZGFyKGFub3RoZXJDYWxlbmRhclswXSkudG9Mb2NhbGUoYW5vdGhlckNhbGVuZGFyWzFdKS5mb3JtYXQodGhpcy5tb2RlbC5vcHRpb25zLnRvb2xib3guY2FsZW5kYXJTd2l0Y2guZm9ybWF0KSxcbiAgICAgICAgICAgICAgICB0b2RheUJ1dHRvblRleHQ6IHRoaXMuX2dldEJ1dHRvblRleHQoKS50b2RheUJ1dHRvbnRleHQsXG4gICAgICAgICAgICAgICAgc3VibWl0QnV0dG9uVGV4dDogdGhpcy5fZ2V0QnV0dG9uVGV4dCgpLnN1Ym1pdEJ1dHRvblRleHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19nZXRCdXR0b25UZXh0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRCdXR0b25UZXh0KCkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kZWwub3B0aW9ucy5sb2NhbGVfID09ICdmYScpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQudG9kYXlCdXR0b250ZXh0ID0gdGhpcy5tb2RlbC5vcHRpb25zLnRvb2xib3gudG9kYXlCdXR0b24udGV4dC5mYTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3VibWl0QnV0dG9uVGV4dCA9IHRoaXMubW9kZWwub3B0aW9ucy50b29sYm94LnN1Ym1pdEJ1dHRvbi50ZXh0LmZhO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1vZGVsLm9wdGlvbnMubG9jYWxlXyA9PSAnZW4nKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnRvZGF5QnV0dG9udGV4dCA9IHRoaXMubW9kZWwub3B0aW9ucy50b29sYm94LnRvZGF5QnV0dG9uLnRleHQuZW47XG4gICAgICAgICAgICAgICAgb3V0cHV0LnN1Ym1pdEJ1dHRvblRleHQgPSB0aGlzLm1vZGVsLm9wdGlvbnMudG9vbGJveC5zdWJtaXRCdXR0b24udGV4dC5lbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19nZXRBbm90aGVyQ2FsZW5kYXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEFub3RoZXJDYWxlbmRhcigpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBjYWwgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgbG9jID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHRoYXQubW9kZWwub3B0aW9ucy5jYWxlbmRhcl8gPT0gJ3BlcnNpYW4nKSB7XG4gICAgICAgICAgICAgICAgY2FsID0gJ2dyZWdvcmlhbic7XG4gICAgICAgICAgICAgICAgbG9jID0gdGhhdC5tb2RlbC5vcHRpb25zLmNhbGVuZGFyLmdyZWdvcmlhbi5sb2NhbGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbCA9ICdwZXJzaWFuJztcbiAgICAgICAgICAgICAgICBsb2MgPSB0aGF0Lm1vZGVsLm9wdGlvbnMuY2FsZW5kYXIucGVyc2lhbi5sb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW2NhbCwgbG9jXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyByZW5kZXIgdGltZXMgYXJlYSwgcHJldmVudCBwZXJmb3JtYW5jZSBpc3N1ZSB3aXRoIHNjcm9sbCBhbmQgdGltZSBzZWN0aW9uXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZW5kZXJUaW1lUGFydGlhbCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJUaW1lUGFydGlhbCgpIHtcbiAgICAgICAgICAgIHZhciB0aW1lVmlld01vZGVsID0gdGhpcy5fZ2V0VGltZVZpZXdNb2RlbCh0aGlzLm1vZGVsLnN0YXRlLnZpZXcpO1xuICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLmZpbmQoJ1tkYXRhLXRpbWUta2V5PVwiaG91clwiXSBpbnB1dCcpLnZhbCh0aW1lVmlld01vZGVsLmhvdXIudGl0bGUpO1xuICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLmZpbmQoJ1tkYXRhLXRpbWUta2V5PVwibWludXRlXCJdIGlucHV0JykudmFsKHRpbWVWaWV3TW9kZWwubWludXRlLnRpdGxlKTtcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci5maW5kKCdbZGF0YS10aW1lLWtleT1cInNlY29uZFwiXSBpbnB1dCcpLnZhbCh0aW1lVmlld01vZGVsLnNlY29uZC50aXRsZSk7XG4gICAgICAgICAgICB0aGlzLiRjb250YWluZXIuZmluZCgnW2RhdGEtdGltZS1rZXk9XCJtZXJpZGlhblwiXSBpbnB1dCcpLnZhbCh0aW1lVmlld01vZGVsLm1lcmlkaWFuLnRpdGxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmVuZGVyIGRhdGVwaWNrZXIgdmlldyBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZW5kZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLm1vZGVsLnN0YXRlLnZpZXc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBIZWxwZXIuZGVidWcodGhpcywgJ3JlbmRlcicpO1xuICAgICAgICAgICAgTXVzdGFjaGUucGFyc2UoVGVtcGxhdGUpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlZCA9ICQoTXVzdGFjaGUucmVuZGVyKHRoaXMubW9kZWwub3B0aW9ucy50ZW1wbGF0ZSwgdGhpcy5nZXRWaWV3TW9kZWwoZGF0YSkpKTtcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci5lbXB0eSgpLmFwcGVuZCh0aGlzLnJlbmRlcmVkKTtcbiAgICAgICAgICAgIHRoaXMubWFya1NlbGVjdGVkRGF5KCk7XG4gICAgICAgICAgICB0aGlzLm1hcmtUb2RheSgpO1xuICAgICAgICAgICAgdGhpcy5hZnRlclJlbmRlcigpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZVJlbmRlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZVJlbmRlcigpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5tb2RlbC5zdGF0ZS52aWV3O1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgZG8gYWZ0ZXIgcmVuZGVyIHdvcmsgbGlrZSBhdHRhY2hlIGV2ZW50c1xuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYWZ0ZXJSZW5kZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWZ0ZXJSZW5kZXIoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlbC5uYXZpZ2F0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLm5hdmlnYXRvci5saXZlQXR0YWNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gVmlldztcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3O1xuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qXG4gKiBIYW1zdGVyLmpzIHYxLjEuMlxuICogKGMpIDIwMTMgTW9ub3NwYWNlZCBodHRwOi8vbW9ub3NwYWNlZC5jb21cbiAqIExpY2Vuc2U6IE1JVFxuICovXG5cbihmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50KXtcbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBIYW1zdGVyXG4gKiB1c2UgdGhpcyB0byBjcmVhdGUgaW5zdGFuY2VzXG4gKiBAcmV0dXJucyB7SGFtc3Rlci5JbnN0YW5jZX1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgSGFtc3RlciA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgcmV0dXJuIG5ldyBIYW1zdGVyLkluc3RhbmNlKGVsZW1lbnQpO1xufTtcblxuLy8gZGVmYXVsdCBldmVudCBuYW1lXG5IYW1zdGVyLlNVUFBPUlQgPSAnd2hlZWwnO1xuXG4vLyBkZWZhdWx0IERPTSBtZXRob2RzXG5IYW1zdGVyLkFERF9FVkVOVCA9ICdhZGRFdmVudExpc3RlbmVyJztcbkhhbXN0ZXIuUkVNT1ZFX0VWRU5UID0gJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuSGFtc3Rlci5QUkVGSVggPSAnJztcblxuLy8gdW50aWwgYnJvd3NlciBpbmNvbnNpc3RlbmNpZXMgaGF2ZSBiZWVuIGZpeGVkLi4uXG5IYW1zdGVyLlJFQURZID0gZmFsc2U7XG5cbkhhbXN0ZXIuSW5zdGFuY2UgPSBmdW5jdGlvbihlbGVtZW50KXtcbiAgaWYgKCFIYW1zdGVyLlJFQURZKSB7XG4gICAgLy8gZml4IGJyb3dzZXIgaW5jb25zaXN0ZW5jaWVzXG4gICAgSGFtc3Rlci5ub3JtYWxpc2UuYnJvd3NlcigpO1xuXG4gICAgLy8gSGFtc3RlciBpcyByZWFkeS4uLiFcbiAgICBIYW1zdGVyLlJFQURZID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgLy8gc3RvcmUgYXR0YWNoZWQgZXZlbnQgaGFuZGxlcnNcbiAgdGhpcy5oYW5kbGVycyA9IFtdO1xuXG4gIC8vIHJldHVybiBpbnN0YW5jZVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogY3JlYXRlIG5ldyBoYW1zdGVyIGluc3RhbmNlXG4gKiBhbGwgbWV0aG9kcyBzaG91bGQgcmV0dXJuIHRoZSBpbnN0YW5jZSBpdHNlbGYsIHNvIGl0IGlzIGNoYWluYWJsZS5cbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gICAgICAgZWxlbWVudFxuICogQHJldHVybnMge0hhbXN0ZXIuSW5zdGFuY2V9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuSGFtc3Rlci5JbnN0YW5jZS5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiBiaW5kIGV2ZW50cyB0byB0aGUgaW5zdGFuY2VcbiAgICogQHBhcmFtICAge0Z1bmN0aW9ufSAgICBoYW5kbGVyXG4gICAqIEBwYXJhbSAgIHtCb29sZWFufSAgICAgdXNlQ2FwdHVyZVxuICAgKiBAcmV0dXJucyB7SGFtc3Rlci5JbnN0YW5jZX1cbiAgICovXG4gIHdoZWVsOiBmdW5jdGlvbiBvbkV2ZW50KGhhbmRsZXIsIHVzZUNhcHR1cmUpe1xuICAgIEhhbXN0ZXIuZXZlbnQuYWRkKHRoaXMsIEhhbXN0ZXIuU1VQUE9SVCwgaGFuZGxlciwgdXNlQ2FwdHVyZSk7XG5cbiAgICAvLyBoYW5kbGUgTW96TW91c2VQaXhlbFNjcm9sbCBpbiBvbGRlciBGaXJlZm94XG4gICAgaWYgKEhhbXN0ZXIuU1VQUE9SVCA9PT0gJ0RPTU1vdXNlU2Nyb2xsJykge1xuICAgICAgSGFtc3Rlci5ldmVudC5hZGQodGhpcywgJ01vek1vdXNlUGl4ZWxTY3JvbGwnLCBoYW5kbGVyLCB1c2VDYXB0dXJlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogdW5iaW5kIGV2ZW50cyB0byB0aGUgaW5zdGFuY2VcbiAgICogQHBhcmFtICAge0Z1bmN0aW9ufSAgICBoYW5kbGVyXG4gICAqIEBwYXJhbSAgIHtCb29sZWFufSAgICAgdXNlQ2FwdHVyZVxuICAgKiBAcmV0dXJucyB7SGFtc3Rlci5JbnN0YW5jZX1cbiAgICovXG4gIHVud2hlZWw6IGZ1bmN0aW9uIG9mZkV2ZW50KGhhbmRsZXIsIHVzZUNhcHR1cmUpe1xuICAgIC8vIGlmIG5vIGhhbmRsZXIgYXJndW1lbnQsXG4gICAgLy8gdW5iaW5kIHRoZSBsYXN0IGJvdW5kIGhhbmRsZXIgKGlmIGV4aXN0cylcbiAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkICYmIChoYW5kbGVyID0gdGhpcy5oYW5kbGVycy5zbGljZSgtMSlbMF0pKSB7XG4gICAgICBoYW5kbGVyID0gaGFuZGxlci5vcmlnaW5hbDtcbiAgICB9XG5cbiAgICBIYW1zdGVyLmV2ZW50LnJlbW92ZSh0aGlzLCBIYW1zdGVyLlNVUFBPUlQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpO1xuXG4gICAgLy8gaGFuZGxlIE1vek1vdXNlUGl4ZWxTY3JvbGwgaW4gb2xkZXIgRmlyZWZveFxuICAgIGlmIChIYW1zdGVyLlNVUFBPUlQgPT09ICdET01Nb3VzZVNjcm9sbCcpIHtcbiAgICAgIEhhbXN0ZXIuZXZlbnQucmVtb3ZlKHRoaXMsICdNb3pNb3VzZVBpeGVsU2Nyb2xsJywgaGFuZGxlciwgdXNlQ2FwdHVyZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbkhhbXN0ZXIuZXZlbnQgPSB7XG4gIC8qKlxuICAgKiBjcm9zcy1icm93c2VyICdhZGRXaGVlbExpc3RlbmVyJ1xuICAgKiBAcGFyYW0gICB7SW5zdGFuY2V9ICAgIGhhbXN0ZXJcbiAgICogQHBhcmFtICAge1N0cmluZ30gICAgICBldmVudE5hbWVcbiAgICogQHBhcmFtICAge0Z1bmN0aW9ufSAgICBoYW5kbGVyXG4gICAqIEBwYXJhbSAgIHtCb29sZWFufSAgICAgdXNlQ2FwdHVyZVxuICAgKi9cbiAgYWRkOiBmdW5jdGlvbiBhZGQoaGFtc3RlciwgZXZlbnROYW1lLCBoYW5kbGVyLCB1c2VDYXB0dXJlKXtcbiAgICAvLyBzdG9yZSB0aGUgb3JpZ2luYWwgaGFuZGxlclxuICAgIHZhciBvcmlnaW5hbEhhbmRsZXIgPSBoYW5kbGVyO1xuXG4gICAgLy8gcmVkZWZpbmUgdGhlIGhhbmRsZXJcbiAgICBoYW5kbGVyID0gZnVuY3Rpb24ob3JpZ2luYWxFdmVudCl7XG5cbiAgICAgIGlmICghb3JpZ2luYWxFdmVudCkge1xuICAgICAgICBvcmlnaW5hbEV2ZW50ID0gd2luZG93LmV2ZW50O1xuICAgICAgfVxuXG4gICAgICAvLyBjcmVhdGUgYSBub3JtYWxpc2VkIGV2ZW50IG9iamVjdCxcbiAgICAgIC8vIGFuZCBub3JtYWxpc2UgXCJkZWx0YXNcIiBvZiB0aGUgbW91c2Ugd2hlZWxcbiAgICAgIHZhciBldmVudCA9IEhhbXN0ZXIubm9ybWFsaXNlLmV2ZW50KG9yaWdpbmFsRXZlbnQpLFxuICAgICAgICAgIGRlbHRhID0gSGFtc3Rlci5ub3JtYWxpc2UuZGVsdGEob3JpZ2luYWxFdmVudCk7XG5cbiAgICAgIC8vIGZpcmUgdGhlIG9yaWdpbmFsIGhhbmRsZXIgd2l0aCBub3JtYWxpc2VkIGFyZ3VtZW50c1xuICAgICAgcmV0dXJuIG9yaWdpbmFsSGFuZGxlcihldmVudCwgZGVsdGFbMF0sIGRlbHRhWzFdLCBkZWx0YVsyXSk7XG5cbiAgICB9O1xuXG4gICAgLy8gY3Jvc3MtYnJvd3NlciBhZGRFdmVudExpc3RlbmVyXG4gICAgaGFtc3Rlci5lbGVtZW50W0hhbXN0ZXIuQUREX0VWRU5UXShIYW1zdGVyLlBSRUZJWCArIGV2ZW50TmFtZSwgaGFuZGxlciwgdXNlQ2FwdHVyZSB8fCBmYWxzZSk7XG5cbiAgICAvLyBzdG9yZSBvcmlnaW5hbCBhbmQgbm9ybWFsaXNlZCBoYW5kbGVycyBvbiB0aGUgaW5zdGFuY2VcbiAgICBoYW1zdGVyLmhhbmRsZXJzLnB1c2goe1xuICAgICAgb3JpZ2luYWw6IG9yaWdpbmFsSGFuZGxlcixcbiAgICAgIG5vcm1hbGlzZWQ6IGhhbmRsZXJcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogcmVtb3ZlV2hlZWxMaXN0ZW5lclxuICAgKiBAcGFyYW0gICB7SW5zdGFuY2V9ICAgIGhhbXN0ZXJcbiAgICogQHBhcmFtICAge1N0cmluZ30gICAgICBldmVudE5hbWVcbiAgICogQHBhcmFtICAge0Z1bmN0aW9ufSAgICBoYW5kbGVyXG4gICAqIEBwYXJhbSAgIHtCb29sZWFufSAgICAgdXNlQ2FwdHVyZVxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoaGFtc3RlciwgZXZlbnROYW1lLCBoYW5kbGVyLCB1c2VDYXB0dXJlKXtcbiAgICAvLyBmaW5kIHRoZSBub3JtYWxpc2VkIGhhbmRsZXIgb24gdGhlIGluc3RhbmNlXG4gICAgdmFyIG9yaWdpbmFsSGFuZGxlciA9IGhhbmRsZXIsXG4gICAgICAgIGxvb2t1cCA9IHt9LFxuICAgICAgICBoYW5kbGVycztcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaGFtc3Rlci5oYW5kbGVycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgbG9va3VwW2hhbXN0ZXIuaGFuZGxlcnNbaV0ub3JpZ2luYWxdID0gaGFtc3Rlci5oYW5kbGVyc1tpXTtcbiAgICB9XG4gICAgaGFuZGxlcnMgPSBsb29rdXBbb3JpZ2luYWxIYW5kbGVyXTtcbiAgICBoYW5kbGVyID0gaGFuZGxlcnMubm9ybWFsaXNlZDtcblxuICAgIC8vIGNyb3NzLWJyb3dzZXIgcmVtb3ZlRXZlbnRMaXN0ZW5lclxuICAgIGhhbXN0ZXIuZWxlbWVudFtIYW1zdGVyLlJFTU9WRV9FVkVOVF0oSGFtc3Rlci5QUkVGSVggKyBldmVudE5hbWUsIGhhbmRsZXIsIHVzZUNhcHR1cmUgfHwgZmFsc2UpO1xuXG4gICAgLy8gcmVtb3ZlIG9yaWdpbmFsIGFuZCBub3JtYWxpc2VkIGhhbmRsZXJzIGZyb20gdGhlIGluc3RhbmNlXG4gICAgZm9yICh2YXIgaCBpbiBoYW1zdGVyLmhhbmRsZXJzKSB7XG4gICAgICBpZiAoaGFtc3Rlci5oYW5kbGVyc1toXSA9PSBoYW5kbGVycykge1xuICAgICAgICBoYW1zdGVyLmhhbmRsZXJzLnNwbGljZShoLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIHRoZXNlIGhvbGQgdGhlIGxvd2VzdCBkZWx0YXMsXG4gKiB1c2VkIHRvIG5vcm1hbGlzZSB0aGUgZGVsdGEgdmFsdWVzXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG52YXIgbG93ZXN0RGVsdGEsXG4gICAgbG93ZXN0RGVsdGFYWTtcblxuSGFtc3Rlci5ub3JtYWxpc2UgPSB7XG4gIC8qKlxuICAgKiBmaXggYnJvd3NlciBpbmNvbnNpc3RlbmNpZXNcbiAgICovXG4gIGJyb3dzZXI6IGZ1bmN0aW9uIG5vcm1hbGlzZUJyb3dzZXIoKXtcbiAgICAvLyBkZXRlY3QgZGVwcmVjYXRlZCB3aGVlbCBldmVudHNcbiAgICBpZiAoISgnb253aGVlbCcgaW4gZG9jdW1lbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID49IDkpKSB7XG4gICAgICBIYW1zdGVyLlNVUFBPUlQgPSBkb2N1bWVudC5vbm1vdXNld2hlZWwgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAnbW91c2V3aGVlbCcgOiAvLyB3ZWJraXQgYW5kIElFIDwgOSBzdXBwb3J0IGF0IGxlYXN0IFwibW91c2V3aGVlbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAnRE9NTW91c2VTY3JvbGwnOyAvLyBhc3N1bWUgcmVtYWluaW5nIGJyb3dzZXJzIGFyZSBvbGRlciBGaXJlZm94XG4gICAgfVxuXG4gICAgLy8gZGV0ZWN0IGRlcHJlY2F0ZWQgZXZlbnQgbW9kZWxcbiAgICBpZiAoIXdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAvLyBhc3N1bWUgSUUgPCA5XG4gICAgICBIYW1zdGVyLkFERF9FVkVOVCA9ICdhdHRhY2hFdmVudCc7XG4gICAgICBIYW1zdGVyLlJFTU9WRV9FVkVOVCA9ICdkZXRhY2hFdmVudCc7XG4gICAgICBIYW1zdGVyLlBSRUZJWCA9ICdvbic7XG4gICAgfVxuXG4gIH0sXG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIG5vcm1hbGlzZWQgZXZlbnQgb2JqZWN0XG4gICAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gICAgb3JpZ2luYWxFdmVudFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSAgICAgIGV2ZW50XG4gICAqL1xuICAgZXZlbnQ6IGZ1bmN0aW9uIG5vcm1hbGlzZUV2ZW50KG9yaWdpbmFsRXZlbnQpe1xuICAgIHZhciBldmVudCA9IHtcbiAgICAgICAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCBldmVudCBvYmplY3RcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBvcmlnaW5hbEV2ZW50LFxuICAgICAgICAgIHRhcmdldDogb3JpZ2luYWxFdmVudC50YXJnZXQgfHwgb3JpZ2luYWxFdmVudC5zcmNFbGVtZW50LFxuICAgICAgICAgIHR5cGU6ICd3aGVlbCcsXG4gICAgICAgICAgZGVsdGFNb2RlOiBvcmlnaW5hbEV2ZW50LnR5cGUgPT09ICdNb3pNb3VzZVBpeGVsU2Nyb2xsJyA/IDAgOiAxLFxuICAgICAgICAgIGRlbHRhWDogMCxcbiAgICAgICAgICBkZWx0YVo6IDAsXG4gICAgICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxFdmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQuY2FuY2VsQnViYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgLy8gY2FsY3VsYXRlIGRlbHRhWSAoYW5kIGRlbHRhWCkgYWNjb3JkaW5nIHRvIHRoZSBldmVudFxuXG4gICAgLy8gJ21vdXNld2hlZWwnXG4gICAgaWYgKG9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YSkge1xuICAgICAgZXZlbnQuZGVsdGFZID0gLSAxLzQwICogb3JpZ2luYWxFdmVudC53aGVlbERlbHRhO1xuICAgIH1cbiAgICAvLyB3ZWJraXRcbiAgICBpZiAob3JpZ2luYWxFdmVudC53aGVlbERlbHRhWCkge1xuICAgICAgZXZlbnQuZGVsdGFYID0gLSAxLzQwICogb3JpZ2luYWxFdmVudC53aGVlbERlbHRhWDtcbiAgICB9XG5cbiAgICAvLyAnRG9tTW91c2VTY3JvbGwnXG4gICAgaWYgKG9yaWdpbmFsRXZlbnQuZGV0YWlsKSB7XG4gICAgICBldmVudC5kZWx0YVkgPSBvcmlnaW5hbEV2ZW50LmRldGFpbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIG5vcm1hbGlzZSAnZGVsdGFzJyBvZiB0aGUgbW91c2Ugd2hlZWxcbiAgICogQHBhcmFtICAge0Z1bmN0aW9ufSAgICBvcmlnaW5hbEV2ZW50XG4gICAqIEByZXR1cm5zIHtBcnJheX0gICAgICAgZGVsdGFzXG4gICAqL1xuICBkZWx0YTogZnVuY3Rpb24gbm9ybWFsaXNlRGVsdGEob3JpZ2luYWxFdmVudCl7XG4gICAgdmFyIGRlbHRhID0gMCxcbiAgICAgIGRlbHRhWCA9IDAsXG4gICAgICBkZWx0YVkgPSAwLFxuICAgICAgYWJzRGVsdGEgPSAwLFxuICAgICAgYWJzRGVsdGFYWSA9IDAsXG4gICAgICBmbjtcblxuICAgIC8vIG5vcm1hbGlzZSBkZWx0YXMgYWNjb3JkaW5nIHRvIHRoZSBldmVudFxuXG4gICAgLy8gJ3doZWVsJyBldmVudFxuICAgIGlmIChvcmlnaW5hbEV2ZW50LmRlbHRhWSkge1xuICAgICAgZGVsdGFZID0gb3JpZ2luYWxFdmVudC5kZWx0YVkgKiAtMTtcbiAgICAgIGRlbHRhICA9IGRlbHRhWTtcbiAgICB9XG4gICAgaWYgKG9yaWdpbmFsRXZlbnQuZGVsdGFYKSB7XG4gICAgICBkZWx0YVggPSBvcmlnaW5hbEV2ZW50LmRlbHRhWDtcbiAgICAgIGRlbHRhICA9IGRlbHRhWCAqIC0xO1xuICAgIH1cblxuICAgIC8vICdtb3VzZXdoZWVsJyBldmVudFxuICAgIGlmIChvcmlnaW5hbEV2ZW50LndoZWVsRGVsdGEpIHtcbiAgICAgIGRlbHRhID0gb3JpZ2luYWxFdmVudC53aGVlbERlbHRhO1xuICAgIH1cbiAgICAvLyB3ZWJraXRcbiAgICBpZiAob3JpZ2luYWxFdmVudC53aGVlbERlbHRhWSkge1xuICAgICAgZGVsdGFZID0gb3JpZ2luYWxFdmVudC53aGVlbERlbHRhWTtcbiAgICB9XG4gICAgaWYgKG9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YVgpIHtcbiAgICAgIGRlbHRhWCA9IG9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YVggKiAtMTtcbiAgICB9XG5cbiAgICAvLyAnRG9tTW91c2VTY3JvbGwnIGV2ZW50XG4gICAgaWYgKG9yaWdpbmFsRXZlbnQuZGV0YWlsKSB7XG4gICAgICBkZWx0YSA9IG9yaWdpbmFsRXZlbnQuZGV0YWlsICogLTE7XG4gICAgfVxuXG4gICAgLy8gRG9uJ3QgcmV0dXJuIE5hTlxuICAgIGlmIChkZWx0YSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFswLCAwLCAwXTtcbiAgICB9XG5cbiAgICAvLyBsb29rIGZvciBsb3dlc3QgZGVsdGEgdG8gbm9ybWFsaXplIHRoZSBkZWx0YSB2YWx1ZXNcbiAgICBhYnNEZWx0YSA9IE1hdGguYWJzKGRlbHRhKTtcbiAgICBpZiAoIWxvd2VzdERlbHRhIHx8IGFic0RlbHRhIDwgbG93ZXN0RGVsdGEpIHtcbiAgICAgIGxvd2VzdERlbHRhID0gYWJzRGVsdGE7XG4gICAgfVxuICAgIGFic0RlbHRhWFkgPSBNYXRoLm1heChNYXRoLmFicyhkZWx0YVkpLCBNYXRoLmFicyhkZWx0YVgpKTtcbiAgICBpZiAoIWxvd2VzdERlbHRhWFkgfHwgYWJzRGVsdGFYWSA8IGxvd2VzdERlbHRhWFkpIHtcbiAgICAgIGxvd2VzdERlbHRhWFkgPSBhYnNEZWx0YVhZO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgZGVsdGFzIHRvIHdob2xlIG51bWJlcnNcbiAgICBmbiA9IGRlbHRhID4gMCA/ICdmbG9vcicgOiAnY2VpbCc7XG4gICAgZGVsdGEgID0gTWF0aFtmbl0oZGVsdGEgLyBsb3dlc3REZWx0YSk7XG4gICAgZGVsdGFYID0gTWF0aFtmbl0oZGVsdGFYIC8gbG93ZXN0RGVsdGFYWSk7XG4gICAgZGVsdGFZID0gTWF0aFtmbl0oZGVsdGFZIC8gbG93ZXN0RGVsdGFYWSk7XG5cbiAgICByZXR1cm4gW2RlbHRhLCBkZWx0YVgsIGRlbHRhWV07XG4gIH1cbn07XG5cbmlmICh0eXBlb2Ygd2luZG93LmRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB3aW5kb3cuZGVmaW5lLmFtZCkge1xuICAvLyBBTURcbiAgd2luZG93LmRlZmluZSgnaGFtc3RlcicsIFtdLCBmdW5jdGlvbigpe1xuICAgIHJldHVybiBIYW1zdGVyO1xuICB9KTtcbn0gZWxzZSBpZiAodHJ1ZSkge1xuICAvLyBDb21tb25KU1xuICBtb2R1bGUuZXhwb3J0cyA9IEhhbXN0ZXI7XG59IGVsc2Uge1xuICAvLyBCcm93c2VyIGdsb2JhbFxuICB3aW5kb3cuSGFtc3RlciA9IEhhbXN0ZXI7XG59XG5cbn0pKHdpbmRvdywgd2luZG93LmRvY3VtZW50KTtcblxuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIVxuICogbXVzdGFjaGUuanMgLSBMb2dpYy1sZXNzIHt7bXVzdGFjaGV9fSB0ZW1wbGF0ZXMgd2l0aCBKYXZhU2NyaXB0XG4gKiBodHRwOi8vZ2l0aHViLmNvbS9qYW5sL211c3RhY2hlLmpzXG4gKi9cblxuLypnbG9iYWwgZGVmaW5lOiBmYWxzZSBNdXN0YWNoZTogdHJ1ZSovXG5cbihmdW5jdGlvbiBkZWZpbmVNdXN0YWNoZSAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiB0eXBlb2YgZXhwb3J0cy5ub2RlTmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICBmYWN0b3J5KGV4cG9ydHMpOyAvLyBDb21tb25KU1xuICB9IGVsc2UgaWYgKHRydWUpIHtcbiAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbZXhwb3J0c10sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/XG5cdFx0XHRcdChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpOyAvLyBBTURcbiAgfSBlbHNlIHtcbiAgICBnbG9iYWwuTXVzdGFjaGUgPSB7fTtcbiAgICBmYWN0b3J5KGdsb2JhbC5NdXN0YWNoZSk7IC8vIHNjcmlwdCwgd3NoLCBhc3BcbiAgfVxufSh0aGlzLCBmdW5jdGlvbiBtdXN0YWNoZUZhY3RvcnkgKG11c3RhY2hlKSB7XG5cbiAgdmFyIG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXlQb2x5ZmlsbCAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdFRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICBmdW5jdGlvbiBpc0Z1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3JlIGNvcnJlY3QgdHlwZW9mIHN0cmluZyBoYW5kbGluZyBhcnJheVxuICAgKiB3aGljaCBub3JtYWxseSByZXR1cm5zIHR5cGVvZiAnb2JqZWN0J1xuICAgKi9cbiAgZnVuY3Rpb24gdHlwZVN0ciAob2JqKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkob2JqKSA/ICdhcnJheScgOiB0eXBlb2Ygb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwIChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1tcXC1cXFtcXF17fSgpKis/LixcXFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJyk7XG4gIH1cblxuICAvKipcbiAgICogTnVsbCBzYWZlIHdheSBvZiBjaGVja2luZyB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QsXG4gICAqIGluY2x1ZGluZyBpdHMgcHJvdG90eXBlLCBoYXMgYSBnaXZlbiBwcm9wZXJ0eVxuICAgKi9cbiAgZnVuY3Rpb24gaGFzUHJvcGVydHkgKG9iaiwgcHJvcE5hbWUpIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgKHByb3BOYW1lIGluIG9iaik7XG4gIH1cblxuICAvKipcbiAgICogU2FmZSB3YXkgb2YgZGV0ZWN0aW5nIHdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiB0aGluZyBpcyBhIHByaW1pdGl2ZSBhbmRcbiAgICogd2hldGhlciBpdCBoYXMgdGhlIGdpdmVuIHByb3BlcnR5XG4gICAqL1xuICBmdW5jdGlvbiBwcmltaXRpdmVIYXNPd25Qcm9wZXJ0eSAocHJpbWl0aXZlLCBwcm9wTmFtZSkgeyAgXG4gICAgcmV0dXJuIChcbiAgICAgIHByaW1pdGl2ZSAhPSBudWxsXG4gICAgICAmJiB0eXBlb2YgcHJpbWl0aXZlICE9PSAnb2JqZWN0J1xuICAgICAgJiYgcHJpbWl0aXZlLmhhc093blByb3BlcnR5XG4gICAgICAmJiBwcmltaXRpdmUuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpXG4gICAgKTtcbiAgfVxuXG4gIC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vaXNzdWVzLmFwYWNoZS5vcmcvamlyYS9icm93c2UvQ09VQ0hEQi01NzdcbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYW5sL211c3RhY2hlLmpzL2lzc3Vlcy8xODlcbiAgdmFyIHJlZ0V4cFRlc3QgPSBSZWdFeHAucHJvdG90eXBlLnRlc3Q7XG4gIGZ1bmN0aW9uIHRlc3RSZWdFeHAgKHJlLCBzdHJpbmcpIHtcbiAgICByZXR1cm4gcmVnRXhwVGVzdC5jYWxsKHJlLCBzdHJpbmcpO1xuICB9XG5cbiAgdmFyIG5vblNwYWNlUmUgPSAvXFxTLztcbiAgZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChzdHJpbmcpIHtcbiAgICByZXR1cm4gIXRlc3RSZWdFeHAobm9uU3BhY2VSZSwgc3RyaW5nKTtcbiAgfVxuXG4gIHZhciBlbnRpdHlNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiMzOTsnLFxuICAgICcvJzogJyYjeDJGOycsXG4gICAgJ2AnOiAnJiN4NjA7JyxcbiAgICAnPSc6ICcmI3gzRDsnXG4gIH07XG5cbiAgZnVuY3Rpb24gZXNjYXBlSHRtbCAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UoL1smPD5cIidgPVxcL10vZywgZnVuY3Rpb24gZnJvbUVudGl0eU1hcCAocykge1xuICAgICAgcmV0dXJuIGVudGl0eU1hcFtzXTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciB3aGl0ZVJlID0gL1xccyovO1xuICB2YXIgc3BhY2VSZSA9IC9cXHMrLztcbiAgdmFyIGVxdWFsc1JlID0gL1xccyo9LztcbiAgdmFyIGN1cmx5UmUgPSAvXFxzKlxcfS87XG4gIHZhciB0YWdSZSA9IC8jfFxcXnxcXC98PnxcXHt8Jnw9fCEvO1xuXG4gIC8qKlxuICAgKiBCcmVha3MgdXAgdGhlIGdpdmVuIGB0ZW1wbGF0ZWAgc3RyaW5nIGludG8gYSB0cmVlIG9mIHRva2Vucy4gSWYgdGhlIGB0YWdzYFxuICAgKiBhcmd1bWVudCBpcyBnaXZlbiBoZXJlIGl0IG11c3QgYmUgYW4gYXJyYXkgd2l0aCB0d28gc3RyaW5nIHZhbHVlczogdGhlXG4gICAqIG9wZW5pbmcgYW5kIGNsb3NpbmcgdGFncyB1c2VkIGluIHRoZSB0ZW1wbGF0ZSAoZS5nLiBbIFwiPCVcIiwgXCIlPlwiIF0pLiBPZlxuICAgKiBjb3Vyc2UsIHRoZSBkZWZhdWx0IGlzIHRvIHVzZSBtdXN0YWNoZXMgKGkuZS4gbXVzdGFjaGUudGFncykuXG4gICAqXG4gICAqIEEgdG9rZW4gaXMgYW4gYXJyYXkgd2l0aCBhdCBsZWFzdCA0IGVsZW1lbnRzLiBUaGUgZmlyc3QgZWxlbWVudCBpcyB0aGVcbiAgICogbXVzdGFjaGUgc3ltYm9sIHRoYXQgd2FzIHVzZWQgaW5zaWRlIHRoZSB0YWcsIGUuZy4gXCIjXCIgb3IgXCImXCIuIElmIHRoZSB0YWdcbiAgICogZGlkIG5vdCBjb250YWluIGEgc3ltYm9sIChpLmUuIHt7bXlWYWx1ZX19KSB0aGlzIGVsZW1lbnQgaXMgXCJuYW1lXCIuIEZvclxuICAgKiBhbGwgdGV4dCB0aGF0IGFwcGVhcnMgb3V0c2lkZSBhIHN5bWJvbCB0aGlzIGVsZW1lbnQgaXMgXCJ0ZXh0XCIuXG4gICAqXG4gICAqIFRoZSBzZWNvbmQgZWxlbWVudCBvZiBhIHRva2VuIGlzIGl0cyBcInZhbHVlXCIuIEZvciBtdXN0YWNoZSB0YWdzIHRoaXMgaXNcbiAgICogd2hhdGV2ZXIgZWxzZSB3YXMgaW5zaWRlIHRoZSB0YWcgYmVzaWRlcyB0aGUgb3BlbmluZyBzeW1ib2wuIEZvciB0ZXh0IHRva2Vuc1xuICAgKiB0aGlzIGlzIHRoZSB0ZXh0IGl0c2VsZi5cbiAgICpcbiAgICogVGhlIHRoaXJkIGFuZCBmb3VydGggZWxlbWVudHMgb2YgdGhlIHRva2VuIGFyZSB0aGUgc3RhcnQgYW5kIGVuZCBpbmRpY2VzLFxuICAgKiByZXNwZWN0aXZlbHksIG9mIHRoZSB0b2tlbiBpbiB0aGUgb3JpZ2luYWwgdGVtcGxhdGUuXG4gICAqXG4gICAqIFRva2VucyB0aGF0IGFyZSB0aGUgcm9vdCBub2RlIG9mIGEgc3VidHJlZSBjb250YWluIHR3byBtb3JlIGVsZW1lbnRzOiAxKSBhblxuICAgKiBhcnJheSBvZiB0b2tlbnMgaW4gdGhlIHN1YnRyZWUgYW5kIDIpIHRoZSBpbmRleCBpbiB0aGUgb3JpZ2luYWwgdGVtcGxhdGUgYXRcbiAgICogd2hpY2ggdGhlIGNsb3NpbmcgdGFnIGZvciB0aGF0IHNlY3Rpb24gYmVnaW5zLlxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VUZW1wbGF0ZSAodGVtcGxhdGUsIHRhZ3MpIHtcbiAgICBpZiAoIXRlbXBsYXRlKVxuICAgICAgcmV0dXJuIFtdO1xuXG4gICAgdmFyIHNlY3Rpb25zID0gW107ICAgICAvLyBTdGFjayB0byBob2xkIHNlY3Rpb24gdG9rZW5zXG4gICAgdmFyIHRva2VucyA9IFtdOyAgICAgICAvLyBCdWZmZXIgdG8gaG9sZCB0aGUgdG9rZW5zXG4gICAgdmFyIHNwYWNlcyA9IFtdOyAgICAgICAvLyBJbmRpY2VzIG9mIHdoaXRlc3BhY2UgdG9rZW5zIG9uIHRoZSBjdXJyZW50IGxpbmVcbiAgICB2YXIgaGFzVGFnID0gZmFsc2U7ICAgIC8vIElzIHRoZXJlIGEge3t0YWd9fSBvbiB0aGUgY3VycmVudCBsaW5lP1xuICAgIHZhciBub25TcGFjZSA9IGZhbHNlOyAgLy8gSXMgdGhlcmUgYSBub24tc3BhY2UgY2hhciBvbiB0aGUgY3VycmVudCBsaW5lP1xuXG4gICAgLy8gU3RyaXBzIGFsbCB3aGl0ZXNwYWNlIHRva2VucyBhcnJheSBmb3IgdGhlIGN1cnJlbnQgbGluZVxuICAgIC8vIGlmIHRoZXJlIHdhcyBhIHt7I3RhZ319IG9uIGl0IGFuZCBvdGhlcndpc2Ugb25seSBzcGFjZS5cbiAgICBmdW5jdGlvbiBzdHJpcFNwYWNlICgpIHtcbiAgICAgIGlmIChoYXNUYWcgJiYgIW5vblNwYWNlKSB7XG4gICAgICAgIHdoaWxlIChzcGFjZXMubGVuZ3RoKVxuICAgICAgICAgIGRlbGV0ZSB0b2tlbnNbc3BhY2VzLnBvcCgpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwYWNlcyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBoYXNUYWcgPSBmYWxzZTtcbiAgICAgIG5vblNwYWNlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIG9wZW5pbmdUYWdSZSwgY2xvc2luZ1RhZ1JlLCBjbG9zaW5nQ3VybHlSZTtcbiAgICBmdW5jdGlvbiBjb21waWxlVGFncyAodGFnc1RvQ29tcGlsZSkge1xuICAgICAgaWYgKHR5cGVvZiB0YWdzVG9Db21waWxlID09PSAnc3RyaW5nJylcbiAgICAgICAgdGFnc1RvQ29tcGlsZSA9IHRhZ3NUb0NvbXBpbGUuc3BsaXQoc3BhY2VSZSwgMik7XG5cbiAgICAgIGlmICghaXNBcnJheSh0YWdzVG9Db21waWxlKSB8fCB0YWdzVG9Db21waWxlLmxlbmd0aCAhPT0gMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRhZ3M6ICcgKyB0YWdzVG9Db21waWxlKTtcblxuICAgICAgb3BlbmluZ1RhZ1JlID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAodGFnc1RvQ29tcGlsZVswXSkgKyAnXFxcXHMqJyk7XG4gICAgICBjbG9zaW5nVGFnUmUgPSBuZXcgUmVnRXhwKCdcXFxccyonICsgZXNjYXBlUmVnRXhwKHRhZ3NUb0NvbXBpbGVbMV0pKTtcbiAgICAgIGNsb3NpbmdDdXJseVJlID0gbmV3IFJlZ0V4cCgnXFxcXHMqJyArIGVzY2FwZVJlZ0V4cCgnfScgKyB0YWdzVG9Db21waWxlWzFdKSk7XG4gICAgfVxuXG4gICAgY29tcGlsZVRhZ3ModGFncyB8fCBtdXN0YWNoZS50YWdzKTtcblxuICAgIHZhciBzY2FubmVyID0gbmV3IFNjYW5uZXIodGVtcGxhdGUpO1xuXG4gICAgdmFyIHN0YXJ0LCB0eXBlLCB2YWx1ZSwgY2hyLCB0b2tlbiwgb3BlblNlY3Rpb247XG4gICAgd2hpbGUgKCFzY2FubmVyLmVvcygpKSB7XG4gICAgICBzdGFydCA9IHNjYW5uZXIucG9zO1xuXG4gICAgICAvLyBNYXRjaCBhbnkgdGV4dCBiZXR3ZWVuIHRhZ3MuXG4gICAgICB2YWx1ZSA9IHNjYW5uZXIuc2NhblVudGlsKG9wZW5pbmdUYWdSZSk7XG5cbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgdmFsdWVMZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGkgPCB2YWx1ZUxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY2hyID0gdmFsdWUuY2hhckF0KGkpO1xuXG4gICAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjaHIpKSB7XG4gICAgICAgICAgICBzcGFjZXMucHVzaCh0b2tlbnMubGVuZ3RoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9uU3BhY2UgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRva2Vucy5wdXNoKFsgJ3RleHQnLCBjaHIsIHN0YXJ0LCBzdGFydCArIDEgXSk7XG4gICAgICAgICAgc3RhcnQgKz0gMTtcblxuICAgICAgICAgIC8vIENoZWNrIGZvciB3aGl0ZXNwYWNlIG9uIHRoZSBjdXJyZW50IGxpbmUuXG4gICAgICAgICAgaWYgKGNociA9PT0gJ1xcbicpXG4gICAgICAgICAgICBzdHJpcFNwYWNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTWF0Y2ggdGhlIG9wZW5pbmcgdGFnLlxuICAgICAgaWYgKCFzY2FubmVyLnNjYW4ob3BlbmluZ1RhZ1JlKSlcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGhhc1RhZyA9IHRydWU7XG5cbiAgICAgIC8vIEdldCB0aGUgdGFnIHR5cGUuXG4gICAgICB0eXBlID0gc2Nhbm5lci5zY2FuKHRhZ1JlKSB8fCAnbmFtZSc7XG4gICAgICBzY2FubmVyLnNjYW4od2hpdGVSZSk7XG5cbiAgICAgIC8vIEdldCB0aGUgdGFnIHZhbHVlLlxuICAgICAgaWYgKHR5cGUgPT09ICc9Jykge1xuICAgICAgICB2YWx1ZSA9IHNjYW5uZXIuc2NhblVudGlsKGVxdWFsc1JlKTtcbiAgICAgICAgc2Nhbm5lci5zY2FuKGVxdWFsc1JlKTtcbiAgICAgICAgc2Nhbm5lci5zY2FuVW50aWwoY2xvc2luZ1RhZ1JlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3snKSB7XG4gICAgICAgIHZhbHVlID0gc2Nhbm5lci5zY2FuVW50aWwoY2xvc2luZ0N1cmx5UmUpO1xuICAgICAgICBzY2FubmVyLnNjYW4oY3VybHlSZSk7XG4gICAgICAgIHNjYW5uZXIuc2NhblVudGlsKGNsb3NpbmdUYWdSZSk7XG4gICAgICAgIHR5cGUgPSAnJic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHNjYW5uZXIuc2NhblVudGlsKGNsb3NpbmdUYWdSZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIE1hdGNoIHRoZSBjbG9zaW5nIHRhZy5cbiAgICAgIGlmICghc2Nhbm5lci5zY2FuKGNsb3NpbmdUYWdSZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5jbG9zZWQgdGFnIGF0ICcgKyBzY2FubmVyLnBvcyk7XG5cbiAgICAgIHRva2VuID0gWyB0eXBlLCB2YWx1ZSwgc3RhcnQsIHNjYW5uZXIucG9zIF07XG4gICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG5cbiAgICAgIGlmICh0eXBlID09PSAnIycgfHwgdHlwZSA9PT0gJ14nKSB7XG4gICAgICAgIHNlY3Rpb25zLnB1c2godG9rZW4pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnLycpIHtcbiAgICAgICAgLy8gQ2hlY2sgc2VjdGlvbiBuZXN0aW5nLlxuICAgICAgICBvcGVuU2VjdGlvbiA9IHNlY3Rpb25zLnBvcCgpO1xuXG4gICAgICAgIGlmICghb3BlblNlY3Rpb24pXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbm9wZW5lZCBzZWN0aW9uIFwiJyArIHZhbHVlICsgJ1wiIGF0ICcgKyBzdGFydCk7XG5cbiAgICAgICAgaWYgKG9wZW5TZWN0aW9uWzFdICE9PSB2YWx1ZSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIHNlY3Rpb24gXCInICsgb3BlblNlY3Rpb25bMV0gKyAnXCIgYXQgJyArIHN0YXJ0KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ25hbWUnIHx8IHR5cGUgPT09ICd7JyB8fCB0eXBlID09PSAnJicpIHtcbiAgICAgICAgbm9uU3BhY2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnPScpIHtcbiAgICAgICAgLy8gU2V0IHRoZSB0YWdzIGZvciB0aGUgbmV4dCB0aW1lIGFyb3VuZC5cbiAgICAgICAgY29tcGlsZVRhZ3ModmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSBhcmUgbm8gb3BlbiBzZWN0aW9ucyB3aGVuIHdlJ3JlIGRvbmUuXG4gICAgb3BlblNlY3Rpb24gPSBzZWN0aW9ucy5wb3AoKTtcblxuICAgIGlmIChvcGVuU2VjdGlvbilcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5jbG9zZWQgc2VjdGlvbiBcIicgKyBvcGVuU2VjdGlvblsxXSArICdcIiBhdCAnICsgc2Nhbm5lci5wb3MpO1xuXG4gICAgcmV0dXJuIG5lc3RUb2tlbnMoc3F1YXNoVG9rZW5zKHRva2VucykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbWJpbmVzIHRoZSB2YWx1ZXMgb2YgY29uc2VjdXRpdmUgdGV4dCB0b2tlbnMgaW4gdGhlIGdpdmVuIGB0b2tlbnNgIGFycmF5XG4gICAqIHRvIGEgc2luZ2xlIHRva2VuLlxuICAgKi9cbiAgZnVuY3Rpb24gc3F1YXNoVG9rZW5zICh0b2tlbnMpIHtcbiAgICB2YXIgc3F1YXNoZWRUb2tlbnMgPSBbXTtcblxuICAgIHZhciB0b2tlbiwgbGFzdFRva2VuO1xuICAgIGZvciAodmFyIGkgPSAwLCBudW1Ub2tlbnMgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbnVtVG9rZW5zOyArK2kpIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuWzBdID09PSAndGV4dCcgJiYgbGFzdFRva2VuICYmIGxhc3RUb2tlblswXSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgbGFzdFRva2VuWzFdICs9IHRva2VuWzFdO1xuICAgICAgICAgIGxhc3RUb2tlblszXSA9IHRva2VuWzNdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNxdWFzaGVkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2VuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNxdWFzaGVkVG9rZW5zO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcm1zIHRoZSBnaXZlbiBhcnJheSBvZiBgdG9rZW5zYCBpbnRvIGEgbmVzdGVkIHRyZWUgc3RydWN0dXJlIHdoZXJlXG4gICAqIHRva2VucyB0aGF0IHJlcHJlc2VudCBhIHNlY3Rpb24gaGF2ZSB0d28gYWRkaXRpb25hbCBpdGVtczogMSkgYW4gYXJyYXkgb2ZcbiAgICogYWxsIHRva2VucyB0aGF0IGFwcGVhciBpbiB0aGF0IHNlY3Rpb24gYW5kIDIpIHRoZSBpbmRleCBpbiB0aGUgb3JpZ2luYWxcbiAgICogdGVtcGxhdGUgdGhhdCByZXByZXNlbnRzIHRoZSBlbmQgb2YgdGhhdCBzZWN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gbmVzdFRva2VucyAodG9rZW5zKSB7XG4gICAgdmFyIG5lc3RlZFRva2VucyA9IFtdO1xuICAgIHZhciBjb2xsZWN0b3IgPSBuZXN0ZWRUb2tlbnM7XG4gICAgdmFyIHNlY3Rpb25zID0gW107XG5cbiAgICB2YXIgdG9rZW4sIHNlY3Rpb247XG4gICAgZm9yICh2YXIgaSA9IDAsIG51bVRva2VucyA9IHRva2Vucy5sZW5ndGg7IGkgPCBudW1Ub2tlbnM7ICsraSkge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIHN3aXRjaCAodG9rZW5bMF0pIHtcbiAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgIGNvbGxlY3Rvci5wdXNoKHRva2VuKTtcbiAgICAgICAgICBzZWN0aW9ucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb2xsZWN0b3IgPSB0b2tlbls0XSA9IFtdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICBzZWN0aW9uID0gc2VjdGlvbnMucG9wKCk7XG4gICAgICAgICAgc2VjdGlvbls1XSA9IHRva2VuWzJdO1xuICAgICAgICAgIGNvbGxlY3RvciA9IHNlY3Rpb25zLmxlbmd0aCA+IDAgPyBzZWN0aW9uc1tzZWN0aW9ucy5sZW5ndGggLSAxXVs0XSA6IG5lc3RlZFRva2VucztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb2xsZWN0b3IucHVzaCh0b2tlbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5lc3RlZFRva2VucztcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNpbXBsZSBzdHJpbmcgc2Nhbm5lciB0aGF0IGlzIHVzZWQgYnkgdGhlIHRlbXBsYXRlIHBhcnNlciB0byBmaW5kXG4gICAqIHRva2VucyBpbiB0ZW1wbGF0ZSBzdHJpbmdzLlxuICAgKi9cbiAgZnVuY3Rpb24gU2Nhbm5lciAoc3RyaW5nKSB7XG4gICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgdGhpcy50YWlsID0gc3RyaW5nO1xuICAgIHRoaXMucG9zID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdGFpbCBpcyBlbXB0eSAoZW5kIG9mIHN0cmluZykuXG4gICAqL1xuICBTY2FubmVyLnByb3RvdHlwZS5lb3MgPSBmdW5jdGlvbiBlb3MgKCkge1xuICAgIHJldHVybiB0aGlzLnRhaWwgPT09ICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmllcyB0byBtYXRjaCB0aGUgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgKiBSZXR1cm5zIHRoZSBtYXRjaGVkIHRleHQgaWYgaXQgY2FuIG1hdGNoLCB0aGUgZW1wdHkgc3RyaW5nIG90aGVyd2lzZS5cbiAgICovXG4gIFNjYW5uZXIucHJvdG90eXBlLnNjYW4gPSBmdW5jdGlvbiBzY2FuIChyZSkge1xuICAgIHZhciBtYXRjaCA9IHRoaXMudGFpbC5tYXRjaChyZSk7XG5cbiAgICBpZiAoIW1hdGNoIHx8IG1hdGNoLmluZGV4ICE9PSAwKVxuICAgICAgcmV0dXJuICcnO1xuXG4gICAgdmFyIHN0cmluZyA9IG1hdGNoWzBdO1xuXG4gICAgdGhpcy50YWlsID0gdGhpcy50YWlsLnN1YnN0cmluZyhzdHJpbmcubGVuZ3RoKTtcbiAgICB0aGlzLnBvcyArPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfTtcblxuICAvKipcbiAgICogU2tpcHMgYWxsIHRleHQgdW50aWwgdGhlIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbiBjYW4gYmUgbWF0Y2hlZC4gUmV0dXJuc1xuICAgKiB0aGUgc2tpcHBlZCBzdHJpbmcsIHdoaWNoIGlzIHRoZSBlbnRpcmUgdGFpbCBpZiBubyBtYXRjaCBjYW4gYmUgbWFkZS5cbiAgICovXG4gIFNjYW5uZXIucHJvdG90eXBlLnNjYW5VbnRpbCA9IGZ1bmN0aW9uIHNjYW5VbnRpbCAocmUpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLnRhaWwuc2VhcmNoKHJlKSwgbWF0Y2g7XG5cbiAgICBzd2l0Y2ggKGluZGV4KSB7XG4gICAgICBjYXNlIC0xOlxuICAgICAgICBtYXRjaCA9IHRoaXMudGFpbDtcbiAgICAgICAgdGhpcy50YWlsID0gJyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAwOlxuICAgICAgICBtYXRjaCA9ICcnO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG1hdGNoID0gdGhpcy50YWlsLnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5zdWJzdHJpbmcoaW5kZXgpO1xuICAgIH1cblxuICAgIHRoaXMucG9zICs9IG1hdGNoLmxlbmd0aDtcblxuICAgIHJldHVybiBtYXRjaDtcbiAgfTtcblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHJlbmRlcmluZyBjb250ZXh0IGJ5IHdyYXBwaW5nIGEgdmlldyBvYmplY3QgYW5kXG4gICAqIG1haW50YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgY29udGV4dC5cbiAgICovXG4gIGZ1bmN0aW9uIENvbnRleHQgKHZpZXcsIHBhcmVudENvbnRleHQpIHtcbiAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgIHRoaXMuY2FjaGUgPSB7ICcuJzogdGhpcy52aWV3IH07XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnRDb250ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY29udGV4dCB1c2luZyB0aGUgZ2l2ZW4gdmlldyB3aXRoIHRoaXMgY29udGV4dFxuICAgKiBhcyB0aGUgcGFyZW50LlxuICAgKi9cbiAgQ29udGV4dC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKHZpZXcpIHtcbiAgICByZXR1cm4gbmV3IENvbnRleHQodmlldywgdGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBuYW1lIGluIHRoaXMgY29udGV4dCwgdHJhdmVyc2luZ1xuICAgKiB1cCB0aGUgY29udGV4dCBoaWVyYXJjaHkgaWYgdGhlIHZhbHVlIGlzIGFic2VudCBpbiB0aGlzIGNvbnRleHQncyB2aWV3LlxuICAgKi9cbiAgQ29udGV4dC5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24gbG9va3VwIChuYW1lKSB7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZTtcblxuICAgIHZhciB2YWx1ZTtcbiAgICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHZhbHVlID0gY2FjaGVbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcywgaW50ZXJtZWRpYXRlVmFsdWUsIG5hbWVzLCBpbmRleCwgbG9va3VwSGl0ID0gZmFsc2U7XG5cbiAgICAgIHdoaWxlIChjb250ZXh0KSB7XG4gICAgICAgIGlmIChuYW1lLmluZGV4T2YoJy4nKSA+IDApIHtcbiAgICAgICAgICBpbnRlcm1lZGlhdGVWYWx1ZSA9IGNvbnRleHQudmlldztcbiAgICAgICAgICBuYW1lcyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgICBpbmRleCA9IDA7XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBVc2luZyB0aGUgZG90IG5vdGlvbiBwYXRoIGluIGBuYW1lYCwgd2UgZGVzY2VuZCB0aHJvdWdoIHRoZVxuICAgICAgICAgICAqIG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogVG8gYmUgY2VydGFpbiB0aGF0IHRoZSBsb29rdXAgaGFzIGJlZW4gc3VjY2Vzc2Z1bCwgd2UgaGF2ZSB0b1xuICAgICAgICAgICAqIGNoZWNrIGlmIHRoZSBsYXN0IG9iamVjdCBpbiB0aGUgcGF0aCBhY3R1YWxseSBoYXMgdGhlIHByb3BlcnR5XG4gICAgICAgICAgICogd2UgYXJlIGxvb2tpbmcgZm9yLiBXZSBzdG9yZSB0aGUgcmVzdWx0IGluIGBsb29rdXBIaXRgLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogVGhpcyBpcyBzcGVjaWFsbHkgbmVjZXNzYXJ5IGZvciB3aGVuIHRoZSB2YWx1ZSBoYXMgYmVlbiBzZXQgdG9cbiAgICAgICAgICAgKiBgdW5kZWZpbmVkYCBhbmQgd2Ugd2FudCB0byBhdm9pZCBsb29raW5nIHVwIHBhcmVudCBjb250ZXh0cy5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEluIHRoZSBjYXNlIHdoZXJlIGRvdCBub3RhdGlvbiBpcyB1c2VkLCB3ZSBjb25zaWRlciB0aGUgbG9va3VwXG4gICAgICAgICAgICogdG8gYmUgc3VjY2Vzc2Z1bCBldmVuIGlmIHRoZSBsYXN0IFwib2JqZWN0XCIgaW4gdGhlIHBhdGggaXNcbiAgICAgICAgICAgKiBub3QgYWN0dWFsbHkgYW4gb2JqZWN0IGJ1dCBhIHByaW1pdGl2ZSAoZS5nLiwgYSBzdHJpbmcsIG9yIGFuXG4gICAgICAgICAgICogaW50ZWdlciksIGJlY2F1c2UgaXQgaXMgc29tZXRpbWVzIHVzZWZ1bCB0byBhY2Nlc3MgYSBwcm9wZXJ0eVxuICAgICAgICAgICAqIG9mIGFuIGF1dG9ib3hlZCBwcmltaXRpdmUsIHN1Y2ggYXMgdGhlIGxlbmd0aCBvZiBhIHN0cmluZy5cbiAgICAgICAgICAgKiovXG4gICAgICAgICAgd2hpbGUgKGludGVybWVkaWF0ZVZhbHVlICE9IG51bGwgJiYgaW5kZXggPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gbmFtZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgbG9va3VwSGl0ID0gKFxuICAgICAgICAgICAgICAgIGhhc1Byb3BlcnR5KGludGVybWVkaWF0ZVZhbHVlLCBuYW1lc1tpbmRleF0pIFxuICAgICAgICAgICAgICAgIHx8IHByaW1pdGl2ZUhhc093blByb3BlcnR5KGludGVybWVkaWF0ZVZhbHVlLCBuYW1lc1tpbmRleF0pXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGludGVybWVkaWF0ZVZhbHVlID0gaW50ZXJtZWRpYXRlVmFsdWVbbmFtZXNbaW5kZXgrK11dO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnRlcm1lZGlhdGVWYWx1ZSA9IGNvbnRleHQudmlld1tuYW1lXTtcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIE9ubHkgY2hlY2tpbmcgYWdhaW5zdCBgaGFzUHJvcGVydHlgLCB3aGljaCBhbHdheXMgcmV0dXJucyBgZmFsc2VgIGlmXG4gICAgICAgICAgICogYGNvbnRleHQudmlld2AgaXMgbm90IGFuIG9iamVjdC4gRGVsaWJlcmF0ZWx5IG9taXR0aW5nIHRoZSBjaGVja1xuICAgICAgICAgICAqIGFnYWluc3QgYHByaW1pdGl2ZUhhc093blByb3BlcnR5YCBpZiBkb3Qgbm90YXRpb24gaXMgbm90IHVzZWQuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBDb25zaWRlciB0aGlzIGV4YW1wbGU6XG4gICAgICAgICAgICogYGBgXG4gICAgICAgICAgICogTXVzdGFjaGUucmVuZGVyKFwiVGhlIGxlbmd0aCBvZiBhIGZvb3RiYWxsIGZpZWxkIGlzIHt7I2xlbmd0aH19e3tsZW5ndGh9fXt7L2xlbmd0aH19LlwiLCB7bGVuZ3RoOiBcIjEwMCB5YXJkc1wifSlcbiAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIElmIHdlIHdlcmUgdG8gY2hlY2sgYWxzbyBhZ2FpbnN0IGBwcmltaXRpdmVIYXNPd25Qcm9wZXJ0eWAsIGFzIHdlIGRvXG4gICAgICAgICAgICogaW4gdGhlIGRvdCBub3RhdGlvbiBjYXNlLCB0aGVuIHJlbmRlciBjYWxsIHdvdWxkIHJldHVybjpcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFwiVGhlIGxlbmd0aCBvZiBhIGZvb3RiYWxsIGZpZWxkIGlzIDkuXCJcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIHJhdGhlciB0aGFuIHRoZSBleHBlY3RlZDpcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFwiVGhlIGxlbmd0aCBvZiBhIGZvb3RiYWxsIGZpZWxkIGlzIDEwMCB5YXJkcy5cIlxuICAgICAgICAgICAqKi9cbiAgICAgICAgICBsb29rdXBIaXQgPSBoYXNQcm9wZXJ0eShjb250ZXh0LnZpZXcsIG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvb2t1cEhpdCkge1xuICAgICAgICAgIHZhbHVlID0gaW50ZXJtZWRpYXRlVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0ID0gY29udGV4dC5wYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIGNhY2hlW25hbWVdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKVxuICAgICAgdmFsdWUgPSB2YWx1ZS5jYWxsKHRoaXMudmlldyk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgV3JpdGVyIGtub3dzIGhvdyB0byB0YWtlIGEgc3RyZWFtIG9mIHRva2VucyBhbmQgcmVuZGVyIHRoZW0gdG8gYVxuICAgKiBzdHJpbmcsIGdpdmVuIGEgY29udGV4dC4gSXQgYWxzbyBtYWludGFpbnMgYSBjYWNoZSBvZiB0ZW1wbGF0ZXMgdG9cbiAgICogYXZvaWQgdGhlIG5lZWQgdG8gcGFyc2UgdGhlIHNhbWUgdGVtcGxhdGUgdHdpY2UuXG4gICAqL1xuICBmdW5jdGlvbiBXcml0ZXIgKCkge1xuICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgYWxsIGNhY2hlZCB0ZW1wbGF0ZXMgaW4gdGhpcyB3cml0ZXIuXG4gICAqL1xuICBXcml0ZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlICgpIHtcbiAgICB0aGlzLmNhY2hlID0ge307XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbmQgY2FjaGVzIHRoZSBnaXZlbiBgdGVtcGxhdGVgIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gYHRhZ3NgIG9yXG4gICAqIGBtdXN0YWNoZS50YWdzYCBpZiBgdGFnc2AgaXMgb21pdHRlZCwgIGFuZCByZXR1cm5zIHRoZSBhcnJheSBvZiB0b2tlbnNcbiAgICogdGhhdCBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgcGFyc2UuXG4gICAqL1xuICBXcml0ZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKHRlbXBsYXRlLCB0YWdzKSB7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZTtcbiAgICB2YXIgY2FjaGVLZXkgPSB0ZW1wbGF0ZSArICc6JyArICh0YWdzIHx8IG11c3RhY2hlLnRhZ3MpLmpvaW4oJzonKTtcbiAgICB2YXIgdG9rZW5zID0gY2FjaGVbY2FjaGVLZXldO1xuXG4gICAgaWYgKHRva2VucyA9PSBudWxsKVxuICAgICAgdG9rZW5zID0gY2FjaGVbY2FjaGVLZXldID0gcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgdGFncyk7XG5cbiAgICByZXR1cm4gdG9rZW5zO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIaWdoLWxldmVsIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gcmVuZGVyIHRoZSBnaXZlbiBgdGVtcGxhdGVgIHdpdGhcbiAgICogdGhlIGdpdmVuIGB2aWV3YC5cbiAgICpcbiAgICogVGhlIG9wdGlvbmFsIGBwYXJ0aWFsc2AgYXJndW1lbnQgbWF5IGJlIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZVxuICAgKiBuYW1lcyBhbmQgdGVtcGxhdGVzIG9mIHBhcnRpYWxzIHRoYXQgYXJlIHVzZWQgaW4gdGhlIHRlbXBsYXRlLiBJdCBtYXlcbiAgICogYWxzbyBiZSBhIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBsb2FkIHBhcnRpYWwgdGVtcGxhdGVzIG9uIHRoZSBmbHlcbiAgICogdGhhdCB0YWtlcyBhIHNpbmdsZSBhcmd1bWVudDogdGhlIG5hbWUgb2YgdGhlIHBhcnRpYWwuXG4gICAqXG4gICAqIElmIHRoZSBvcHRpb25hbCBgdGFnc2AgYXJndW1lbnQgaXMgZ2l2ZW4gaGVyZSBpdCBtdXN0IGJlIGFuIGFycmF5IHdpdGggdHdvXG4gICAqIHN0cmluZyB2YWx1ZXM6IHRoZSBvcGVuaW5nIGFuZCBjbG9zaW5nIHRhZ3MgdXNlZCBpbiB0aGUgdGVtcGxhdGUgKGUuZy5cbiAgICogWyBcIjwlXCIsIFwiJT5cIiBdKS4gVGhlIGRlZmF1bHQgaXMgdG8gbXVzdGFjaGUudGFncy5cbiAgICovXG4gIFdyaXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICh0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMsIHRhZ3MpIHtcbiAgICB2YXIgdG9rZW5zID0gdGhpcy5wYXJzZSh0ZW1wbGF0ZSwgdGFncyk7XG4gICAgdmFyIGNvbnRleHQgPSAodmlldyBpbnN0YW5jZW9mIENvbnRleHQpID8gdmlldyA6IG5ldyBDb250ZXh0KHZpZXcpO1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRva2Vucyh0b2tlbnMsIGNvbnRleHQsIHBhcnRpYWxzLCB0ZW1wbGF0ZSwgdGFncyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIExvdy1sZXZlbCBtZXRob2QgdGhhdCByZW5kZXJzIHRoZSBnaXZlbiBhcnJheSBvZiBgdG9rZW5zYCB1c2luZ1xuICAgKiB0aGUgZ2l2ZW4gYGNvbnRleHRgIGFuZCBgcGFydGlhbHNgLlxuICAgKlxuICAgKiBOb3RlOiBUaGUgYG9yaWdpbmFsVGVtcGxhdGVgIGlzIG9ubHkgZXZlciB1c2VkIHRvIGV4dHJhY3QgdGhlIHBvcnRpb25cbiAgICogb2YgdGhlIG9yaWdpbmFsIHRlbXBsYXRlIHRoYXQgd2FzIGNvbnRhaW5lZCBpbiBhIGhpZ2hlci1vcmRlciBzZWN0aW9uLlxuICAgKiBJZiB0aGUgdGVtcGxhdGUgZG9lc24ndCB1c2UgaGlnaGVyLW9yZGVyIHNlY3Rpb25zLCB0aGlzIGFyZ3VtZW50IG1heVxuICAgKiBiZSBvbWl0dGVkLlxuICAgKi9cbiAgV3JpdGVyLnByb3RvdHlwZS5yZW5kZXJUb2tlbnMgPSBmdW5jdGlvbiByZW5kZXJUb2tlbnMgKHRva2VucywgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUsIHRhZ3MpIHtcbiAgICB2YXIgYnVmZmVyID0gJyc7XG5cbiAgICB2YXIgdG9rZW4sIHN5bWJvbCwgdmFsdWU7XG4gICAgZm9yICh2YXIgaSA9IDAsIG51bVRva2VucyA9IHRva2Vucy5sZW5ndGg7IGkgPCBudW1Ub2tlbnM7ICsraSkge1xuICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgIHN5bWJvbCA9IHRva2VuWzBdO1xuXG4gICAgICBpZiAoc3ltYm9sID09PSAnIycpIHZhbHVlID0gdGhpcy5yZW5kZXJTZWN0aW9uKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgICBlbHNlIGlmIChzeW1ib2wgPT09ICdeJykgdmFsdWUgPSB0aGlzLnJlbmRlckludmVydGVkKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgICBlbHNlIGlmIChzeW1ib2wgPT09ICc+JykgdmFsdWUgPSB0aGlzLnJlbmRlclBhcnRpYWwodG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCB0YWdzKTtcbiAgICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJyYnKSB2YWx1ZSA9IHRoaXMudW5lc2NhcGVkVmFsdWUodG9rZW4sIGNvbnRleHQpO1xuICAgICAgZWxzZSBpZiAoc3ltYm9sID09PSAnbmFtZScpIHZhbHVlID0gdGhpcy5lc2NhcGVkVmFsdWUodG9rZW4sIGNvbnRleHQpO1xuICAgICAgZWxzZSBpZiAoc3ltYm9sID09PSAndGV4dCcpIHZhbHVlID0gdGhpcy5yYXdWYWx1ZSh0b2tlbik7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBidWZmZXIgKz0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfTtcblxuICBXcml0ZXIucHJvdG90eXBlLnJlbmRlclNlY3Rpb24gPSBmdW5jdGlvbiByZW5kZXJTZWN0aW9uICh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGJ1ZmZlciA9ICcnO1xuICAgIHZhciB2YWx1ZSA9IGNvbnRleHQubG9va3VwKHRva2VuWzFdKTtcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByZW5kZXIgYW4gYXJiaXRyYXJ5IHRlbXBsYXRlXG4gICAgLy8gaW4gdGhlIGN1cnJlbnQgY29udGV4dCBieSBoaWdoZXItb3JkZXIgc2VjdGlvbnMuXG4gICAgZnVuY3Rpb24gc3ViUmVuZGVyICh0ZW1wbGF0ZSkge1xuICAgICAgcmV0dXJuIHNlbGYucmVuZGVyKHRlbXBsYXRlLCBjb250ZXh0LCBwYXJ0aWFscyk7XG4gICAgfVxuXG4gICAgaWYgKCF2YWx1ZSkgcmV0dXJuO1xuXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBmb3IgKHZhciBqID0gMCwgdmFsdWVMZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGogPCB2YWx1ZUxlbmd0aDsgKytqKSB7XG4gICAgICAgIGJ1ZmZlciArPSB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dC5wdXNoKHZhbHVlW2pdKSwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGJ1ZmZlciArPSB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dC5wdXNoKHZhbHVlKSwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxUZW1wbGF0ZSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVzZSBoaWdoZXItb3JkZXIgc2VjdGlvbnMgd2l0aG91dCB0aGUgb3JpZ2luYWwgdGVtcGxhdGUnKTtcblxuICAgICAgLy8gRXh0cmFjdCB0aGUgcG9ydGlvbiBvZiB0aGUgb3JpZ2luYWwgdGVtcGxhdGUgdGhhdCB0aGUgc2VjdGlvbiBjb250YWlucy5cbiAgICAgIHZhbHVlID0gdmFsdWUuY2FsbChjb250ZXh0LnZpZXcsIG9yaWdpbmFsVGVtcGxhdGUuc2xpY2UodG9rZW5bM10sIHRva2VuWzVdKSwgc3ViUmVuZGVyKTtcblxuICAgICAgaWYgKHZhbHVlICE9IG51bGwpXG4gICAgICAgIGJ1ZmZlciArPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyICs9IHRoaXMucmVuZGVyVG9rZW5zKHRva2VuWzRdLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG4gIH07XG5cbiAgV3JpdGVyLnByb3RvdHlwZS5yZW5kZXJJbnZlcnRlZCA9IGZ1bmN0aW9uIHJlbmRlckludmVydGVkICh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpIHtcbiAgICB2YXIgdmFsdWUgPSBjb250ZXh0Lmxvb2t1cCh0b2tlblsxXSk7XG5cbiAgICAvLyBVc2UgSmF2YVNjcmlwdCdzIGRlZmluaXRpb24gb2YgZmFsc3kuIEluY2x1ZGUgZW1wdHkgYXJyYXlzLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFubC9tdXN0YWNoZS5qcy9pc3N1ZXMvMTg2XG4gICAgaWYgKCF2YWx1ZSB8fCAoaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSlcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICB9O1xuXG4gIFdyaXRlci5wcm90b3R5cGUucmVuZGVyUGFydGlhbCA9IGZ1bmN0aW9uIHJlbmRlclBhcnRpYWwgKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgdGFncykge1xuICAgIGlmICghcGFydGlhbHMpIHJldHVybjtcblxuICAgIHZhciB2YWx1ZSA9IGlzRnVuY3Rpb24ocGFydGlhbHMpID8gcGFydGlhbHModG9rZW5bMV0pIDogcGFydGlhbHNbdG9rZW5bMV1dO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyVG9rZW5zKHRoaXMucGFyc2UodmFsdWUsIHRhZ3MpLCBjb250ZXh0LCBwYXJ0aWFscywgdmFsdWUpO1xuICB9O1xuXG4gIFdyaXRlci5wcm90b3R5cGUudW5lc2NhcGVkVmFsdWUgPSBmdW5jdGlvbiB1bmVzY2FwZWRWYWx1ZSAodG9rZW4sIGNvbnRleHQpIHtcbiAgICB2YXIgdmFsdWUgPSBjb250ZXh0Lmxvb2t1cCh0b2tlblsxXSk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpXG4gICAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgV3JpdGVyLnByb3RvdHlwZS5lc2NhcGVkVmFsdWUgPSBmdW5jdGlvbiBlc2NhcGVkVmFsdWUgKHRva2VuLCBjb250ZXh0KSB7XG4gICAgdmFyIHZhbHVlID0gY29udGV4dC5sb29rdXAodG9rZW5bMV0pO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgICAgcmV0dXJuIG11c3RhY2hlLmVzY2FwZSh2YWx1ZSk7XG4gIH07XG5cbiAgV3JpdGVyLnByb3RvdHlwZS5yYXdWYWx1ZSA9IGZ1bmN0aW9uIHJhd1ZhbHVlICh0b2tlbikge1xuICAgIHJldHVybiB0b2tlblsxXTtcbiAgfTtcblxuICBtdXN0YWNoZS5uYW1lID0gJ211c3RhY2hlLmpzJztcbiAgbXVzdGFjaGUudmVyc2lvbiA9ICczLjAuMSc7XG4gIG11c3RhY2hlLnRhZ3MgPSBbICd7eycsICd9fScgXTtcblxuICAvLyBBbGwgaGlnaC1sZXZlbCBtdXN0YWNoZS4qIGZ1bmN0aW9ucyB1c2UgdGhpcyB3cml0ZXIuXG4gIHZhciBkZWZhdWx0V3JpdGVyID0gbmV3IFdyaXRlcigpO1xuXG4gIC8qKlxuICAgKiBDbGVhcnMgYWxsIGNhY2hlZCB0ZW1wbGF0ZXMgaW4gdGhlIGRlZmF1bHQgd3JpdGVyLlxuICAgKi9cbiAgbXVzdGFjaGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIGNsZWFyQ2FjaGUgKCkge1xuICAgIHJldHVybiBkZWZhdWx0V3JpdGVyLmNsZWFyQ2FjaGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2VzIGFuZCBjYWNoZXMgdGhlIGdpdmVuIHRlbXBsYXRlIGluIHRoZSBkZWZhdWx0IHdyaXRlciBhbmQgcmV0dXJucyB0aGVcbiAgICogYXJyYXkgb2YgdG9rZW5zIGl0IGNvbnRhaW5zLiBEb2luZyB0aGlzIGFoZWFkIG9mIHRpbWUgYXZvaWRzIHRoZSBuZWVkIHRvXG4gICAqIHBhcnNlIHRlbXBsYXRlcyBvbiB0aGUgZmx5IGFzIHRoZXkgYXJlIHJlbmRlcmVkLlxuICAgKi9cbiAgbXVzdGFjaGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAodGVtcGxhdGUsIHRhZ3MpIHtcbiAgICByZXR1cm4gZGVmYXVsdFdyaXRlci5wYXJzZSh0ZW1wbGF0ZSwgdGFncyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGB0ZW1wbGF0ZWAgd2l0aCB0aGUgZ2l2ZW4gYHZpZXdgIGFuZCBgcGFydGlhbHNgIHVzaW5nIHRoZVxuICAgKiBkZWZhdWx0IHdyaXRlci4gSWYgdGhlIG9wdGlvbmFsIGB0YWdzYCBhcmd1bWVudCBpcyBnaXZlbiBoZXJlIGl0IG11c3QgYmUgYW5cbiAgICogYXJyYXkgd2l0aCB0d28gc3RyaW5nIHZhbHVlczogdGhlIG9wZW5pbmcgYW5kIGNsb3NpbmcgdGFncyB1c2VkIGluIHRoZVxuICAgKiB0ZW1wbGF0ZSAoZS5nLiBbIFwiPCVcIiwgXCIlPlwiIF0pLiBUaGUgZGVmYXVsdCBpcyB0byBtdXN0YWNoZS50YWdzLlxuICAgKi9cbiAgbXVzdGFjaGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICh0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMsIHRhZ3MpIHtcbiAgICBpZiAodHlwZW9mIHRlbXBsYXRlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB0ZW1wbGF0ZSEgVGVtcGxhdGUgc2hvdWxkIGJlIGEgXCJzdHJpbmdcIiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2J1dCBcIicgKyB0eXBlU3RyKHRlbXBsYXRlKSArICdcIiB3YXMgZ2l2ZW4gYXMgdGhlIGZpcnN0ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYXJndW1lbnQgZm9yIG11c3RhY2hlI3JlbmRlcih0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMpJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmF1bHRXcml0ZXIucmVuZGVyKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscywgdGFncyk7XG4gIH07XG5cbiAgLy8gVGhpcyBpcyBoZXJlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIDAuNC54LixcbiAgLyplc2xpbnQtZGlzYWJsZSAqLyAvLyBlc2xpbnQgd2FudHMgY2FtZWwgY2FzZWQgZnVuY3Rpb24gbmFtZVxuICBtdXN0YWNoZS50b19odG1sID0gZnVuY3Rpb24gdG9faHRtbCAodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzLCBzZW5kKSB7XG4gICAgLyplc2xpbnQtZW5hYmxlKi9cblxuICAgIHZhciByZXN1bHQgPSBtdXN0YWNoZS5yZW5kZXIodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzKTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKHNlbmQpKSB7XG4gICAgICBzZW5kKHJlc3VsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9O1xuXG4gIC8vIEV4cG9ydCB0aGUgZXNjYXBpbmcgZnVuY3Rpb24gc28gdGhhdCB0aGUgdXNlciBtYXkgb3ZlcnJpZGUgaXQuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFubC9tdXN0YWNoZS5qcy9pc3N1ZXMvMjQ0XG4gIG11c3RhY2hlLmVzY2FwZSA9IGVzY2FwZUh0bWw7XG5cbiAgLy8gRXhwb3J0IHRoZXNlIG1haW5seSBmb3IgdGVzdGluZywgYnV0IGFsc28gZm9yIGFkdmFuY2VkIHVzYWdlLlxuICBtdXN0YWNoZS5TY2FubmVyID0gU2Nhbm5lcjtcbiAgbXVzdGFjaGUuQ29udGV4dCA9IENvbnRleHQ7XG4gIG11c3RhY2hlLldyaXRlciA9IFdyaXRlcjtcblxuICByZXR1cm4gbXVzdGFjaGU7XG59KSk7XG5cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/persian-datepicker/dist/js/persian-datepicker.js\n");

/***/ })

}]);